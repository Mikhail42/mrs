// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package com.ionkin.mrs.hl7.fhir


/** A date or partial date (e.g. just year or year + month). There is no time zone. The format is a union of the schema types gYear, gYearMonth and date.  Dates SHALL be valid dates.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DateType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[String]}
}

      


/** A date, date-time or partial date (e.g. just year or year + month).  If hours and minutes are specified, a time zone SHALL be populated. The format is a union of the schema types gYear, gYearMonth, date and dateTime. Seconds must be provided due to schema type constraints but may be zero-filled and may be ignored.                 Dates SHALL be valid dates.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DateTimeType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[String]}
}

      


/** A string which has at least one character and no leading or trailing whitespace and where there is no whitespace other than single spaces in the contentsIf the element is present, it must have either a @value, an @id referenced from the Narrative, or extensions
*/
case class CodeType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[String]}
}

      


/** A sequence of Unicode charactersNote that FHIR strings may not exceed 1MB in sizeIf the element is present, it must have either a @value, an @id, or extensions
*/
case class StringTypeType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[String]}
}

      


/** A whole number32 bit number; for values larger than this, use decimalIf the element is present, it must have either a @value, an @id, or extensions
*/
case class IntegerType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[Int]}
}

      


/** An OID represented as a URIRFC 3001. See also ISO/IEC 8824:1990 â‚¬If the element is present, it must have either a @value, an @id referenced from the Narrative, or extensions
*/
case class OidType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[java.net.URI]}
}

      


/** String of characters used to identify a name or a resourcesee http://en.wikipedia.org/wiki/Uniform_resource_identifierIf the element is present, it must have either a @value, an @id, or extensions
*/
case class UriType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[java.net.URI]}
}

      


/** A UUID, represented as a URISee The Open Group, CDE 1.1 Remote Procedure Call specification, Appendix A.If the element is present, it must have either a @value, an @id referenced from the Narrative, or extensions
*/
case class UuidType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[java.net.URI]}
}

      


/** An instant in time - known at least to the secondNote: This is intended for precisely observed times, typically system logs etc., and not human-reported times - for them, see date and dateTime below. Time zone is always requiredIf the element is present, it must have either a @value, an @id, or extensions
*/
case class InstantType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[javax.xml.datatype.XMLGregorianCalendar]}
}

      


/** Value of "true" or "false"If the element is present, it must have either a @value, an @id, or extensions
*/
case class BooleanTypeType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[Boolean]}
}

      


/** A stream of bytesA stream of bytes, base64 encodedIf the element is present, it must have either a @value, an @id, or extensions
*/
case class Base64BinaryTypeType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[scalaxb.Base64Binary]}
}

      


/** An integer with a value that is not negative (e.g. >= 0)If the element is present, it must have either a @value, an @id referenced from the Narrative, or extensions
*/
case class UnsignedIntType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[BigInt]}
}

      


/** A string that may contain markdown syntax for optional processing by a mark down presentation engineSystems are not required to have markdown support, and there is considerable variation in markdown syntax, so the text should be readable without markdown processing. The preferred markdown syntax is described here: http://daringfireball.net/projects/markdown/syntax (and tests here: http://daringfireball.net/projects/downloads/MarkdownTest_1.0.zip)If the element is present, it must have either a @value, an @id referenced from the Narrative, or extensions
*/
case class MarkdownType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[String]}
}

      


/** A time during the day, with no date specifiedIf the element is present, it must have either a @value, an @id, or extensions
*/
case class TimeType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[javax.xml.datatype.XMLGregorianCalendar]}
}

      


/** Any combination of letters, numerals, "-" and ".", with a length limit of 64 characters.  (This might be an integer, an unprefixed OID, UUID or any other identifier pattern that meets these constraints.)  Ids are case-insensitive.RFC 4122If the element is present, it must have either a @value, an @id referenced from the Narrative, or extensions
*/
case class IdType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[String]}
}

      


/** An integer with a value that is positive (e.g. >0)If the element is present, it must have either a @value, an @id referenced from the Narrative, or extensions
*/
case class PositiveIntType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[BigInt]}
}

      


/** A rational number with implicit precisionDo not use a IEEE type floating point type, instead use something that works like a true decimal, with inbuilt precision (e.g. Java BigInteger)If the element is present, it must have either a @value, an @id, or extensions
*/
case class DecimalType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[BigDecimal]}
}

      


case class ResourceContainer(Account: Option[AccountType] = None,
  ActivityDefinition: Option[ActivityDefinitionType] = None,
  AdverseEvent: Option[AdverseEventType] = None,
  AllergyIntolerance: Option[AllergyIntoleranceType] = None,
  Appointment: Option[AppointmentType] = None,
  AppointmentResponse: Option[AppointmentResponseType] = None,
  AuditEvent: Option[AuditEventType] = None,
  Basic: Option[BasicType] = None,
  Binary: Option[BinaryType] = None,
  BodySite: Option[BodySiteType] = None,
  Bundle: Option[BundleType] = None,
  CapabilityStatement: Option[CapabilityStatementType] = None,
  CarePlan: Option[CarePlanType] = None,
  CareTeam: Option[CareTeamType] = None,
  ChargeItem: Option[ChargeItemType] = None,
  Claim: Option[ClaimType] = None,
  ClaimResponse: Option[ClaimResponseType] = None,
  ClinicalImpression: Option[ClinicalImpressionType] = None,
  CodeSystem: Option[CodeSystemType] = None,
  Communication: Option[CommunicationType] = None,
  CommunicationRequest: Option[CommunicationRequestType] = None,
  CompartmentDefinition: Option[CompartmentDefinitionType] = None,
  Composition: Option[CompositionType] = None,
  ConceptMap: Option[ConceptMapType] = None,
  Condition: Option[ConditionType] = None,
  Consent: Option[ConsentType] = None,
  Contract: Option[ContractType] = None,
  Coverage: Option[CoverageType] = None,
  DataElement: Option[DataElementType] = None,
  DetectedIssue: Option[DetectedIssueType] = None,
  Device: Option[DeviceType] = None,
  DeviceComponent: Option[DeviceComponentType] = None,
  DeviceMetric: Option[DeviceMetricType] = None,
  DeviceRequest: Option[DeviceRequestType] = None,
  DeviceUseStatement: Option[DeviceUseStatementType] = None,
  DiagnosticReport: Option[DiagnosticReportType] = None,
  DocumentManifest: Option[DocumentManifestType] = None,
  DocumentReference: Option[DocumentReferenceType] = None,
  EligibilityRequest: Option[EligibilityRequestType] = None,
  EligibilityResponse: Option[EligibilityResponseType] = None,
  Encounter: Option[EncounterType] = None,
  Endpoint: Option[EndpointType] = None,
  EnrollmentRequest: Option[EnrollmentRequestType] = None,
  EnrollmentResponse: Option[EnrollmentResponseType] = None,
  EpisodeOfCare: Option[EpisodeOfCareType] = None,
  ExpansionProfile: Option[ExpansionProfileType] = None,
  ExplanationOfBenefit: Option[ExplanationOfBenefitType] = None,
  FamilyMemberHistory: Option[FamilyMemberHistoryType] = None,
  Flag: Option[FlagType] = None,
  Goal: Option[GoalType] = None,
  GraphDefinition: Option[GraphDefinitionType] = None,
  Group: Option[GroupType2] = None,
  GuidanceResponse: Option[GuidanceResponseType] = None,
  HealthcareService: Option[HealthcareServiceType] = None,
  ImagingManifest: Option[ImagingManifestType] = None,
  ImagingStudy: Option[ImagingStudyType] = None,
  Immunization: Option[ImmunizationType] = None,
  ImmunizationRecommendation: Option[ImmunizationRecommendationType] = None,
  ImplementationGuide: Option[ImplementationGuideType] = None,
  Library: Option[LibraryType] = None,
  Linkage: Option[LinkageType] = None,
  ListValue: Option[ListTypeType] = None,
  Location: Option[LocationType] = None,
  Measure: Option[MeasureType] = None,
  MeasureReport: Option[MeasureReportType2] = None,
  Media: Option[MediaType] = None,
  Medication: Option[MedicationType] = None,
  MedicationAdministration: Option[MedicationAdministrationType] = None,
  MedicationDispense: Option[MedicationDispenseType] = None,
  MedicationRequest: Option[MedicationRequestType] = None,
  MedicationStatement: Option[MedicationStatementType] = None,
  MessageDefinition: Option[MessageDefinitionType] = None,
  MessageHeader: Option[MessageHeaderType] = None,
  NamingSystem: Option[NamingSystemType2] = None,
  NutritionOrder: Option[NutritionOrderType] = None,
  Observation: Option[ObservationType] = None,
  OperationDefinition: Option[OperationDefinitionType] = None,
  OperationOutcome: Option[OperationOutcomeType] = None,
  Organization: Option[OrganizationType] = None,
  Patient: Option[PatientType] = None,
  PaymentNotice: Option[PaymentNoticeType] = None,
  PaymentReconciliation: Option[PaymentReconciliationType] = None,
  Person: Option[PersonType] = None,
  PlanDefinition: Option[PlanDefinitionType] = None,
  Practitioner: Option[PractitionerType] = None,
  PractitionerRole: Option[PractitionerRoleType] = None,
  Procedure: Option[ProcedureType] = None,
  ProcedureRequest: Option[ProcedureRequestType] = None,
  ProcessRequest: Option[ProcessRequestType] = None,
  ProcessResponse: Option[ProcessResponseType] = None,
  Provenance: Option[ProvenanceType] = None,
  Questionnaire: Option[QuestionnaireType] = None,
  QuestionnaireResponse: Option[QuestionnaireResponseType] = None,
  ReferralRequest: Option[ReferralRequestType] = None,
  RelatedPerson: Option[RelatedPersonType] = None,
  RequestGroup: Option[RequestGroupType] = None,
  ResearchStudy: Option[ResearchStudyType] = None,
  ResearchSubject: Option[ResearchSubjectType] = None,
  RiskAssessment: Option[RiskAssessmentType] = None,
  Schedule: Option[ScheduleType] = None,
  SearchParameter: Option[SearchParameterType] = None,
  Sequence: Option[SequenceType] = None,
  ServiceDefinition: Option[ServiceDefinitionType] = None,
  Slot: Option[SlotType] = None,
  Specimen: Option[SpecimenType] = None,
  StructureDefinition: Option[StructureDefinitionType] = None,
  StructureMap: Option[StructureMapType] = None,
  Subscription: Option[SubscriptionType] = None,
  Substance: Option[SubstanceType] = None,
  SupplyDelivery: Option[SupplyDeliveryType] = None,
  SupplyRequest: Option[SupplyRequestType] = None,
  Task: Option[TaskType] = None,
  TestReport: Option[TestReportType] = None,
  TestScript: Option[TestScriptType] = None,
  ValueSet: Option[ValueSet] = None,
  VisionPrescription: Option[VisionPrescriptionType] = None,
  Parameters: Option[ParametersType] = None)
      


/** Optional Extension Element - found in all resources.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ExtensionType(extension: Seq[ExtensionType] = Nil,
  valueBase64Binary: Option[Base64BinaryTypeType] = None,
  valueBoolean: Option[BooleanTypeType] = None,
  valueCode: Option[CodeType] = None,
  valueDate: Option[DateType] = None,
  valueDateTime: Option[DateTimeType] = None,
  valueDecimal: Option[DecimalType] = None,
  valueId: Option[IdType] = None,
  valueInstant: Option[InstantType] = None,
  valueInteger: Option[IntegerType] = None,
  valueMarkdown: Option[MarkdownType] = None,
  valueOid: Option[OidType] = None,
  valuePositiveInt: Option[PositiveIntType] = None,
  valueString: Option[StringTypeType] = None,
  valueTime: Option[TimeType] = None,
  valueUnsignedInt: Option[UnsignedIntType] = None,
  valueUri: Option[UriType] = None,
  valueAddress: Option[AddressType2] = None,
  valueAge: Option[AgeType] = None,
  valueAnnotation: Option[AnnotationType] = None,
  valueAttachment: Option[AttachmentType] = None,
  valueCodeableConcept: Option[CodeableConceptType] = None,
  valueCoding: Option[CodingType] = None,
  valueContactPoint: Option[ContactPointType] = None,
  valueCount: Option[CountType] = None,
  valueDistance: Option[DistanceType] = None,
  valueDuration: Option[DurationType] = None,
  valueHumanName: Option[HumanNameType] = None,
  valueIdentifier: Option[IdentifierType] = None,
  valueMoney: Option[MoneyType] = None,
  valuePeriod: Option[PeriodType] = None,
  valueQuantity: Option[Quantityable] = None,
  valueRange: Option[RangeTypeType] = None,
  valueRatio: Option[RatioType] = None,
  valueReference: Option[ReferenceType] = None,
  valueSampledData: Option[SampledDataType] = None,
  valueSignature: Option[SignatureType] = None,
  valueTiming: Option[TimingType] = None,
  valueMeta: Option[MetaType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val url = attributes("@url").as[java.net.URI]
}

      


/** Base definition for all elements that are defined inside a resource - but not those in a data type.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
trait BackboneElementable extends Elementable {
  def extension: Seq[ExtensionType]
  def modifierExtension: Seq[ExtensionType]
  def id: Option[String]
}


/** Base definition for all elements that are defined inside a resource - but not those in a data type.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class BackboneElementType(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A human-readable formatted text, including images.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class NarrativeType(extension: Seq[ExtensionType] = Nil,
  status: NarrativeStatus,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait NarrativeStatusu45list

object NarrativeStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[NarrativeStatusu45list]): NarrativeStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: NarrativeStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[NarrativeStatusu45list] = Seq(Generated, ExtensionsValue, Additional, EmptyValue)
}

case object Generated extends NarrativeStatusu45list { override def toString = "generated" }
case object ExtensionsValue extends NarrativeStatusu45list { override def toString = "extensions" }
case object Additional extends NarrativeStatusu45list { override def toString = "additional" }
case object EmptyValue extends NarrativeStatusu45list { override def toString = "empty" }


/** The status of a resource narrativeIf the element is present, it must have either a @value, an @id, or extensions
*/
case class NarrativeStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[NarrativeStatusu45list]}
}

      


/** Base definition for all elements in a resource.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
trait Elementable {
  def extension: Seq[ExtensionType]
  def id: Option[String]
}


/** Base definition for all elements in a resource.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ElementType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A reference from one resource to another.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ReferenceType(extension: Seq[ExtensionType] = Nil,
  reference: Option[StringTypeType] = None,
  identifier: Option[IdentifierType] = None,
  display: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
trait Quantityable extends Elementable {
  def extension: Seq[ExtensionType]
  def value: Option[DecimalType]
  def comparator: Option[QuantityComparator]
  def unit: Option[StringTypeType]
  def system: Option[UriType]
  def code: Option[CodeType]
  def id: Option[String]
}


/** A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class QuantityType(extension: Seq[ExtensionType] = Nil,
  value: Option[DecimalType] = None,
  comparator: Option[QuantityComparator] = None,
  unit: Option[StringTypeType] = None,
  system: Option[UriType] = None,
  code: Option[CodeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Quantityable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait QuantityComparatoru45list

object QuantityComparatoru45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[QuantityComparatoru45list]): QuantityComparatoru45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: QuantityComparatoru45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[QuantityComparatoru45list] = Seq(U60, U60u61, U62u61, U62)
}

case object U60 extends QuantityComparatoru45list { override def toString = "<" }
case object U60u61 extends QuantityComparatoru45list { override def toString = "<=" }
case object U62u61 extends QuantityComparatoru45list { override def toString = ">=" }
case object U62 extends QuantityComparatoru45list { override def toString = ">" }


/** How the Quantity should be understood and represented.If the element is present, it must have either a @value, an @id, or extensions
*/
case class QuantityComparator(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[QuantityComparatoru45list]}
}

      


/** A time period defined by a start and end date and optionally time.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class PeriodType(extension: Seq[ExtensionType] = Nil,
  start: Option[DateTimeType] = None,
  end: Option[DateTimeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** For referring to data content defined in other formats.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class AttachmentType(extension: Seq[ExtensionType] = Nil,
  contentType: Option[CodeType] = None,
  language: Option[CodeType] = None,
  data: Option[Base64BinaryTypeType] = None,
  url: Option[UriType] = None,
  size: Option[UnsignedIntType] = None,
  hash: Option[Base64BinaryTypeType] = None,
  title: Option[StringTypeType] = None,
  creation: Option[DateTimeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A length of time.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class DurationType(extension: Seq[ExtensionType] = Nil,
  value: Option[DecimalType] = None,
  comparator: Option[QuantityComparator] = None,
  unit: Option[StringTypeType] = None,
  system: Option[UriType] = None,
  code: Option[CodeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Quantityable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class CountType(extension: Seq[ExtensionType] = Nil,
  value: Option[DecimalType] = None,
  comparator: Option[QuantityComparator] = None,
  unit: Option[StringTypeType] = None,
  system: Option[UriType] = None,
  code: Option[CodeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Quantityable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A set of ordered Quantities defined by a low and high limit.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class RangeTypeType(extension: Seq[ExtensionType] = Nil,
  low: Option[Quantityable] = None,
  high: Option[Quantityable] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A  text note which also  contains information about who made the statement and when.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class AnnotationType(extension: Seq[ExtensionType] = Nil,
  authorReference: Option[ReferenceType] = None,
  authorString: Option[StringTypeType] = None,
  time: Option[DateTimeType] = None,
  text: StringTypeType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** An amount of economic utility in some recognized currency.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class MoneyType(extension: Seq[ExtensionType] = Nil,
  value: Option[DecimalType] = None,
  comparator: Option[QuantityComparator] = None,
  unit: Option[StringTypeType] = None,
  system: Option[UriType] = None,
  code: Option[CodeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Quantityable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A technical identifier - identifies some entity uniquely and unambiguously.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class IdentifierType(extension: Seq[ExtensionType] = Nil,
  use: Option[IdentifierUse] = None,
  typeValue: Option[CodeableConceptType] = None,
  system: Option[UriType] = None,
  value: Option[StringTypeType] = None,
  period: Option[PeriodType] = None,
  assigner: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait IdentifierUseu45list

object IdentifierUseu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[IdentifierUseu45list]): IdentifierUseu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: IdentifierUseu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[IdentifierUseu45list] = Seq(UsualValue, OfficialValue, TempValue, Secondary)
}

case object UsualValue extends IdentifierUseu45list { override def toString = "usual" }
case object OfficialValue extends IdentifierUseu45list { override def toString = "official" }
case object TempValue extends IdentifierUseu45list { override def toString = "temp" }
case object Secondary extends IdentifierUseu45list { override def toString = "secondary" }


/** Identifies the purpose for this identifier, if known .If the element is present, it must have either a @value, an @id, or extensions
*/
case class IdentifierUse(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[IdentifierUseu45list]}
}

      


/** A reference to a code defined by a terminology system.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class CodingType(extension: Seq[ExtensionType] = Nil,
  system: Option[UriType] = None,
  version: Option[StringTypeType] = None,
  code: Option[CodeType] = None,
  display: Option[StringTypeType] = None,
  userSelected: Option[BooleanTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A digital signature along with supporting context. The signature may be electronic/cryptographic in nature, or a graphical image representing a hand-written signature, or a signature process. Different signature approaches have different utilities.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class SignatureType(extension: Seq[ExtensionType] = Nil,
  typeValue: Seq[CodingType] = Nil,
  when: InstantType,
  whoUri: Option[UriType] = None,
  whoReference: Option[ReferenceType] = None,
  onBehalfOfUri: Option[UriType] = None,
  onBehalfOfReference: Option[ReferenceType] = None,
  contentType: Option[CodeType] = None,
  blob: Option[Base64BinaryTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class SampledDataType(extension: Seq[ExtensionType] = Nil,
  origin: Quantityable,
  period: DecimalType,
  factor: Option[DecimalType] = None,
  lowerLimit: Option[DecimalType] = None,
  upperLimit: Option[DecimalType] = None,
  dimensions: PositiveIntType,
  data: SampledDataDataType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


case class SampledDataDataType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[String]}
}

      


/** A relationship of two Quantity values - expressed as a numerator and a denominator.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class RatioType(extension: Seq[ExtensionType] = Nil,
  numerator: Option[Quantityable] = None,
  denominator: Option[Quantityable] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A length - a value with a unit that is a physical distance.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class DistanceType(extension: Seq[ExtensionType] = Nil,
  value: Option[DecimalType] = None,
  comparator: Option[QuantityComparator] = None,
  unit: Option[StringTypeType] = None,
  system: Option[UriType] = None,
  code: Option[CodeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Quantityable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A duration of time during which an organism (or a process) has existed.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class AgeType(extension: Seq[ExtensionType] = Nil,
  value: Option[DecimalType] = None,
  comparator: Option[QuantityComparator] = None,
  unit: Option[StringTypeType] = None,
  system: Option[UriType] = None,
  code: Option[CodeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Quantityable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class CodeableConceptType(extension: Seq[ExtensionType] = Nil,
  coding: Seq[CodingType] = Nil,
  text: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content may not always be associated with version changes to the resource.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class MetaType(extension: Seq[ExtensionType] = Nil,
  versionId: Option[IdType] = None,
  lastUpdated: Option[InstantType] = None,
  profile: Seq[UriType] = Nil,
  security: Seq[CodingType] = Nil,
  tag: Seq[CodingType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class AddressType2(extension: Seq[ExtensionType] = Nil,
  use: Option[AddressUse] = None,
  typeValue: Option[AddressType] = None,
  text: Option[StringTypeType] = None,
  line: Seq[StringTypeType] = Nil,
  city: Option[StringTypeType] = None,
  district: Option[StringTypeType] = None,
  state: Option[StringTypeType] = None,
  postalCode: Option[StringTypeType] = None,
  country: Option[StringTypeType] = None,
  period: Option[PeriodType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait AddressUseu45list

object AddressUseu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AddressUseu45list]): AddressUseu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AddressUseu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AddressUseu45list] = Seq(Home, Work, TempValue2, OldValue)
}

case object Home extends AddressUseu45list { override def toString = "home" }
case object Work extends AddressUseu45list { override def toString = "work" }
case object TempValue2 extends AddressUseu45list { override def toString = "temp" }
case object OldValue extends AddressUseu45list { override def toString = "old" }


/** The use of an addressIf the element is present, it must have either a @value, an @id, or extensions
*/
case class AddressUse(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AddressUseu45list]}
}

      

sealed trait AddressTypeu45list

object AddressTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AddressTypeu45list]): AddressTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AddressTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AddressTypeu45list] = Seq(Postal, Physical, BothValue)
}

case object Postal extends AddressTypeu45list { override def toString = "postal" }
case object Physical extends AddressTypeu45list { override def toString = "physical" }
case object BothValue extends AddressTypeu45list { override def toString = "both" }


/** The type of an address (physical / postal)If the element is present, it must have either a @value, an @id, or extensions
*/
case class AddressType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AddressTypeu45list]}
}

      


/** A description of a triggering event.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class TriggerDefinitionType(extension: Seq[ExtensionType] = Nil,
  typeValue: TriggerType,
  eventName: Option[StringTypeType] = None,
  eventTimingTiming: Option[TimingType] = None,
  eventTimingReference: Option[ReferenceType] = None,
  eventTimingDate: Option[DateType] = None,
  eventTimingDateTime: Option[DateTimeType] = None,
  eventData: Option[DataRequirementType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait TriggerTypeu45list

object TriggerTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[TriggerTypeu45list]): TriggerTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TriggerTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[TriggerTypeu45list] = Seq(Namedu45event, Periodic, Datau45added, Datau45modified, Datau45removed, Datau45accessed, Datau45accessu45ended)
}

case object Namedu45event extends TriggerTypeu45list { override def toString = "named-event" }
case object Periodic extends TriggerTypeu45list { override def toString = "periodic" }
case object Datau45added extends TriggerTypeu45list { override def toString = "data-added" }
case object Datau45modified extends TriggerTypeu45list { override def toString = "data-modified" }
case object Datau45removed extends TriggerTypeu45list { override def toString = "data-removed" }
case object Datau45accessed extends TriggerTypeu45list { override def toString = "data-accessed" }
case object Datau45accessu45ended extends TriggerTypeu45list { override def toString = "data-access-ended" }


/** The type of triggerIf the element is present, it must have either a @value, an @id, or extensions
*/
case class TriggerType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[TriggerTypeu45list]}
}

      


/** A contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ContributorType2(extension: Seq[ExtensionType] = Nil,
  typeValue: ContributorType,
  name: StringTypeType,
  contact: Seq[ContactDetailType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ContributorTypeu45list

object ContributorTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ContributorTypeu45list]): ContributorTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ContributorTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ContributorTypeu45list] = Seq(Author, Editor, Reviewer, Endorser)
}

case object Author extends ContributorTypeu45list { override def toString = "author" }
case object Editor extends ContributorTypeu45list { override def toString = "editor" }
case object Reviewer extends ContributorTypeu45list { override def toString = "reviewer" }
case object Endorser extends ContributorTypeu45list { override def toString = "endorser" }


/** The type of contributorIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ContributorType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ContributorTypeu45list]}
}

      


/** Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class DataRequirementType(extension: Seq[ExtensionType] = Nil,
  typeValue: CodeType,
  profile: Seq[UriType] = Nil,
  mustSupport: Seq[StringTypeType] = Nil,
  codeFilter: Seq[DataRequirementu46CodeFilter] = Nil,
  dateFilter: Seq[DataRequirementu46DateFilter] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class DataRequirementu46CodeFilter(extension: Seq[ExtensionType] = Nil,
  path: StringTypeType,
  valueSetString: Option[StringTypeType] = None,
  valueSetReference: Option[ReferenceType] = None,
  valueCode: Seq[CodeType] = Nil,
  valueCoding: Seq[CodingType] = Nil,
  valueCodeableConcept: Seq[CodeableConceptType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class DataRequirementu46DateFilter(extension: Seq[ExtensionType] = Nil,
  path: StringTypeType,
  valueDateTime: Option[DateTimeType] = None,
  valuePeriod: Option[PeriodType] = None,
  valueDuration: Option[DurationType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Indicates how the medication is/was taken or should be taken by the patient.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class DosageType(extension: Seq[ExtensionType] = Nil,
  sequence: Option[IntegerType] = None,
  text: Option[StringTypeType] = None,
  additionalInstruction: Seq[CodeableConceptType] = Nil,
  patientInstruction: Option[StringTypeType] = None,
  timing: Option[TimingType] = None,
  asNeededBoolean: Option[BooleanTypeType] = None,
  asNeededCodeableConcept: Option[CodeableConceptType] = None,
  site: Option[CodeableConceptType] = None,
  route: Option[CodeableConceptType] = None,
  method: Option[CodeableConceptType] = None,
  doseRange: Option[RangeTypeType] = None,
  doseQuantity: Option[Quantityable] = None,
  maxDosePerPeriod: Option[RatioType] = None,
  maxDosePerAdministration: Option[Quantityable] = None,
  maxDosePerLifetime: Option[Quantityable] = None,
  rateRatio: Option[RatioType] = None,
  rateRange: Option[RangeTypeType] = None,
  rateQuantity: Option[Quantityable] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Related artifacts such as additional documentation, justification, or bibliographic references.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class RelatedArtifactType(extension: Seq[ExtensionType] = Nil,
  typeValue: RelatedArtifactTypeType,
  display: Option[StringTypeType] = None,
  citation: Option[StringTypeType] = None,
  url: Option[UriType] = None,
  document: Option[AttachmentType] = None,
  resource: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait RelatedArtifactTypeu45list

object RelatedArtifactTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[RelatedArtifactTypeu45list]): RelatedArtifactTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RelatedArtifactTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[RelatedArtifactTypeu45list] = Seq(Documentation, Justification, Citation, Predecessor, Successor, Derivedu45fromValue, Dependsu45on, Composedu45of)
}

case object Documentation extends RelatedArtifactTypeu45list { override def toString = "documentation" }
case object Justification extends RelatedArtifactTypeu45list { override def toString = "justification" }
case object Citation extends RelatedArtifactTypeu45list { override def toString = "citation" }
case object Predecessor extends RelatedArtifactTypeu45list { override def toString = "predecessor" }
case object Successor extends RelatedArtifactTypeu45list { override def toString = "successor" }
case object Derivedu45fromValue extends RelatedArtifactTypeu45list { override def toString = "derived-from" }
case object Dependsu45on extends RelatedArtifactTypeu45list { override def toString = "depends-on" }
case object Composedu45of extends RelatedArtifactTypeu45list { override def toString = "composed-of" }


/** The type of relationship to the related artifactIf the element is present, it must have either a @value, an @id, or extensions
*/
case class RelatedArtifactTypeType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[RelatedArtifactTypeu45list]}
}

      


/** Specifies contact information for a person or organization.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ContactDetailType(extension: Seq[ExtensionType] = Nil,
  name: Option[StringTypeType] = None,
  telecom: Seq[ContactPointType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A human's name with the ability to identify parts and usage.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class HumanNameType(extension: Seq[ExtensionType] = Nil,
  use: Option[NameUse] = None,
  text: Option[StringTypeType] = None,
  family: Option[StringTypeType] = None,
  given: Seq[StringTypeType] = Nil,
  prefix: Seq[StringTypeType] = Nil,
  suffix: Seq[StringTypeType] = Nil,
  period: Option[PeriodType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait NameUseu45list

object NameUseu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[NameUseu45list]): NameUseu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: NameUseu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[NameUseu45list] = Seq(Usual, Official, Temp, Nickname, Anonymous, Old, Maiden)
}

case object Usual extends NameUseu45list { override def toString = "usual" }
case object Official extends NameUseu45list { override def toString = "official" }
case object Temp extends NameUseu45list { override def toString = "temp" }
case object Nickname extends NameUseu45list { override def toString = "nickname" }
case object Anonymous extends NameUseu45list { override def toString = "anonymous" }
case object Old extends NameUseu45list { override def toString = "old" }
case object Maiden extends NameUseu45list { override def toString = "maiden" }


/** The use of a human nameIf the element is present, it must have either a @value, an @id, or extensions
*/
case class NameUse(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[NameUseu45list]}
}

      


/** Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ContactPointType(extension: Seq[ExtensionType] = Nil,
  system: Option[ContactPointSystem] = None,
  value: Option[StringTypeType] = None,
  use: Option[ContactPointUse] = None,
  rank: Option[PositiveIntType] = None,
  period: Option[PeriodType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ContactPointSystemu45list

object ContactPointSystemu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ContactPointSystemu45list]): ContactPointSystemu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ContactPointSystemu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ContactPointSystemu45list] = Seq(Phone, Fax, EmailValue, Pager, UrlValue, SmsValue, OtherValue2)
}

case object Phone extends ContactPointSystemu45list { override def toString = "phone" }
case object Fax extends ContactPointSystemu45list { override def toString = "fax" }
case object EmailValue extends ContactPointSystemu45list { override def toString = "email" }
case object Pager extends ContactPointSystemu45list { override def toString = "pager" }
case object UrlValue extends ContactPointSystemu45list { override def toString = "url" }
case object SmsValue extends ContactPointSystemu45list { override def toString = "sms" }
case object OtherValue2 extends ContactPointSystemu45list { override def toString = "other" }


/** Telecommunications form for contact pointIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ContactPointSystem(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ContactPointSystemu45list]}
}

      

sealed trait ContactPointUseu45list

object ContactPointUseu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ContactPointUseu45list]): ContactPointUseu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ContactPointUseu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ContactPointUseu45list] = Seq(HomeValue, WorkValue, TempValue3, OldValue2, Mobile)
}

case object HomeValue extends ContactPointUseu45list { override def toString = "home" }
case object WorkValue extends ContactPointUseu45list { override def toString = "work" }
case object TempValue3 extends ContactPointUseu45list { override def toString = "temp" }
case object OldValue2 extends ContactPointUseu45list { override def toString = "old" }
case object Mobile extends ContactPointUseu45list { override def toString = "mobile" }


/** Use of contact pointIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ContactPointUse(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ContactPointUseu45list]}
}

      


/** Specifies clinical/business/etc metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care).If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class UsageContextType(extension: Seq[ExtensionType] = Nil,
  code: CodingType,
  valueCodeableConcept: Option[CodeableConceptType] = None,
  valueQuantity: Option[Quantityable] = None,
  valueRange: Option[RangeTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class TimingType(extension: Seq[ExtensionType] = Nil,
  event: Seq[DateTimeType] = Nil,
  repeat: Option[Timingu46Repeat] = None,
  code: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class Timingu46Repeat(extension: Seq[ExtensionType] = Nil,
  boundsDuration: Option[DurationType] = None,
  boundsRange: Option[RangeTypeType] = None,
  boundsPeriod: Option[PeriodType] = None,
  count: Option[IntegerType] = None,
  countMax: Option[IntegerType] = None,
  duration: Option[DecimalType] = None,
  durationMax: Option[DecimalType] = None,
  durationUnit: Option[UnitsOfTime] = None,
  frequency: Option[IntegerType] = None,
  frequencyMax: Option[IntegerType] = None,
  period: Option[DecimalType] = None,
  periodMax: Option[DecimalType] = None,
  periodUnit: Option[UnitsOfTime] = None,
  dayOfWeek: Seq[CodeType] = Nil,
  timeOfDay: Seq[TimeType] = Nil,
  when: Seq[EventTiming] = Nil,
  offset: Option[UnsignedIntType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait UnitsOfTimeu45list

object UnitsOfTimeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[UnitsOfTimeu45list]): UnitsOfTimeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: UnitsOfTimeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[UnitsOfTimeu45list] = Seq(S, Min, H, D, Wk, Mo, A)
}

case object S extends UnitsOfTimeu45list { override def toString = "s" }
case object Min extends UnitsOfTimeu45list { override def toString = "min" }
case object H extends UnitsOfTimeu45list { override def toString = "h" }
case object D extends UnitsOfTimeu45list { override def toString = "d" }
case object Wk extends UnitsOfTimeu45list { override def toString = "wk" }
case object Mo extends UnitsOfTimeu45list { override def toString = "mo" }
case object A extends UnitsOfTimeu45list { override def toString = "a" }


/** A unit of time (units from UCUM).If the element is present, it must have either a @value, an @id, or extensions
*/
case class UnitsOfTime(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[UnitsOfTimeu45list]}
}

      

sealed trait EventTimingu45list

object EventTimingu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[EventTimingu45list]): EventTimingu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: EventTimingu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[EventTimingu45list] = Seq(MORN, AFT, EVE, NIGHT, PHS, HS, WAKE, CValue, CM, CD, CV, AC, ACM, ACD, ACV, PC, PCM, PCD, PCV)
}

case object MORN extends EventTimingu45list { override def toString = "MORN" }
case object AFT extends EventTimingu45list { override def toString = "AFT" }
case object EVE extends EventTimingu45list { override def toString = "EVE" }
case object NIGHT extends EventTimingu45list { override def toString = "NIGHT" }
case object PHS extends EventTimingu45list { override def toString = "PHS" }
case object HS extends EventTimingu45list { override def toString = "HS" }
case object WAKE extends EventTimingu45list { override def toString = "WAKE" }
case object CValue extends EventTimingu45list { override def toString = "C" }
case object CM extends EventTimingu45list { override def toString = "CM" }
case object CD extends EventTimingu45list { override def toString = "CD" }
case object CV extends EventTimingu45list { override def toString = "CV" }
case object AC extends EventTimingu45list { override def toString = "AC" }
case object ACM extends EventTimingu45list { override def toString = "ACM" }
case object ACD extends EventTimingu45list { override def toString = "ACD" }
case object ACV extends EventTimingu45list { override def toString = "ACV" }
case object PC extends EventTimingu45list { override def toString = "PC" }
case object PCM extends EventTimingu45list { override def toString = "PCM" }
case object PCD extends EventTimingu45list { override def toString = "PCD" }
case object PCV extends EventTimingu45list { override def toString = "PCV" }


/** Real world event relating to the schedule.If the element is present, it must have either a @value, an @id, or extensions
*/
case class EventTiming(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[EventTimingu45list]}
}

      


/** Captures constraints on each element within the resource, profile, or extension.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ElementDefinitionType(extension: Seq[ExtensionType] = Nil,
  path: StringTypeType,
  representation: Seq[PropertyRepresentation] = Nil,
  sliceName: Option[StringTypeType] = None,
  label: Option[StringTypeType] = None,
  code: Seq[CodingType] = Nil,
  slicing: Option[ElementDefinitionu46Slicing] = None,
  short: Option[StringTypeType] = None,
  definition: Option[MarkdownType] = None,
  comment: Option[MarkdownType] = None,
  requirements: Option[MarkdownType] = None,
  alias: Seq[StringTypeType] = Nil,
  min: Option[UnsignedIntType] = None,
  max: Option[StringTypeType] = None,
  base: Option[ElementDefinitionu46Base] = None,
  contentReference: Option[UriType] = None,
  typeValue: Seq[ElementDefinitionu46Type] = Nil,
  defaultValueBase64Binary: Option[Base64BinaryTypeType] = None,
  defaultValueBoolean: Option[BooleanTypeType] = None,
  defaultValueCode: Option[CodeType] = None,
  defaultValueDate: Option[DateType] = None,
  defaultValueDateTime: Option[DateTimeType] = None,
  defaultValueDecimal: Option[DecimalType] = None,
  defaultValueId: Option[IdType] = None,
  defaultValueInstant: Option[InstantType] = None,
  defaultValueInteger: Option[IntegerType] = None,
  defaultValueMarkdown: Option[MarkdownType] = None,
  defaultValueOid: Option[OidType] = None,
  defaultValuePositiveInt: Option[PositiveIntType] = None,
  defaultValueString: Option[StringTypeType] = None,
  defaultValueTime: Option[TimeType] = None,
  defaultValueUnsignedInt: Option[UnsignedIntType] = None,
  defaultValueUri: Option[UriType] = None,
  defaultValueAddress: Option[AddressType2] = None,
  defaultValueAge: Option[AgeType] = None,
  defaultValueAnnotation: Option[AnnotationType] = None,
  defaultValueAttachment: Option[AttachmentType] = None,
  defaultValueCodeableConcept: Option[CodeableConceptType] = None,
  defaultValueCoding: Option[CodingType] = None,
  defaultValueContactPoint: Option[ContactPointType] = None,
  defaultValueCount: Option[CountType] = None,
  defaultValueDistance: Option[DistanceType] = None,
  defaultValueDuration: Option[DurationType] = None,
  defaultValueHumanName: Option[HumanNameType] = None,
  defaultValueIdentifier: Option[IdentifierType] = None,
  defaultValueMoney: Option[MoneyType] = None,
  defaultValuePeriod: Option[PeriodType] = None,
  defaultValueQuantity: Option[Quantityable] = None,
  defaultValueRange: Option[RangeTypeType] = None,
  defaultValueRatio: Option[RatioType] = None,
  defaultValueReference: Option[ReferenceType] = None,
  defaultValueSampledData: Option[SampledDataType] = None,
  defaultValueSignature: Option[SignatureType] = None,
  defaultValueTiming: Option[TimingType] = None,
  defaultValueMeta: Option[MetaType] = None,
  meaningWhenMissing: Option[MarkdownType] = None,
  orderMeaning: Option[StringTypeType] = None,
  fixedBase64Binary: Option[Base64BinaryTypeType] = None,
  fixedBoolean: Option[BooleanTypeType] = None,
  fixedCode: Option[CodeType] = None,
  fixedDate: Option[DateType] = None,
  fixedDateTime: Option[DateTimeType] = None,
  fixedDecimal: Option[DecimalType] = None,
  fixedId: Option[IdType] = None,
  fixedInstant: Option[InstantType] = None,
  fixedInteger: Option[IntegerType] = None,
  fixedMarkdown: Option[MarkdownType] = None,
  fixedOid: Option[OidType] = None,
  fixedPositiveInt: Option[PositiveIntType] = None,
  fixedString: Option[StringTypeType] = None,
  fixedTime: Option[TimeType] = None,
  fixedUnsignedInt: Option[UnsignedIntType] = None,
  fixedUri: Option[UriType] = None,
  fixedAddress: Option[AddressType2] = None,
  fixedAge: Option[AgeType] = None,
  fixedAnnotation: Option[AnnotationType] = None,
  fixedAttachment: Option[AttachmentType] = None,
  fixedCodeableConcept: Option[CodeableConceptType] = None,
  fixedCoding: Option[CodingType] = None,
  fixedContactPoint: Option[ContactPointType] = None,
  fixedCount: Option[CountType] = None,
  fixedDistance: Option[DistanceType] = None,
  fixedDuration: Option[DurationType] = None,
  fixedHumanName: Option[HumanNameType] = None,
  fixedIdentifier: Option[IdentifierType] = None,
  fixedMoney: Option[MoneyType] = None,
  fixedPeriod: Option[PeriodType] = None,
  fixedQuantity: Option[Quantityable] = None,
  fixedRange: Option[RangeTypeType] = None,
  fixedRatio: Option[RatioType] = None,
  fixedReference: Option[ReferenceType] = None,
  fixedSampledData: Option[SampledDataType] = None,
  fixedSignature: Option[SignatureType] = None,
  fixedTiming: Option[TimingType] = None,
  fixedMeta: Option[MetaType] = None,
  patternBase64Binary: Option[Base64BinaryTypeType] = None,
  patternBoolean: Option[BooleanTypeType] = None,
  patternCode: Option[CodeType] = None,
  patternDate: Option[DateType] = None,
  patternDateTime: Option[DateTimeType] = None,
  patternDecimal: Option[DecimalType] = None,
  patternId: Option[IdType] = None,
  patternInstant: Option[InstantType] = None,
  patternInteger: Option[IntegerType] = None,
  patternMarkdown: Option[MarkdownType] = None,
  patternOid: Option[OidType] = None,
  patternPositiveInt: Option[PositiveIntType] = None,
  patternString: Option[StringTypeType] = None,
  patternTime: Option[TimeType] = None,
  patternUnsignedInt: Option[UnsignedIntType] = None,
  patternUri: Option[UriType] = None,
  patternAddress: Option[AddressType2] = None,
  patternAge: Option[AgeType] = None,
  patternAnnotation: Option[AnnotationType] = None,
  patternAttachment: Option[AttachmentType] = None,
  patternCodeableConcept: Option[CodeableConceptType] = None,
  patternCoding: Option[CodingType] = None,
  patternContactPoint: Option[ContactPointType] = None,
  patternCount: Option[CountType] = None,
  patternDistance: Option[DistanceType] = None,
  patternDuration: Option[DurationType] = None,
  patternHumanName: Option[HumanNameType] = None,
  patternIdentifier: Option[IdentifierType] = None,
  patternMoney: Option[MoneyType] = None,
  patternPeriod: Option[PeriodType] = None,
  patternQuantity: Option[Quantityable] = None,
  patternRange: Option[RangeTypeType] = None,
  patternRatio: Option[RatioType] = None,
  patternReference: Option[ReferenceType] = None,
  patternSampledData: Option[SampledDataType] = None,
  patternSignature: Option[SignatureType] = None,
  patternTiming: Option[TimingType] = None,
  patternMeta: Option[MetaType] = None,
  example: Seq[ElementDefinitionu46Example] = Nil,
  minValueDate: Option[DateType] = None,
  minValueDateTime: Option[DateTimeType] = None,
  minValueInstant: Option[InstantType] = None,
  minValueTime: Option[TimeType] = None,
  minValueDecimal: Option[DecimalType] = None,
  minValueInteger: Option[IntegerType] = None,
  minValuePositiveInt: Option[PositiveIntType] = None,
  minValueUnsignedInt: Option[UnsignedIntType] = None,
  minValueQuantity: Option[Quantityable] = None,
  maxValueDate: Option[DateType] = None,
  maxValueDateTime: Option[DateTimeType] = None,
  maxValueInstant: Option[InstantType] = None,
  maxValueTime: Option[TimeType] = None,
  maxValueDecimal: Option[DecimalType] = None,
  maxValueInteger: Option[IntegerType] = None,
  maxValuePositiveInt: Option[PositiveIntType] = None,
  maxValueUnsignedInt: Option[UnsignedIntType] = None,
  maxValueQuantity: Option[Quantityable] = None,
  maxLength: Option[IntegerType] = None,
  condition: Seq[IdType] = Nil,
  constraint: Seq[ElementDefinitionu46Constraint] = Nil,
  mustSupport: Option[BooleanTypeType] = None,
  isModifier: Option[BooleanTypeType] = None,
  isSummary: Option[BooleanTypeType] = None,
  binding: Option[ElementDefinitionu46Binding] = None,
  mapping: Seq[ElementDefinitionu46Mapping] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Captures constraints on each element within the resource, profile, or extension.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ElementDefinitionu46Constraint(extension: Seq[ExtensionType] = Nil,
  key: IdType,
  requirements: Option[StringTypeType] = None,
  severity: ConstraintSeverity,
  human: StringTypeType,
  expression: StringTypeType,
  xpath: Option[StringTypeType] = None,
  source: Option[UriType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Captures constraints on each element within the resource, profile, or extension.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ElementDefinitionu46Mapping(extension: Seq[ExtensionType] = Nil,
  identity: IdType,
  language: Option[CodeType] = None,
  map: StringTypeType,
  comment: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Captures constraints on each element within the resource, profile, or extension.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ElementDefinitionu46Base(extension: Seq[ExtensionType] = Nil,
  path: StringTypeType,
  min: UnsignedIntType,
  max: StringTypeType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Captures constraints on each element within the resource, profile, or extension.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ElementDefinitionu46Type(extension: Seq[ExtensionType] = Nil,
  code: UriType,
  profile: Option[UriType] = None,
  targetProfile: Option[UriType] = None,
  aggregation: Seq[AggregationMode] = Nil,
  versioning: Option[ReferenceVersionRules] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Captures constraints on each element within the resource, profile, or extension.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ElementDefinitionu46Example(extension: Seq[ExtensionType] = Nil,
  label: StringTypeType,
  valueBase64Binary: Option[Base64BinaryTypeType] = None,
  valueBoolean: Option[BooleanTypeType] = None,
  valueCode: Option[CodeType] = None,
  valueDate: Option[DateType] = None,
  valueDateTime: Option[DateTimeType] = None,
  valueDecimal: Option[DecimalType] = None,
  valueId: Option[IdType] = None,
  valueInstant: Option[InstantType] = None,
  valueInteger: Option[IntegerType] = None,
  valueMarkdown: Option[MarkdownType] = None,
  valueOid: Option[OidType] = None,
  valuePositiveInt: Option[PositiveIntType] = None,
  valueString: Option[StringTypeType] = None,
  valueTime: Option[TimeType] = None,
  valueUnsignedInt: Option[UnsignedIntType] = None,
  valueUri: Option[UriType] = None,
  valueAddress: Option[AddressType2] = None,
  valueAge: Option[AgeType] = None,
  valueAnnotation: Option[AnnotationType] = None,
  valueAttachment: Option[AttachmentType] = None,
  valueCodeableConcept: Option[CodeableConceptType] = None,
  valueCoding: Option[CodingType] = None,
  valueContactPoint: Option[ContactPointType] = None,
  valueCount: Option[CountType] = None,
  valueDistance: Option[DistanceType] = None,
  valueDuration: Option[DurationType] = None,
  valueHumanName: Option[HumanNameType] = None,
  valueIdentifier: Option[IdentifierType] = None,
  valueMoney: Option[MoneyType] = None,
  valuePeriod: Option[PeriodType] = None,
  valueQuantity: Option[Quantityable] = None,
  valueRange: Option[RangeTypeType] = None,
  valueRatio: Option[RatioType] = None,
  valueReference: Option[ReferenceType] = None,
  valueSampledData: Option[SampledDataType] = None,
  valueSignature: Option[SignatureType] = None,
  valueTiming: Option[TimingType] = None,
  valueMeta: Option[MetaType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Captures constraints on each element within the resource, profile, or extension.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ElementDefinitionu46Slicing(extension: Seq[ExtensionType] = Nil,
  discriminator: Seq[ElementDefinitionu46Discriminator] = Nil,
  description: Option[StringTypeType] = None,
  ordered: Option[BooleanTypeType] = None,
  rules: SlicingRules,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Captures constraints on each element within the resource, profile, or extension.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ElementDefinitionu46Binding(extension: Seq[ExtensionType] = Nil,
  strength: BindingStrength,
  description: Option[StringTypeType] = None,
  valueSetUri: Option[UriType] = None,
  valueSetReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Captures constraints on each element within the resource, profile, or extension.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ElementDefinitionu46Discriminator(extension: Seq[ExtensionType] = Nil,
  typeValue: DiscriminatorType,
  path: StringTypeType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait PropertyRepresentationu45list

object PropertyRepresentationu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[PropertyRepresentationu45list]): PropertyRepresentationu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PropertyRepresentationu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[PropertyRepresentationu45list] = Seq(XmlAttr, XmlText, TypeAttr, CdaText, XhtmlValue2)
}

case object XmlAttr extends PropertyRepresentationu45list { override def toString = "xmlAttr" }
case object XmlText extends PropertyRepresentationu45list { override def toString = "xmlText" }
case object TypeAttr extends PropertyRepresentationu45list { override def toString = "typeAttr" }
case object CdaText extends PropertyRepresentationu45list { override def toString = "cdaText" }
case object XhtmlValue2 extends PropertyRepresentationu45list { override def toString = "xhtml" }


/** How a property is represented when serialized.If the element is present, it must have either a @value, an @id, or extensions
*/
case class PropertyRepresentation(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[PropertyRepresentationu45list]}
}

      

sealed trait ConstraintSeverityu45list

object ConstraintSeverityu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ConstraintSeverityu45list]): ConstraintSeverityu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ConstraintSeverityu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ConstraintSeverityu45list] = Seq(ErrorValue3, WarningValue)
}

case object ErrorValue3 extends ConstraintSeverityu45list { override def toString = "error" }
case object WarningValue extends ConstraintSeverityu45list { override def toString = "warning" }


/** SHALL applications comply with this constraint?If the element is present, it must have either a @value, an @id, or extensions
*/
case class ConstraintSeverity(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ConstraintSeverityu45list]}
}

      

sealed trait AggregationModeu45list

object AggregationModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AggregationModeu45list]): AggregationModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AggregationModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AggregationModeu45list] = Seq(Contained, Referenced, Bundled)
}

case object Contained extends AggregationModeu45list { override def toString = "contained" }
case object Referenced extends AggregationModeu45list { override def toString = "referenced" }
case object Bundled extends AggregationModeu45list { override def toString = "bundled" }


/** How resource references can be aggregated.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AggregationMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AggregationModeu45list]}
}

      

sealed trait ReferenceVersionRulesu45list

object ReferenceVersionRulesu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ReferenceVersionRulesu45list]): ReferenceVersionRulesu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ReferenceVersionRulesu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ReferenceVersionRulesu45list] = Seq(Either, Independent, Specific)
}

case object Either extends ReferenceVersionRulesu45list { override def toString = "either" }
case object Independent extends ReferenceVersionRulesu45list { override def toString = "independent" }
case object Specific extends ReferenceVersionRulesu45list { override def toString = "specific" }


/** Whether a reference needs to be version specific or version independent, or whether either can be usedIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ReferenceVersionRules(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ReferenceVersionRulesu45list]}
}

      

sealed trait SlicingRulesu45list

object SlicingRulesu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[SlicingRulesu45list]): SlicingRulesu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SlicingRulesu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SlicingRulesu45list] = Seq(Closed, Open, OpenAtEnd)
}

case object Closed extends SlicingRulesu45list { override def toString = "closed" }
case object Open extends SlicingRulesu45list { override def toString = "open" }
case object OpenAtEnd extends SlicingRulesu45list { override def toString = "openAtEnd" }


/** How slices are interpreted when evaluating an instance.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SlicingRules(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[SlicingRulesu45list]}
}

      

sealed trait BindingStrengthu45list

object BindingStrengthu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[BindingStrengthu45list]): BindingStrengthu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: BindingStrengthu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[BindingStrengthu45list] = Seq(RequiredValue2, Extensible, Preferred, Example)
}

case object RequiredValue2 extends BindingStrengthu45list { override def toString = "required" }
case object Extensible extends BindingStrengthu45list { override def toString = "extensible" }
case object Preferred extends BindingStrengthu45list { override def toString = "preferred" }
case object Example extends BindingStrengthu45list { override def toString = "example" }


/** Indication of the degree of conformance expectations associated with a binding.If the element is present, it must have either a @value, an @id, or extensions
*/
case class BindingStrength(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[BindingStrengthu45list]}
}

      

sealed trait DiscriminatorTypeu45list

object DiscriminatorTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[DiscriminatorTypeu45list]): DiscriminatorTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DiscriminatorTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DiscriminatorTypeu45list] = Seq(ValueValue, Exists, Pattern, TypeValue3, Profile)
}

case object ValueValue extends DiscriminatorTypeu45list { override def toString = "value" }
case object Exists extends DiscriminatorTypeu45list { override def toString = "exists" }
case object Pattern extends DiscriminatorTypeu45list { override def toString = "pattern" }
case object TypeValue3 extends DiscriminatorTypeu45list { override def toString = "type" }
case object Profile extends DiscriminatorTypeu45list { override def toString = "profile" }


/** How an element value is interpreted when discrimination is evaluatedIf the element is present, it must have either a @value, an @id, or extensions
*/
case class DiscriminatorType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[DiscriminatorTypeu45list]}
}

      


/** The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse.If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
*/
case class ParameterDefinitionType(extension: Seq[ExtensionType] = Nil,
  name: Option[CodeType] = None,
  use: CodeType,
  min: Option[IntegerType] = None,
  max: Option[StringTypeType] = None,
  documentation: Option[StringTypeType] = None,
  typeValue: CodeType,
  profile: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A resource that includes narrative, extensions, and contained resources.
*/
trait DomainResourcable extends Resourcable {
  def id: Option[IdType]
  def meta: Option[MetaType]
  def implicitRules: Option[UriType]
  def language: Option[CodeType]
  def text: Option[NarrativeType]
  def contained: Seq[ResourceContainer]
  def extension: Seq[ExtensionType]
  def modifierExtension: Seq[ExtensionType]
}


/** A resource that includes narrative, extensions, and contained resources.
*/
case class DomainResourceType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil) extends DomainResourcable
      


/** This is the base resource type for everything.
*/
trait Resourcable {
  def id: Option[IdType]
  def meta: Option[MetaType]
  def implicitRules: Option[UriType]
  def language: Option[CodeType]
}


/** This is the base resource type for everything.
*/
case class ResourceType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None) extends Resourcable
      

sealed trait PublicationStatusu45list

object PublicationStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[PublicationStatusu45list]): PublicationStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PublicationStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[PublicationStatusu45list] = Seq(DraftValue4, ActiveValue12, RetiredValue, UnknownValue7)
}

case object DraftValue4 extends PublicationStatusu45list { override def toString = "draft" }
case object ActiveValue12 extends PublicationStatusu45list { override def toString = "active" }
case object RetiredValue extends PublicationStatusu45list { override def toString = "retired" }
case object UnknownValue7 extends PublicationStatusu45list { override def toString = "unknown" }


/** If the element is present, it must have either a @value, an @id, or extensions
*/
case class PublicationStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[PublicationStatusu45list]}
}

      

sealed trait SearchParamTypeu45list

object SearchParamTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[SearchParamTypeu45list]): SearchParamTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SearchParamTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SearchParamTypeu45list] = Seq(Number, DateValue3, StringTypeValue3, Token, ReferenceValue4, Composite, QuantityValue3, UriValue2)
}

case object Number extends SearchParamTypeu45list { override def toString = "number" }
case object DateValue3 extends SearchParamTypeu45list { override def toString = "date" }
case object StringTypeValue3 extends SearchParamTypeu45list { override def toString = "string" }
case object Token extends SearchParamTypeu45list { override def toString = "token" }
case object ReferenceValue4 extends SearchParamTypeu45list { override def toString = "reference" }
case object Composite extends SearchParamTypeu45list { override def toString = "composite" }
case object QuantityValue3 extends SearchParamTypeu45list { override def toString = "quantity" }
case object UriValue2 extends SearchParamTypeu45list { override def toString = "uri" }


/** If the element is present, it must have either a @value, an @id, or extensions
*/
case class SearchParamType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[SearchParamTypeu45list]}
}

      

sealed trait AdministrativeGenderu45list

object AdministrativeGenderu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AdministrativeGenderu45list]): AdministrativeGenderu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AdministrativeGenderu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AdministrativeGenderu45list] = Seq(Male, Female, OtherValue, UnknownValue6)
}

case object Male extends AdministrativeGenderu45list { override def toString = "male" }
case object Female extends AdministrativeGenderu45list { override def toString = "female" }
case object OtherValue extends AdministrativeGenderu45list { override def toString = "other" }
case object UnknownValue6 extends AdministrativeGenderu45list { override def toString = "unknown" }


/** If the element is present, it must have either a @value, an @id, or extensions
*/
case class AdministrativeGender(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AdministrativeGenderu45list]}
}

      

sealed trait RemittanceOutcomeu45list

object RemittanceOutcomeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[RemittanceOutcomeu45list]): RemittanceOutcomeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RemittanceOutcomeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[RemittanceOutcomeu45list] = Seq(Complete, ErrorValue2, Partial)
}

case object Complete extends RemittanceOutcomeu45list { override def toString = "complete" }
case object ErrorValue2 extends RemittanceOutcomeu45list { override def toString = "error" }
case object Partial extends RemittanceOutcomeu45list { override def toString = "partial" }


/** If the element is present, it must have either a @value, an @id, or extensions
*/
case class RemittanceOutcome(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[RemittanceOutcomeu45list]}
}

      

sealed trait NoteTypeu45list

object NoteTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[NoteTypeu45list]): NoteTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: NoteTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[NoteTypeu45list] = Seq(DisplayValue, Print, Printoper)
}

case object DisplayValue extends NoteTypeu45list { override def toString = "display" }
case object Print extends NoteTypeu45list { override def toString = "print" }
case object Printoper extends NoteTypeu45list { override def toString = "printoper" }


/** If the element is present, it must have either a @value, an @id, or extensions
*/
case class NoteType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[NoteTypeu45list]}
}

      

sealed trait ConceptMapEquivalenceu45list

object ConceptMapEquivalenceu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ConceptMapEquivalenceu45list]): ConceptMapEquivalenceu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ConceptMapEquivalenceu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ConceptMapEquivalenceu45list] = Seq(Relatedto, Equivalent, Equal, Wider, Subsumes, Narrower, Specializes, Inexact, Unmatched, Disjoint)
}

case object Relatedto extends ConceptMapEquivalenceu45list { override def toString = "relatedto" }
case object Equivalent extends ConceptMapEquivalenceu45list { override def toString = "equivalent" }
case object Equal extends ConceptMapEquivalenceu45list { override def toString = "equal" }
case object Wider extends ConceptMapEquivalenceu45list { override def toString = "wider" }
case object Subsumes extends ConceptMapEquivalenceu45list { override def toString = "subsumes" }
case object Narrower extends ConceptMapEquivalenceu45list { override def toString = "narrower" }
case object Specializes extends ConceptMapEquivalenceu45list { override def toString = "specializes" }
case object Inexact extends ConceptMapEquivalenceu45list { override def toString = "inexact" }
case object Unmatched extends ConceptMapEquivalenceu45list { override def toString = "unmatched" }
case object Disjoint extends ConceptMapEquivalenceu45list { override def toString = "disjoint" }


/** If the element is present, it must have either a @value, an @id, or extensions
*/
case class ConceptMapEquivalence(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ConceptMapEquivalenceu45list]}
}

      

sealed trait DocumentReferenceStatusu45list

object DocumentReferenceStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[DocumentReferenceStatusu45list]): DocumentReferenceStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DocumentReferenceStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DocumentReferenceStatusu45list] = Seq(CurrentValue, Superseded, Enteredu45inu45errorValue16)
}

case object CurrentValue extends DocumentReferenceStatusu45list { override def toString = "current" }
case object Superseded extends DocumentReferenceStatusu45list { override def toString = "superseded" }
case object Enteredu45inu45errorValue16 extends DocumentReferenceStatusu45list { override def toString = "entered-in-error" }


/** If the element is present, it must have either a @value, an @id, or extensions
*/
case class DocumentReferenceStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[DocumentReferenceStatusu45list]}
}

      


/** A financial tool for tracking value accrued for a particular purpose.  In the healthcare field, used to track charges for a patient, cost centers, etc.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AccountType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[AccountStatus] = None,
  typeValue: Option[CodeableConceptType] = None,
  name: Option[StringTypeType] = None,
  subject: Option[ReferenceType] = None,
  period: Option[PeriodType] = None,
  active: Option[PeriodType] = None,
  balance: Option[MoneyType] = None,
  coverage: Seq[Accountu46Coverage] = Nil,
  owner: Option[ReferenceType] = None,
  description: Option[StringTypeType] = None,
  guarantor: Seq[Accountu46Guarantor] = Nil) extends DomainResourcable
      


/** A financial tool for tracking value accrued for a particular purpose.  In the healthcare field, used to track charges for a patient, cost centers, etc.
*/
case class Accountu46Coverage(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  coverage: ReferenceType,
  priority: Option[PositiveIntType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A financial tool for tracking value accrued for a particular purpose.  In the healthcare field, used to track charges for a patient, cost centers, etc.
*/
case class Accountu46Guarantor(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  party: ReferenceType,
  onHold: Option[BooleanTypeType] = None,
  period: Option[PeriodType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait AccountStatusu45list

object AccountStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AccountStatusu45list]): AccountStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AccountStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AccountStatusu45list] = Seq(ActiveValue13, InactiveValue4, Enteredu45inu45errorValue17)
}

case object ActiveValue13 extends AccountStatusu45list { override def toString = "active" }
case object InactiveValue4 extends AccountStatusu45list { override def toString = "inactive" }
case object Enteredu45inu45errorValue17 extends AccountStatusu45list { override def toString = "entered-in-error" }


/** Indicates whether the account is available to be used.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AccountStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AccountStatusu45list]}
}

      


/** This resource allows for the definition of some activity to be performed, independent of a particular patient, practitioner, or other performance context.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ActivityDefinitionType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: Option[UriType] = None,
  identifier: Seq[IdentifierType] = Nil,
  version: Option[StringTypeType] = None,
  name: Option[StringTypeType] = None,
  title: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  description: Option[MarkdownType] = None,
  purpose: Option[MarkdownType] = None,
  usage: Option[StringTypeType] = None,
  approvalDate: Option[DateType] = None,
  lastReviewDate: Option[DateType] = None,
  effectivePeriod: Option[PeriodType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  topic: Seq[CodeableConceptType] = Nil,
  contributor: Seq[ContributorType2] = Nil,
  contact: Seq[ContactDetailType] = Nil,
  copyright: Option[MarkdownType] = None,
  relatedArtifact: Seq[RelatedArtifactType] = Nil,
  library: Seq[ReferenceType] = Nil,
  kind: Option[ResourceTypeType] = None,
  code: Option[CodeableConceptType] = None,
  timingTiming: Option[TimingType] = None,
  timingDateTime: Option[DateTimeType] = None,
  timingPeriod: Option[PeriodType] = None,
  timingRange: Option[RangeTypeType] = None,
  location: Option[ReferenceType] = None,
  participant: Seq[ActivityDefinitionu46Participant] = Nil,
  productReference: Option[ReferenceType] = None,
  productCodeableConcept: Option[CodeableConceptType] = None,
  quantity: Option[Quantityable] = None,
  dosage: Seq[DosageType] = Nil,
  bodySite: Seq[CodeableConceptType] = Nil,
  transform: Option[ReferenceType] = None,
  dynamicValue: Seq[ActivityDefinitionu46DynamicValue] = Nil) extends DomainResourcable
      


/** This resource allows for the definition of some activity to be performed, independent of a particular patient, practitioner, or other performance context.
*/
case class ActivityDefinitionu46Participant(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: ActionParticipantType,
  role: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource allows for the definition of some activity to be performed, independent of a particular patient, practitioner, or other performance context.
*/
case class ActivityDefinitionu46DynamicValue(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  description: Option[StringTypeType] = None,
  path: Option[StringTypeType] = None,
  language: Option[StringTypeType] = None,
  expression: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ActionParticipantTypeu45list

object ActionParticipantTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ActionParticipantTypeu45list]): ActionParticipantTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ActionParticipantTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ActionParticipantTypeu45list] = Seq(PatientValue4, PractitionerValue4, Relatedu45person)
}

case object PatientValue4 extends ActionParticipantTypeu45list { override def toString = "patient" }
case object PractitionerValue4 extends ActionParticipantTypeu45list { override def toString = "practitioner" }
case object Relatedu45person extends ActionParticipantTypeu45list { override def toString = "related-person" }


/** The type of participant in the activityIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ActionParticipantType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ActionParticipantTypeu45list]}
}

      

sealed trait ResourceTypeu45list

object ResourceTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ResourceTypeu45list]): ResourceTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ResourceTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ResourceTypeu45list] = Seq(AccountValue2, ActivityDefinitionValue2, AdverseEventValue2, AllergyIntoleranceValue2, AppointmentValue2, AppointmentResponseValue2, AuditEventValue2, BasicValue2, BinaryValue2, BodySiteValue2, BundleValue2, CapabilityStatementValue2, CarePlanValue2, CareTeamValue2, ChargeItemValue2, ClaimValue2, ClaimResponseValue2, ClinicalImpressionValue2, CodeSystemValue2, CommunicationValue2, CommunicationRequestValue2, CompartmentDefinitionValue2, CompositionValue2, ConceptMapValue2, ConditionValue2, ConsentValue2, ContractValue2, CoverageValue2, DataElementValue2, DetectedIssueValue2, DeviceValue3, DeviceComponentValue2, DeviceMetricValue2, DeviceRequestValue2, DeviceUseStatementValue2, DiagnosticReportValue2, DocumentManifestValue2, DocumentReferenceValue2, DomainResourceValue2, EligibilityRequestValue2, EligibilityResponseValue2, EncounterValue3, EndpointValue2, EnrollmentRequestValue2, EnrollmentResponseValue2, EpisodeOfCareValue2, ExpansionProfileValue2, ExplanationOfBenefitValue2, FamilyMemberHistoryValue2, FlagValue2, GoalValue2, GraphDefinitionValue2, GroupValue3, GuidanceResponseValue2, HealthcareServiceValue2, ImagingManifestValue2, ImagingStudyValue2, ImmunizationValue2, ImmunizationRecommendationValue2, ImplementationGuideValue2, LibraryValue2, LinkageValue2, ListTypeValue2, LocationValue2, MeasureValue2, MeasureReportValue2, MediaValue2, MedicationValue3, MedicationAdministrationValue2, MedicationDispenseValue2, MedicationRequestValue2, MedicationStatementValue2, MessageDefinitionValue2, MessageHeaderValue2, NamingSystemValue2, NutritionOrderValue2, ObservationValue2, OperationDefinitionValue2, OperationOutcomeValue2, OrganizationValue2, ParametersValue2, PatientValue3, PaymentNoticeValue2, PaymentReconciliationValue2, PersonValue2, PlanDefinitionValue2, PractitionerValue3, PractitionerRoleValue2, ProcedureValue2, ProcedureRequestValue2, ProcessRequestValue2, ProcessResponseValue2, ProvenanceValue2, QuestionnaireValue2, QuestionnaireResponseValue2, ReferralRequestValue2, RelatedPersonValue3, RequestGroupValue2, ResearchStudyValue2, ResearchSubjectValue2, ResourceValue2, RiskAssessmentValue2, ScheduleValue2, SearchParameterValue2, SequenceValue2, ServiceDefinitionValue2, SlotValue2, SpecimenValue2, StructureDefinitionValue2, StructureMapValue2, SubscriptionValue2, SubstanceValue2, SupplyDeliveryValue2, SupplyRequestValue2, TaskValue2, TestReportValue2, TestScriptValue2, ValueSetValue3, VisionPrescriptionValue2)
}

case object AccountValue2 extends ResourceTypeu45list { override def toString = "Account" }
case object ActivityDefinitionValue2 extends ResourceTypeu45list { override def toString = "ActivityDefinition" }
case object AdverseEventValue2 extends ResourceTypeu45list { override def toString = "AdverseEvent" }
case object AllergyIntoleranceValue2 extends ResourceTypeu45list { override def toString = "AllergyIntolerance" }
case object AppointmentValue2 extends ResourceTypeu45list { override def toString = "Appointment" }
case object AppointmentResponseValue2 extends ResourceTypeu45list { override def toString = "AppointmentResponse" }
case object AuditEventValue2 extends ResourceTypeu45list { override def toString = "AuditEvent" }
case object BasicValue2 extends ResourceTypeu45list { override def toString = "Basic" }
case object BinaryValue2 extends ResourceTypeu45list { override def toString = "Binary" }
case object BodySiteValue2 extends ResourceTypeu45list { override def toString = "BodySite" }
case object BundleValue2 extends ResourceTypeu45list { override def toString = "Bundle" }
case object CapabilityStatementValue2 extends ResourceTypeu45list { override def toString = "CapabilityStatement" }
case object CarePlanValue2 extends ResourceTypeu45list { override def toString = "CarePlan" }
case object CareTeamValue2 extends ResourceTypeu45list { override def toString = "CareTeam" }
case object ChargeItemValue2 extends ResourceTypeu45list { override def toString = "ChargeItem" }
case object ClaimValue2 extends ResourceTypeu45list { override def toString = "Claim" }
case object ClaimResponseValue2 extends ResourceTypeu45list { override def toString = "ClaimResponse" }
case object ClinicalImpressionValue2 extends ResourceTypeu45list { override def toString = "ClinicalImpression" }
case object CodeSystemValue2 extends ResourceTypeu45list { override def toString = "CodeSystem" }
case object CommunicationValue2 extends ResourceTypeu45list { override def toString = "Communication" }
case object CommunicationRequestValue2 extends ResourceTypeu45list { override def toString = "CommunicationRequest" }
case object CompartmentDefinitionValue2 extends ResourceTypeu45list { override def toString = "CompartmentDefinition" }
case object CompositionValue2 extends ResourceTypeu45list { override def toString = "Composition" }
case object ConceptMapValue2 extends ResourceTypeu45list { override def toString = "ConceptMap" }
case object ConditionValue2 extends ResourceTypeu45list { override def toString = "Condition" }
case object ConsentValue2 extends ResourceTypeu45list { override def toString = "Consent" }
case object ContractValue2 extends ResourceTypeu45list { override def toString = "Contract" }
case object CoverageValue2 extends ResourceTypeu45list { override def toString = "Coverage" }
case object DataElementValue2 extends ResourceTypeu45list { override def toString = "DataElement" }
case object DetectedIssueValue2 extends ResourceTypeu45list { override def toString = "DetectedIssue" }
case object DeviceValue3 extends ResourceTypeu45list { override def toString = "Device" }
case object DeviceComponentValue2 extends ResourceTypeu45list { override def toString = "DeviceComponent" }
case object DeviceMetricValue2 extends ResourceTypeu45list { override def toString = "DeviceMetric" }
case object DeviceRequestValue2 extends ResourceTypeu45list { override def toString = "DeviceRequest" }
case object DeviceUseStatementValue2 extends ResourceTypeu45list { override def toString = "DeviceUseStatement" }
case object DiagnosticReportValue2 extends ResourceTypeu45list { override def toString = "DiagnosticReport" }
case object DocumentManifestValue2 extends ResourceTypeu45list { override def toString = "DocumentManifest" }
case object DocumentReferenceValue2 extends ResourceTypeu45list { override def toString = "DocumentReference" }
case object DomainResourceValue2 extends ResourceTypeu45list { override def toString = "DomainResource" }
case object EligibilityRequestValue2 extends ResourceTypeu45list { override def toString = "EligibilityRequest" }
case object EligibilityResponseValue2 extends ResourceTypeu45list { override def toString = "EligibilityResponse" }
case object EncounterValue3 extends ResourceTypeu45list { override def toString = "Encounter" }
case object EndpointValue2 extends ResourceTypeu45list { override def toString = "Endpoint" }
case object EnrollmentRequestValue2 extends ResourceTypeu45list { override def toString = "EnrollmentRequest" }
case object EnrollmentResponseValue2 extends ResourceTypeu45list { override def toString = "EnrollmentResponse" }
case object EpisodeOfCareValue2 extends ResourceTypeu45list { override def toString = "EpisodeOfCare" }
case object ExpansionProfileValue2 extends ResourceTypeu45list { override def toString = "ExpansionProfile" }
case object ExplanationOfBenefitValue2 extends ResourceTypeu45list { override def toString = "ExplanationOfBenefit" }
case object FamilyMemberHistoryValue2 extends ResourceTypeu45list { override def toString = "FamilyMemberHistory" }
case object FlagValue2 extends ResourceTypeu45list { override def toString = "Flag" }
case object GoalValue2 extends ResourceTypeu45list { override def toString = "Goal" }
case object GraphDefinitionValue2 extends ResourceTypeu45list { override def toString = "GraphDefinition" }
case object GroupValue3 extends ResourceTypeu45list { override def toString = "Group" }
case object GuidanceResponseValue2 extends ResourceTypeu45list { override def toString = "GuidanceResponse" }
case object HealthcareServiceValue2 extends ResourceTypeu45list { override def toString = "HealthcareService" }
case object ImagingManifestValue2 extends ResourceTypeu45list { override def toString = "ImagingManifest" }
case object ImagingStudyValue2 extends ResourceTypeu45list { override def toString = "ImagingStudy" }
case object ImmunizationValue2 extends ResourceTypeu45list { override def toString = "Immunization" }
case object ImmunizationRecommendationValue2 extends ResourceTypeu45list { override def toString = "ImmunizationRecommendation" }
case object ImplementationGuideValue2 extends ResourceTypeu45list { override def toString = "ImplementationGuide" }
case object LibraryValue2 extends ResourceTypeu45list { override def toString = "Library" }
case object LinkageValue2 extends ResourceTypeu45list { override def toString = "Linkage" }
case object ListTypeValue2 extends ResourceTypeu45list { override def toString = "List" }
case object LocationValue2 extends ResourceTypeu45list { override def toString = "Location" }
case object MeasureValue2 extends ResourceTypeu45list { override def toString = "Measure" }
case object MeasureReportValue2 extends ResourceTypeu45list { override def toString = "MeasureReport" }
case object MediaValue2 extends ResourceTypeu45list { override def toString = "Media" }
case object MedicationValue3 extends ResourceTypeu45list { override def toString = "Medication" }
case object MedicationAdministrationValue2 extends ResourceTypeu45list { override def toString = "MedicationAdministration" }
case object MedicationDispenseValue2 extends ResourceTypeu45list { override def toString = "MedicationDispense" }
case object MedicationRequestValue2 extends ResourceTypeu45list { override def toString = "MedicationRequest" }
case object MedicationStatementValue2 extends ResourceTypeu45list { override def toString = "MedicationStatement" }
case object MessageDefinitionValue2 extends ResourceTypeu45list { override def toString = "MessageDefinition" }
case object MessageHeaderValue2 extends ResourceTypeu45list { override def toString = "MessageHeader" }
case object NamingSystemValue2 extends ResourceTypeu45list { override def toString = "NamingSystem" }
case object NutritionOrderValue2 extends ResourceTypeu45list { override def toString = "NutritionOrder" }
case object ObservationValue2 extends ResourceTypeu45list { override def toString = "Observation" }
case object OperationDefinitionValue2 extends ResourceTypeu45list { override def toString = "OperationDefinition" }
case object OperationOutcomeValue2 extends ResourceTypeu45list { override def toString = "OperationOutcome" }
case object OrganizationValue2 extends ResourceTypeu45list { override def toString = "Organization" }
case object ParametersValue2 extends ResourceTypeu45list { override def toString = "Parameters" }
case object PatientValue3 extends ResourceTypeu45list { override def toString = "Patient" }
case object PaymentNoticeValue2 extends ResourceTypeu45list { override def toString = "PaymentNotice" }
case object PaymentReconciliationValue2 extends ResourceTypeu45list { override def toString = "PaymentReconciliation" }
case object PersonValue2 extends ResourceTypeu45list { override def toString = "Person" }
case object PlanDefinitionValue2 extends ResourceTypeu45list { override def toString = "PlanDefinition" }
case object PractitionerValue3 extends ResourceTypeu45list { override def toString = "Practitioner" }
case object PractitionerRoleValue2 extends ResourceTypeu45list { override def toString = "PractitionerRole" }
case object ProcedureValue2 extends ResourceTypeu45list { override def toString = "Procedure" }
case object ProcedureRequestValue2 extends ResourceTypeu45list { override def toString = "ProcedureRequest" }
case object ProcessRequestValue2 extends ResourceTypeu45list { override def toString = "ProcessRequest" }
case object ProcessResponseValue2 extends ResourceTypeu45list { override def toString = "ProcessResponse" }
case object ProvenanceValue2 extends ResourceTypeu45list { override def toString = "Provenance" }
case object QuestionnaireValue2 extends ResourceTypeu45list { override def toString = "Questionnaire" }
case object QuestionnaireResponseValue2 extends ResourceTypeu45list { override def toString = "QuestionnaireResponse" }
case object ReferralRequestValue2 extends ResourceTypeu45list { override def toString = "ReferralRequest" }
case object RelatedPersonValue3 extends ResourceTypeu45list { override def toString = "RelatedPerson" }
case object RequestGroupValue2 extends ResourceTypeu45list { override def toString = "RequestGroup" }
case object ResearchStudyValue2 extends ResourceTypeu45list { override def toString = "ResearchStudy" }
case object ResearchSubjectValue2 extends ResourceTypeu45list { override def toString = "ResearchSubject" }
case object ResourceValue2 extends ResourceTypeu45list { override def toString = "Resource" }
case object RiskAssessmentValue2 extends ResourceTypeu45list { override def toString = "RiskAssessment" }
case object ScheduleValue2 extends ResourceTypeu45list { override def toString = "Schedule" }
case object SearchParameterValue2 extends ResourceTypeu45list { override def toString = "SearchParameter" }
case object SequenceValue2 extends ResourceTypeu45list { override def toString = "Sequence" }
case object ServiceDefinitionValue2 extends ResourceTypeu45list { override def toString = "ServiceDefinition" }
case object SlotValue2 extends ResourceTypeu45list { override def toString = "Slot" }
case object SpecimenValue2 extends ResourceTypeu45list { override def toString = "Specimen" }
case object StructureDefinitionValue2 extends ResourceTypeu45list { override def toString = "StructureDefinition" }
case object StructureMapValue2 extends ResourceTypeu45list { override def toString = "StructureMap" }
case object SubscriptionValue2 extends ResourceTypeu45list { override def toString = "Subscription" }
case object SubstanceValue2 extends ResourceTypeu45list { override def toString = "Substance" }
case object SupplyDeliveryValue2 extends ResourceTypeu45list { override def toString = "SupplyDelivery" }
case object SupplyRequestValue2 extends ResourceTypeu45list { override def toString = "SupplyRequest" }
case object TaskValue2 extends ResourceTypeu45list { override def toString = "Task" }
case object TestReportValue2 extends ResourceTypeu45list { override def toString = "TestReport" }
case object TestScriptValue2 extends ResourceTypeu45list { override def toString = "TestScript" }
case object ValueSetValue3 extends ResourceTypeu45list { override def toString = "ValueSet" }
case object VisionPrescriptionValue2 extends ResourceTypeu45list { override def toString = "VisionPrescription" }


/** The kind of activity the definition is describingIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ResourceTypeType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ResourceTypeu45list]}
}

      


/** Actual or  potential/avoided event causing unintended physical injury resulting from or contributed to by medical care, a research study or other healthcare setting factors that requires additional monitoring, treatment, or hospitalization, or that results in death.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AdverseEventType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  category: Option[AdverseEventCategory] = None,
  typeValue: Option[CodeableConceptType] = None,
  subject: Option[ReferenceType] = None,
  date: Option[DateTimeType] = None,
  reaction: Seq[ReferenceType] = Nil,
  location: Option[ReferenceType] = None,
  seriousness: Option[CodeableConceptType] = None,
  outcome: Option[CodeableConceptType] = None,
  recorder: Option[ReferenceType] = None,
  eventParticipant: Option[ReferenceType] = None,
  description: Option[StringTypeType] = None,
  suspectEntity: Seq[AdverseEventu46SuspectEntity] = Nil,
  subjectMedicalHistory: Seq[ReferenceType] = Nil,
  referenceDocument: Seq[ReferenceType] = Nil,
  study: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** Actual or  potential/avoided event causing unintended physical injury resulting from or contributed to by medical care, a research study or other healthcare setting factors that requires additional monitoring, treatment, or hospitalization, or that results in death.
*/
case class AdverseEventu46SuspectEntity(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  instance: ReferenceType,
  causality: Option[AdverseEventCausality] = None,
  causalityAssessment: Option[CodeableConceptType] = None,
  causalityProductRelatedness: Option[StringTypeType] = None,
  causalityMethod: Option[CodeableConceptType] = None,
  causalityAuthor: Option[ReferenceType] = None,
  causalityResult: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait AdverseEventCausalityu45list

object AdverseEventCausalityu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AdverseEventCausalityu45list]): AdverseEventCausalityu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AdverseEventCausalityu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AdverseEventCausalityu45list] = Seq(Causality1, Causality2)
}

case object Causality1 extends AdverseEventCausalityu45list { override def toString = "causality1" }
case object Causality2 extends AdverseEventCausalityu45list { override def toString = "causality2" }


/** TODOIf the element is present, it must have either a @value, an @id, or extensions
*/
case class AdverseEventCausality(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AdverseEventCausalityu45list]}
}

      

sealed trait AdverseEventCategoryu45list

object AdverseEventCategoryu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AdverseEventCategoryu45list]): AdverseEventCategoryu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AdverseEventCategoryu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AdverseEventCategoryu45list] = Seq(AE, PAE)
}

case object AE extends AdverseEventCategoryu45list { override def toString = "AE" }
case object PAE extends AdverseEventCategoryu45list { override def toString = "PAE" }


/** Overall categorization of the event, e.g. real or potentialIf the element is present, it must have either a @value, an @id, or extensions
*/
case class AdverseEventCategory(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AdverseEventCategoryu45list]}
}

      


/** Risk of harmful or undesirable, physiological response which is unique to an individual and associated with exposure to a substance.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AllergyIntoleranceType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  clinicalStatus: Option[AllergyIntoleranceClinicalStatus] = None,
  verificationStatus: AllergyIntoleranceVerificationStatus,
  typeValue: Option[AllergyIntoleranceTypeType] = None,
  category: Seq[AllergyIntoleranceCategory] = Nil,
  criticality: Option[AllergyIntoleranceCriticality] = None,
  code: Option[CodeableConceptType] = None,
  patient: ReferenceType,
  onsetDateTime: Option[DateTimeType] = None,
  onsetAge: Option[AgeType] = None,
  onsetPeriod: Option[PeriodType] = None,
  onsetRange: Option[RangeTypeType] = None,
  onsetString: Option[StringTypeType] = None,
  assertedDate: Option[DateTimeType] = None,
  recorder: Option[ReferenceType] = None,
  asserter: Option[ReferenceType] = None,
  lastOccurrence: Option[DateTimeType] = None,
  note: Seq[AnnotationType] = Nil,
  reaction: Seq[AllergyIntoleranceu46Reaction] = Nil) extends DomainResourcable
      


/** Risk of harmful or undesirable, physiological response which is unique to an individual and associated with exposure to a substance.
*/
case class AllergyIntoleranceu46Reaction(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  substance: Option[CodeableConceptType] = None,
  manifestation: Seq[CodeableConceptType] = Nil,
  description: Option[StringTypeType] = None,
  onset: Option[DateTimeType] = None,
  severity: Option[AllergyIntoleranceSeverity] = None,
  exposureRoute: Option[CodeableConceptType] = None,
  note: Seq[AnnotationType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait AllergyIntoleranceCriticalityu45list

object AllergyIntoleranceCriticalityu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AllergyIntoleranceCriticalityu45list]): AllergyIntoleranceCriticalityu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AllergyIntoleranceCriticalityu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AllergyIntoleranceCriticalityu45list] = Seq(Low, High, Unableu45tou45assess)
}

case object Low extends AllergyIntoleranceCriticalityu45list { override def toString = "low" }
case object High extends AllergyIntoleranceCriticalityu45list { override def toString = "high" }
case object Unableu45tou45assess extends AllergyIntoleranceCriticalityu45list { override def toString = "unable-to-assess" }


/** Estimate of the potential clinical harm, or seriousness, of a reaction to an identified substance.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AllergyIntoleranceCriticality(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AllergyIntoleranceCriticalityu45list]}
}

      

sealed trait AllergyIntoleranceTypeu45list

object AllergyIntoleranceTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AllergyIntoleranceTypeu45list]): AllergyIntoleranceTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AllergyIntoleranceTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AllergyIntoleranceTypeu45list] = Seq(Allergy, Intolerance)
}

case object Allergy extends AllergyIntoleranceTypeu45list { override def toString = "allergy" }
case object Intolerance extends AllergyIntoleranceTypeu45list { override def toString = "intolerance" }


/** Identification of the underlying physiological mechanism for a Reaction Risk.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AllergyIntoleranceTypeType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AllergyIntoleranceTypeu45list]}
}

      

sealed trait AllergyIntoleranceCategoryu45list

object AllergyIntoleranceCategoryu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AllergyIntoleranceCategoryu45list]): AllergyIntoleranceCategoryu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AllergyIntoleranceCategoryu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AllergyIntoleranceCategoryu45list] = Seq(Food, MedicationValue2, Environment, Biologic)
}

case object Food extends AllergyIntoleranceCategoryu45list { override def toString = "food" }
case object MedicationValue2 extends AllergyIntoleranceCategoryu45list { override def toString = "medication" }
case object Environment extends AllergyIntoleranceCategoryu45list { override def toString = "environment" }
case object Biologic extends AllergyIntoleranceCategoryu45list { override def toString = "biologic" }


/** Category of an identified substance.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AllergyIntoleranceCategory(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AllergyIntoleranceCategoryu45list]}
}

      

sealed trait AllergyIntoleranceVerificationStatusu45list

object AllergyIntoleranceVerificationStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AllergyIntoleranceVerificationStatusu45list]): AllergyIntoleranceVerificationStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AllergyIntoleranceVerificationStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AllergyIntoleranceVerificationStatusu45list] = Seq(Unconfirmed, ConfirmedValue, RefutedValue, Enteredu45inu45errorValue15)
}

case object Unconfirmed extends AllergyIntoleranceVerificationStatusu45list { override def toString = "unconfirmed" }
case object ConfirmedValue extends AllergyIntoleranceVerificationStatusu45list { override def toString = "confirmed" }
case object RefutedValue extends AllergyIntoleranceVerificationStatusu45list { override def toString = "refuted" }
case object Enteredu45inu45errorValue15 extends AllergyIntoleranceVerificationStatusu45list { override def toString = "entered-in-error" }


/** Assertion about certainty associated with a propensity, or potential risk, of a reaction to the identified substance.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AllergyIntoleranceVerificationStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AllergyIntoleranceVerificationStatusu45list]}
}

      

sealed trait AllergyIntoleranceSeverityu45list

object AllergyIntoleranceSeverityu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AllergyIntoleranceSeverityu45list]): AllergyIntoleranceSeverityu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AllergyIntoleranceSeverityu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AllergyIntoleranceSeverityu45list] = Seq(Mild, Moderate, Severe)
}

case object Mild extends AllergyIntoleranceSeverityu45list { override def toString = "mild" }
case object Moderate extends AllergyIntoleranceSeverityu45list { override def toString = "moderate" }
case object Severe extends AllergyIntoleranceSeverityu45list { override def toString = "severe" }


/** Clinical assessment of the severity of a reaction event as a whole, potentially considering multiple different manifestations.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AllergyIntoleranceSeverity(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AllergyIntoleranceSeverityu45list]}
}

      

sealed trait AllergyIntoleranceClinicalStatusu45list

object AllergyIntoleranceClinicalStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AllergyIntoleranceClinicalStatusu45list]): AllergyIntoleranceClinicalStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AllergyIntoleranceClinicalStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AllergyIntoleranceClinicalStatusu45list] = Seq(ActiveValue11, InactiveValue3, ResolvedValue)
}

case object ActiveValue11 extends AllergyIntoleranceClinicalStatusu45list { override def toString = "active" }
case object InactiveValue3 extends AllergyIntoleranceClinicalStatusu45list { override def toString = "inactive" }
case object ResolvedValue extends AllergyIntoleranceClinicalStatusu45list { override def toString = "resolved" }


/** The clinical status of the allergy or intolerance.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AllergyIntoleranceClinicalStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AllergyIntoleranceClinicalStatusu45list]}
}

      


/** A booking of a healthcare event among patient(s), practitioner(s), related person(s) and/or device(s) for a specific date/time. This may result in one or more Encounter(s).If the element is present, it must have either a @value, an @id, or extensions
*/
case class AppointmentType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: AppointmentStatus,
  serviceCategory: Option[CodeableConceptType] = None,
  serviceType: Seq[CodeableConceptType] = Nil,
  specialty: Seq[CodeableConceptType] = Nil,
  appointmentType: Option[CodeableConceptType] = None,
  reason: Seq[CodeableConceptType] = Nil,
  indication: Seq[ReferenceType] = Nil,
  priority: Option[UnsignedIntType] = None,
  description: Option[StringTypeType] = None,
  supportingInformation: Seq[ReferenceType] = Nil,
  start: Option[InstantType] = None,
  end: Option[InstantType] = None,
  minutesDuration: Option[PositiveIntType] = None,
  slot: Seq[ReferenceType] = Nil,
  created: Option[DateTimeType] = None,
  comment: Option[StringTypeType] = None,
  incomingReferral: Seq[ReferenceType] = Nil,
  participant: Seq[Appointmentu46Participant] = Nil,
  requestedPeriod: Seq[PeriodType] = Nil) extends DomainResourcable
      


/** A booking of a healthcare event among patient(s), practitioner(s), related person(s) and/or device(s) for a specific date/time. This may result in one or more Encounter(s).
*/
case class Appointmentu46Participant(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: Seq[CodeableConceptType] = Nil,
  actor: Option[ReferenceType] = None,
  required: Option[ParticipantRequired] = None,
  status: ParticipationStatus,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ParticipantRequiredu45list

object ParticipantRequiredu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ParticipantRequiredu45list]): ParticipantRequiredu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParticipantRequiredu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ParticipantRequiredu45list] = Seq(RequiredValue, Optional, Informationu45only)
}

case object RequiredValue extends ParticipantRequiredu45list { override def toString = "required" }
case object Optional extends ParticipantRequiredu45list { override def toString = "optional" }
case object Informationu45only extends ParticipantRequiredu45list { override def toString = "information-only" }


/** Is the Participant required to attend the appointment.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ParticipantRequired(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ParticipantRequiredu45list]}
}

      

sealed trait AppointmentStatusu45list

object AppointmentStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AppointmentStatusu45list]): AppointmentStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AppointmentStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AppointmentStatusu45list] = Seq(ProposedValue2, Pending, Booked, ArrivedValue, Fulfilled, CancelledValue6, Noshow, Enteredu45inu45errorValue14)
}

case object ProposedValue2 extends AppointmentStatusu45list { override def toString = "proposed" }
case object Pending extends AppointmentStatusu45list { override def toString = "pending" }
case object Booked extends AppointmentStatusu45list { override def toString = "booked" }
case object ArrivedValue extends AppointmentStatusu45list { override def toString = "arrived" }
case object Fulfilled extends AppointmentStatusu45list { override def toString = "fulfilled" }
case object CancelledValue6 extends AppointmentStatusu45list { override def toString = "cancelled" }
case object Noshow extends AppointmentStatusu45list { override def toString = "noshow" }
case object Enteredu45inu45errorValue14 extends AppointmentStatusu45list { override def toString = "entered-in-error" }


/** The free/busy status of an appointment.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AppointmentStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AppointmentStatusu45list]}
}

      

sealed trait ParticipationStatusu45list

object ParticipationStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ParticipationStatusu45list]): ParticipationStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParticipationStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ParticipationStatusu45list] = Seq(AcceptedValue, Declined, Tentative, Needsu45action)
}

case object AcceptedValue extends ParticipationStatusu45list { override def toString = "accepted" }
case object Declined extends ParticipationStatusu45list { override def toString = "declined" }
case object Tentative extends ParticipationStatusu45list { override def toString = "tentative" }
case object Needsu45action extends ParticipationStatusu45list { override def toString = "needs-action" }


/** The Participation status of an appointment.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ParticipationStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ParticipationStatusu45list]}
}

      


/** A reply to an appointment request for a patient and/or practitioner(s), such as a confirmation or rejection.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AppointmentResponseType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  appointment: ReferenceType,
  start: Option[InstantType] = None,
  end: Option[InstantType] = None,
  participantType: Seq[CodeableConceptType] = Nil,
  actor: Option[ReferenceType] = None,
  participantStatus: ParticipationStatus,
  comment: Option[StringTypeType] = None) extends DomainResourcable
      


/** A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AuditEventType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: CodingType,
  subtype: Seq[CodingType] = Nil,
  action: Option[AuditEventAction] = None,
  recorded: InstantType,
  outcome: Option[AuditEventOutcome] = None,
  outcomeDesc: Option[StringTypeType] = None,
  purposeOfEvent: Seq[CodeableConceptType] = Nil,
  agent: Seq[AuditEventu46Agent] = Nil,
  source: AuditEventu46Source,
  entity: Seq[AuditEventu46Entity] = Nil) extends DomainResourcable
      


/** A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage.
*/
case class AuditEventu46Agent(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  role: Seq[CodeableConceptType] = Nil,
  reference: Option[ReferenceType] = None,
  userId: Option[IdentifierType] = None,
  altId: Option[StringTypeType] = None,
  name: Option[StringTypeType] = None,
  requestor: BooleanTypeType,
  location: Option[ReferenceType] = None,
  policy: Seq[UriType] = Nil,
  media: Option[CodingType] = None,
  network: Option[AuditEventu46Network] = None,
  purposeOfUse: Seq[CodeableConceptType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage.
*/
case class AuditEventu46Network(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  address: Option[StringTypeType] = None,
  typeValue: Option[AuditEventAgentNetworkType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage.
*/
case class AuditEventu46Source(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  site: Option[StringTypeType] = None,
  identifier: IdentifierType,
  typeValue: Seq[CodingType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage.
*/
case class AuditEventu46Entity(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  reference: Option[ReferenceType] = None,
  typeValue: Option[CodingType] = None,
  role: Option[CodingType] = None,
  lifecycle: Option[CodingType] = None,
  securityLabel: Seq[CodingType] = Nil,
  name: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  query: Option[Base64BinaryTypeType] = None,
  detail: Seq[AuditEventu46Detail] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage.
*/
case class AuditEventu46Detail(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: StringTypeType,
  value: Base64BinaryTypeType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait AuditEventOutcomeu45list

object AuditEventOutcomeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AuditEventOutcomeu45list]): AuditEventOutcomeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AuditEventOutcomeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AuditEventOutcomeu45list] = Seq(Number0, Number4, Number8, Number12)
}

case object Number0 extends AuditEventOutcomeu45list { override def toString = "0" }
case object Number4 extends AuditEventOutcomeu45list { override def toString = "4" }
case object Number8 extends AuditEventOutcomeu45list { override def toString = "8" }
case object Number12 extends AuditEventOutcomeu45list { override def toString = "12" }


/** Indicates whether the event succeeded or failedIf the element is present, it must have either a @value, an @id, or extensions
*/
case class AuditEventOutcome(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AuditEventOutcomeu45list]}
}

      

sealed trait AuditEventActionu45list

object AuditEventActionu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AuditEventActionu45list]): AuditEventActionu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AuditEventActionu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AuditEventActionu45list] = Seq(CValue2, R, U, DValue, E)
}

case object CValue2 extends AuditEventActionu45list { override def toString = "C" }
case object R extends AuditEventActionu45list { override def toString = "R" }
case object U extends AuditEventActionu45list { override def toString = "U" }
case object DValue extends AuditEventActionu45list { override def toString = "D" }
case object E extends AuditEventActionu45list { override def toString = "E" }


/** Indicator for type of action performed during the event that generated the eventIf the element is present, it must have either a @value, an @id, or extensions
*/
case class AuditEventAction(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AuditEventActionu45list]}
}

      

sealed trait AuditEventAgentNetworkTypeu45list

object AuditEventAgentNetworkTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AuditEventAgentNetworkTypeu45list]): AuditEventAgentNetworkTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AuditEventAgentNetworkTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AuditEventAgentNetworkTypeu45list] = Seq(Number1, Number2, Number3, Number4Value, Number5)
}

case object Number1 extends AuditEventAgentNetworkTypeu45list { override def toString = "1" }
case object Number2 extends AuditEventAgentNetworkTypeu45list { override def toString = "2" }
case object Number3 extends AuditEventAgentNetworkTypeu45list { override def toString = "3" }
case object Number4Value extends AuditEventAgentNetworkTypeu45list { override def toString = "4" }
case object Number5 extends AuditEventAgentNetworkTypeu45list { override def toString = "5" }


/** The type of network access point of this agent in the audit eventIf the element is present, it must have either a @value, an @id, or extensions
*/
case class AuditEventAgentNetworkType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AuditEventAgentNetworkTypeu45list]}
}

      


/** Basic is used for handling concepts not yet defined in FHIR, narrative-only resources that don't map to an existing resource, and custom resources not appropriate for inclusion in the FHIR specification.If the element is present, it must have either a @value, an @id, or extensions
*/
case class BasicType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  code: CodeableConceptType,
  subject: Option[ReferenceType] = None,
  created: Option[DateType] = None,
  author: Option[ReferenceType] = None) extends DomainResourcable
      


/** A binary resource can contain any content, whether text, image, pdf, zip archive, etc.If the element is present, it must have either a @value, an @id, or extensions
*/
case class BinaryType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  contentType: CodeType,
  securityContext: Option[ReferenceType] = None,
  content: Base64BinaryTypeType) extends Resourcable
      


/** Record details about the anatomical location of a specimen or body part.  This resource may be used when a coded concept does not provide the necessary detail needed for the use case.If the element is present, it must have either a @value, an @id, or extensions
*/
case class BodySiteType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  active: Option[BooleanTypeType] = None,
  code: Option[CodeableConceptType] = None,
  qualifier: Seq[CodeableConceptType] = Nil,
  description: Option[StringTypeType] = None,
  image: Seq[AttachmentType] = Nil,
  patient: ReferenceType) extends DomainResourcable
      


/** A container for a collection of resources.If the element is present, it must have either a @value, an @id, or extensions
*/
case class BundleType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  identifier: Option[IdentifierType] = None,
  typeValue: BundleTypeType,
  total: Option[UnsignedIntType] = None,
  link: Seq[Bundleu46Link] = Nil,
  entry: Seq[Bundleu46Entry] = Nil,
  signature: Option[SignatureType] = None) extends Resourcable
      


/** A container for a collection of resources.
*/
case class Bundleu46Link(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  relation: StringTypeType,
  url: UriType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A container for a collection of resources.
*/
case class Bundleu46Entry(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  link: Seq[Bundleu46Link] = Nil,
  fullUrl: Option[UriType] = None,
  resource: Option[ResourceContainer] = None,
  search: Option[Bundleu46Search] = None,
  request: Option[Bundleu46Request] = None,
  response: Option[Bundleu46Response] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A container for a collection of resources.
*/
case class Bundleu46Search(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  mode: Option[SearchEntryMode] = None,
  score: Option[DecimalType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A container for a collection of resources.
*/
case class Bundleu46Request(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  method: HTTPVerb,
  url: UriType,
  ifNoneMatch: Option[StringTypeType] = None,
  ifModifiedSince: Option[InstantType] = None,
  ifMatch: Option[StringTypeType] = None,
  ifNoneExist: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A container for a collection of resources.
*/
case class Bundleu46Response(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  status: StringTypeType,
  location: Option[UriType] = None,
  etag: Option[StringTypeType] = None,
  lastModified: Option[InstantType] = None,
  outcome: Option[ResourceContainer] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait HTTPVerbu45list

object HTTPVerbu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[HTTPVerbu45list]): HTTPVerbu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: HTTPVerbu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[HTTPVerbu45list] = Seq(GETValue, POSTValue, PUTValue, DELETEValue2)
}

case object GETValue extends HTTPVerbu45list { override def toString = "GET" }
case object POSTValue extends HTTPVerbu45list { override def toString = "POST" }
case object PUTValue extends HTTPVerbu45list { override def toString = "PUT" }
case object DELETEValue2 extends HTTPVerbu45list { override def toString = "DELETE" }


/** HTTP verbs (in the HTTP command line).If the element is present, it must have either a @value, an @id, or extensions
*/
case class HTTPVerb(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[HTTPVerbu45list]}
}

      

sealed trait BundleTypeu45list

object BundleTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[BundleTypeu45list]): BundleTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: BundleTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[BundleTypeu45list] = Seq(Document, MessageValue, TransactionValue, Transactionu45response, BatchValue, Batchu45response, History, Searchset, Collection)
}

case object Document extends BundleTypeu45list { override def toString = "document" }
case object MessageValue extends BundleTypeu45list { override def toString = "message" }
case object TransactionValue extends BundleTypeu45list { override def toString = "transaction" }
case object Transactionu45response extends BundleTypeu45list { override def toString = "transaction-response" }
case object BatchValue extends BundleTypeu45list { override def toString = "batch" }
case object Batchu45response extends BundleTypeu45list { override def toString = "batch-response" }
case object History extends BundleTypeu45list { override def toString = "history" }
case object Searchset extends BundleTypeu45list { override def toString = "searchset" }
case object Collection extends BundleTypeu45list { override def toString = "collection" }


/** Indicates the purpose of a bundle - how it was intended to be used.If the element is present, it must have either a @value, an @id, or extensions
*/
case class BundleTypeType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[BundleTypeu45list]}
}

      

sealed trait SearchEntryModeu45list

object SearchEntryModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[SearchEntryModeu45list]): SearchEntryModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SearchEntryModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SearchEntryModeu45list] = Seq(Match, Include, Outcome)
}

case object Match extends SearchEntryModeu45list { override def toString = "match" }
case object Include extends SearchEntryModeu45list { override def toString = "include" }
case object Outcome extends SearchEntryModeu45list { override def toString = "outcome" }


/** Why an entry is in the result set - whether it's included as a match or because of an _include requirement.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SearchEntryMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[SearchEntryModeu45list]}
}

      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.If the element is present, it must have either a @value, an @id, or extensions
*/
case class CapabilityStatementType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: Option[UriType] = None,
  version: Option[StringTypeType] = None,
  name: Option[StringTypeType] = None,
  title: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: DateTimeType,
  publisher: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  description: Option[MarkdownType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  purpose: Option[MarkdownType] = None,
  copyright: Option[MarkdownType] = None,
  kind: CapabilityStatementKind,
  instantiates: Seq[UriType] = Nil,
  software: Option[CapabilityStatementu46Software] = None,
  implementation: Option[CapabilityStatementu46Implementation] = None,
  fhirVersion: IdType,
  acceptUnknown: UnknownContentCode,
  format: Seq[CodeType] = Nil,
  patchFormat: Seq[CodeType] = Nil,
  implementationGuide: Seq[UriType] = Nil,
  profile: Seq[ReferenceType] = Nil,
  rest: Seq[CapabilityStatementu46Rest] = Nil,
  messaging: Seq[CapabilityStatementu46Messaging] = Nil,
  document: Seq[CapabilityStatementu46Document] = Nil) extends DomainResourcable
      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
*/
case class CapabilityStatementu46Software(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: StringTypeType,
  version: Option[StringTypeType] = None,
  releaseDate: Option[DateTimeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
*/
case class CapabilityStatementu46Implementation(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  description: StringTypeType,
  url: Option[UriType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
*/
case class CapabilityStatementu46Rest(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  mode: RestfulCapabilityMode,
  documentation: Option[StringTypeType] = None,
  security: Option[CapabilityStatementu46Security] = None,
  resource: Seq[CapabilityStatementu46Resource] = Nil,
  interaction: Seq[CapabilityStatementu46Interaction1] = Nil,
  searchParam: Seq[CapabilityStatementu46SearchParam] = Nil,
  operation: Seq[CapabilityStatementu46Operation] = Nil,
  compartment: Seq[UriType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
*/
case class CapabilityStatementu46Security(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  cors: Option[BooleanTypeType] = None,
  service: Seq[CodeableConceptType] = Nil,
  description: Option[StringTypeType] = None,
  certificate: Seq[CapabilityStatementu46Certificate] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
*/
case class CapabilityStatementu46Certificate(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: Option[CodeType] = None,
  blob: Option[Base64BinaryTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
*/
case class CapabilityStatementu46Resource(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: ResourceTypeType,
  profile: Option[ReferenceType] = None,
  documentation: Option[MarkdownType] = None,
  interaction: Seq[CapabilityStatementu46Interaction] = Nil,
  versioning: Option[ResourceVersionPolicy] = None,
  readHistory: Option[BooleanTypeType] = None,
  updateCreate: Option[BooleanTypeType] = None,
  conditionalCreate: Option[BooleanTypeType] = None,
  conditionalRead: Option[ConditionalReadStatus] = None,
  conditionalUpdate: Option[BooleanTypeType] = None,
  conditionalDelete: Option[ConditionalDeleteStatus] = None,
  referencePolicy: Seq[ReferenceHandlingPolicy] = Nil,
  searchInclude: Seq[StringTypeType] = Nil,
  searchRevInclude: Seq[StringTypeType] = Nil,
  searchParam: Seq[CapabilityStatementu46SearchParam] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
*/
case class CapabilityStatementu46Interaction(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: TypeRestfulInteraction,
  documentation: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
*/
case class CapabilityStatementu46SearchParam(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: StringTypeType,
  definition: Option[UriType] = None,
  typeValue: SearchParamType,
  documentation: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
*/
case class CapabilityStatementu46Interaction1(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: SystemRestfulInteraction,
  documentation: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
*/
case class CapabilityStatementu46Operation(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: StringTypeType,
  definition: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
*/
case class CapabilityStatementu46Messaging(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  endpoint: Seq[CapabilityStatementu46Endpoint] = Nil,
  reliableCache: Option[UnsignedIntType] = None,
  documentation: Option[StringTypeType] = None,
  supportedMessage: Seq[CapabilityStatementu46SupportedMessage] = Nil,
  event: Seq[CapabilityStatementu46Event] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
*/
case class CapabilityStatementu46Endpoint(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  protocol: CodingType,
  address: UriType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
*/
case class CapabilityStatementu46SupportedMessage(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  mode: EventCapabilityMode,
  definition: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
*/
case class CapabilityStatementu46Event(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: CodingType,
  category: Option[MessageSignificanceCategory] = None,
  mode: EventCapabilityMode,
  focus: ResourceTypeType,
  request: ReferenceType,
  response: ReferenceType,
  documentation: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
*/
case class CapabilityStatementu46Document(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  mode: DocumentMode,
  documentation: Option[StringTypeType] = None,
  profile: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait CapabilityStatementKindu45list

object CapabilityStatementKindu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[CapabilityStatementKindu45list]): CapabilityStatementKindu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CapabilityStatementKindu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[CapabilityStatementKindu45list] = Seq(InstanceValue, Capability, Requirements)
}

case object InstanceValue extends CapabilityStatementKindu45list { override def toString = "instance" }
case object Capability extends CapabilityStatementKindu45list { override def toString = "capability" }
case object Requirements extends CapabilityStatementKindu45list { override def toString = "requirements" }


/** How a capability statement is intended to be used.If the element is present, it must have either a @value, an @id, or extensions
*/
case class CapabilityStatementKind(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[CapabilityStatementKindu45list]}
}

      

sealed trait EventCapabilityModeu45list

object EventCapabilityModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[EventCapabilityModeu45list]): EventCapabilityModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: EventCapabilityModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[EventCapabilityModeu45list] = Seq(Sender, Receiver)
}

case object Sender extends EventCapabilityModeu45list { override def toString = "sender" }
case object Receiver extends EventCapabilityModeu45list { override def toString = "receiver" }


/** The mode of a message capability statement.If the element is present, it must have either a @value, an @id, or extensions
*/
case class EventCapabilityMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[EventCapabilityModeu45list]}
}

      

sealed trait ResourceVersionPolicyu45list

object ResourceVersionPolicyu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ResourceVersionPolicyu45list]): ResourceVersionPolicyu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ResourceVersionPolicyu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ResourceVersionPolicyu45list] = Seq(Nou45version, Versioned, Versionedu45update)
}

case object Nou45version extends ResourceVersionPolicyu45list { override def toString = "no-version" }
case object Versioned extends ResourceVersionPolicyu45list { override def toString = "versioned" }
case object Versionedu45update extends ResourceVersionPolicyu45list { override def toString = "versioned-update" }


/** How the system supports versioning for a resource.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ResourceVersionPolicy(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ResourceVersionPolicyu45list]}
}

      

sealed trait MessageSignificanceCategoryu45list

object MessageSignificanceCategoryu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[MessageSignificanceCategoryu45list]): MessageSignificanceCategoryu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MessageSignificanceCategoryu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[MessageSignificanceCategoryu45list] = Seq(Consequence, Currency, Notification)
}

case object Consequence extends MessageSignificanceCategoryu45list { override def toString = "Consequence" }
case object Currency extends MessageSignificanceCategoryu45list { override def toString = "Currency" }
case object Notification extends MessageSignificanceCategoryu45list { override def toString = "Notification" }


/** The impact of the content of a message.If the element is present, it must have either a @value, an @id, or extensions
*/
case class MessageSignificanceCategory(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[MessageSignificanceCategoryu45list]}
}

      

sealed trait DocumentModeu45list

object DocumentModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[DocumentModeu45list]): DocumentModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DocumentModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DocumentModeu45list] = Seq(Producer, Consumer)
}

case object Producer extends DocumentModeu45list { override def toString = "producer" }
case object Consumer extends DocumentModeu45list { override def toString = "consumer" }


/** Whether the application produces or consumes documents.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DocumentMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[DocumentModeu45list]}
}

      

sealed trait RestfulCapabilityModeu45list

object RestfulCapabilityModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[RestfulCapabilityModeu45list]): RestfulCapabilityModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RestfulCapabilityModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[RestfulCapabilityModeu45list] = Seq(Client, Server)
}

case object Client extends RestfulCapabilityModeu45list { override def toString = "client" }
case object Server extends RestfulCapabilityModeu45list { override def toString = "server" }


/** The mode of a RESTful capability statement.If the element is present, it must have either a @value, an @id, or extensions
*/
case class RestfulCapabilityMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[RestfulCapabilityModeu45list]}
}

      

sealed trait UnknownContentCodeu45list

object UnknownContentCodeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[UnknownContentCodeu45list]): UnknownContentCodeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: UnknownContentCodeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[UnknownContentCodeu45list] = Seq(No, Extensions, Elements, Both)
}

case object No extends UnknownContentCodeu45list { override def toString = "no" }
case object Extensions extends UnknownContentCodeu45list { override def toString = "extensions" }
case object Elements extends UnknownContentCodeu45list { override def toString = "elements" }
case object Both extends UnknownContentCodeu45list { override def toString = "both" }


/** A code that indicates whether an application accepts unknown elements or extensions when reading resources.If the element is present, it must have either a @value, an @id, or extensions
*/
case class UnknownContentCode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[UnknownContentCodeu45list]}
}

      

sealed trait TypeRestfulInteractionu45list

object TypeRestfulInteractionu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[TypeRestfulInteractionu45list]): TypeRestfulInteractionu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TypeRestfulInteractionu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[TypeRestfulInteractionu45list] = Seq(Read, Vread, Update, PatchValue, DeleteValue, Historyu45instance, Historyu45type, CreateValue, Searchu45type)
}

case object Read extends TypeRestfulInteractionu45list { override def toString = "read" }
case object Vread extends TypeRestfulInteractionu45list { override def toString = "vread" }
case object Update extends TypeRestfulInteractionu45list { override def toString = "update" }
case object PatchValue extends TypeRestfulInteractionu45list { override def toString = "patch" }
case object DeleteValue extends TypeRestfulInteractionu45list { override def toString = "delete" }
case object Historyu45instance extends TypeRestfulInteractionu45list { override def toString = "history-instance" }
case object Historyu45type extends TypeRestfulInteractionu45list { override def toString = "history-type" }
case object CreateValue extends TypeRestfulInteractionu45list { override def toString = "create" }
case object Searchu45type extends TypeRestfulInteractionu45list { override def toString = "search-type" }


/** Operations supported by REST at the type or instance level.If the element is present, it must have either a @value, an @id, or extensions
*/
case class TypeRestfulInteraction(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[TypeRestfulInteractionu45list]}
}

      

sealed trait SystemRestfulInteractionu45list

object SystemRestfulInteractionu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[SystemRestfulInteractionu45list]): SystemRestfulInteractionu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SystemRestfulInteractionu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SystemRestfulInteractionu45list] = Seq(Transaction, Batch, Searchu45system, Historyu45system)
}

case object Transaction extends SystemRestfulInteractionu45list { override def toString = "transaction" }
case object Batch extends SystemRestfulInteractionu45list { override def toString = "batch" }
case object Searchu45system extends SystemRestfulInteractionu45list { override def toString = "search-system" }
case object Historyu45system extends SystemRestfulInteractionu45list { override def toString = "history-system" }


/** Operations supported by REST at the system level.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SystemRestfulInteraction(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[SystemRestfulInteractionu45list]}
}

      

sealed trait ConditionalReadStatusu45list

object ConditionalReadStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ConditionalReadStatusu45list]): ConditionalReadStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ConditionalReadStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ConditionalReadStatusu45list] = Seq(Notu45supportedValue2, Modifiedu45since, Notu45match, Fullu45support)
}

case object Notu45supportedValue2 extends ConditionalReadStatusu45list { override def toString = "not-supported" }
case object Modifiedu45since extends ConditionalReadStatusu45list { override def toString = "modified-since" }
case object Notu45match extends ConditionalReadStatusu45list { override def toString = "not-match" }
case object Fullu45support extends ConditionalReadStatusu45list { override def toString = "full-support" }


/** A code that indicates how the server supports conditional read.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ConditionalReadStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ConditionalReadStatusu45list]}
}

      

sealed trait ReferenceHandlingPolicyu45list

object ReferenceHandlingPolicyu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ReferenceHandlingPolicyu45list]): ReferenceHandlingPolicyu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ReferenceHandlingPolicyu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ReferenceHandlingPolicyu45list] = Seq(Literal, Logical, Resolves, Enforced, Local)
}

case object Literal extends ReferenceHandlingPolicyu45list { override def toString = "literal" }
case object Logical extends ReferenceHandlingPolicyu45list { override def toString = "logical" }
case object Resolves extends ReferenceHandlingPolicyu45list { override def toString = "resolves" }
case object Enforced extends ReferenceHandlingPolicyu45list { override def toString = "enforced" }
case object Local extends ReferenceHandlingPolicyu45list { override def toString = "local" }


/** A set of flags that defines how references are supported.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ReferenceHandlingPolicy(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ReferenceHandlingPolicyu45list]}
}

      

sealed trait ConditionalDeleteStatusu45list

object ConditionalDeleteStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ConditionalDeleteStatusu45list]): ConditionalDeleteStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ConditionalDeleteStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ConditionalDeleteStatusu45list] = Seq(Notu45supportedValue, Single, Multiple)
}

case object Notu45supportedValue extends ConditionalDeleteStatusu45list { override def toString = "not-supported" }
case object Single extends ConditionalDeleteStatusu45list { override def toString = "single" }
case object Multiple extends ConditionalDeleteStatusu45list { override def toString = "multiple" }


/** A code that indicates how the server supports conditional delete.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ConditionalDeleteStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ConditionalDeleteStatusu45list]}
}

      


/** Describes the intention of how one or more practitioners intend to deliver care for a particular patient, group or community for a period of time, possibly limited to care for a specific condition or set of conditions.If the element is present, it must have either a @value, an @id, or extensions
*/
case class CarePlanType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  definition: Seq[ReferenceType] = Nil,
  basedOn: Seq[ReferenceType] = Nil,
  replaces: Seq[ReferenceType] = Nil,
  partOf: Seq[ReferenceType] = Nil,
  status: CarePlanStatus,
  intent: CarePlanIntent,
  category: Seq[CodeableConceptType] = Nil,
  title: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  subject: ReferenceType,
  context: Option[ReferenceType] = None,
  period: Option[PeriodType] = None,
  author: Seq[ReferenceType] = Nil,
  careTeam: Seq[ReferenceType] = Nil,
  addresses: Seq[ReferenceType] = Nil,
  supportingInfo: Seq[ReferenceType] = Nil,
  goal: Seq[ReferenceType] = Nil,
  activity: Seq[CarePlanu46Activity] = Nil,
  note: Seq[AnnotationType] = Nil) extends DomainResourcable
      


/** Describes the intention of how one or more practitioners intend to deliver care for a particular patient, group or community for a period of time, possibly limited to care for a specific condition or set of conditions.
*/
case class CarePlanu46Activity(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  outcomeCodeableConcept: Seq[CodeableConceptType] = Nil,
  outcomeReference: Seq[ReferenceType] = Nil,
  progress: Seq[AnnotationType] = Nil,
  reference: Option[ReferenceType] = None,
  detail: Option[CarePlanu46Detail] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Describes the intention of how one or more practitioners intend to deliver care for a particular patient, group or community for a period of time, possibly limited to care for a specific condition or set of conditions.
*/
case class CarePlanu46Detail(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  category: Option[CodeableConceptType] = None,
  definition: Option[ReferenceType] = None,
  code: Option[CodeableConceptType] = None,
  reasonCode: Seq[CodeableConceptType] = Nil,
  reasonReference: Seq[ReferenceType] = Nil,
  goal: Seq[ReferenceType] = Nil,
  status: CarePlanActivityStatus,
  statusReason: Option[StringTypeType] = None,
  prohibited: Option[BooleanTypeType] = None,
  scheduledTiming: Option[TimingType] = None,
  scheduledPeriod: Option[PeriodType] = None,
  scheduledString: Option[StringTypeType] = None,
  location: Option[ReferenceType] = None,
  performer: Seq[ReferenceType] = Nil,
  productCodeableConcept: Option[CodeableConceptType] = None,
  productReference: Option[ReferenceType] = None,
  dailyAmount: Option[Quantityable] = None,
  quantity: Option[Quantityable] = None,
  description: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait CarePlanStatusu45list

object CarePlanStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[CarePlanStatusu45list]): CarePlanStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CarePlanStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[CarePlanStatusu45list] = Seq(DraftValue5, ActiveValue14, SuspendedValue4, CompletedValue8, Enteredu45inu45errorValue18, CancelledValue7, UnknownValue8)
}

case object DraftValue5 extends CarePlanStatusu45list { override def toString = "draft" }
case object ActiveValue14 extends CarePlanStatusu45list { override def toString = "active" }
case object SuspendedValue4 extends CarePlanStatusu45list { override def toString = "suspended" }
case object CompletedValue8 extends CarePlanStatusu45list { override def toString = "completed" }
case object Enteredu45inu45errorValue18 extends CarePlanStatusu45list { override def toString = "entered-in-error" }
case object CancelledValue7 extends CarePlanStatusu45list { override def toString = "cancelled" }
case object UnknownValue8 extends CarePlanStatusu45list { override def toString = "unknown" }


/** Indicates whether the plan is currently being acted upon, represents future intentions or is now a historical record.If the element is present, it must have either a @value, an @id, or extensions
*/
case class CarePlanStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[CarePlanStatusu45list]}
}

      

sealed trait CarePlanActivityStatusu45list

object CarePlanActivityStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[CarePlanActivityStatusu45list]): CarePlanActivityStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CarePlanActivityStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[CarePlanActivityStatusu45list] = Seq(Notu45started, Scheduled, Inu45progressValue5, Onu45holdValue5, CompletedValue9, CancelledValue8, UnknownValue9)
}

case object Notu45started extends CarePlanActivityStatusu45list { override def toString = "not-started" }
case object Scheduled extends CarePlanActivityStatusu45list { override def toString = "scheduled" }
case object Inu45progressValue5 extends CarePlanActivityStatusu45list { override def toString = "in-progress" }
case object Onu45holdValue5 extends CarePlanActivityStatusu45list { override def toString = "on-hold" }
case object CompletedValue9 extends CarePlanActivityStatusu45list { override def toString = "completed" }
case object CancelledValue8 extends CarePlanActivityStatusu45list { override def toString = "cancelled" }
case object UnknownValue9 extends CarePlanActivityStatusu45list { override def toString = "unknown" }


/** Indicates where the activity is at in its overall life cycle.If the element is present, it must have either a @value, an @id, or extensions
*/
case class CarePlanActivityStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[CarePlanActivityStatusu45list]}
}

      

sealed trait CarePlanIntentu45list

object CarePlanIntentu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[CarePlanIntentu45list]): CarePlanIntentu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CarePlanIntentu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[CarePlanIntentu45list] = Seq(Proposal, Plan, Order, OptionType)
}

case object Proposal extends CarePlanIntentu45list { override def toString = "proposal" }
case object Plan extends CarePlanIntentu45list { override def toString = "plan" }
case object Order extends CarePlanIntentu45list { override def toString = "order" }
case object OptionType extends CarePlanIntentu45list { override def toString = "option" }


/** Codes indicating the degree of authority/intentionality associated with a care planIf the element is present, it must have either a @value, an @id, or extensions
*/
case class CarePlanIntent(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[CarePlanIntentu45list]}
}

      


/** The Care Team includes all the people and organizations who plan to participate in the coordination and delivery of care for a patient.If the element is present, it must have either a @value, an @id, or extensions
*/
case class CareTeamType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[CareTeamStatus] = None,
  category: Seq[CodeableConceptType] = Nil,
  name: Option[StringTypeType] = None,
  subject: Option[ReferenceType] = None,
  context: Option[ReferenceType] = None,
  period: Option[PeriodType] = None,
  participant: Seq[CareTeamu46Participant] = Nil,
  reasonCode: Seq[CodeableConceptType] = Nil,
  reasonReference: Seq[ReferenceType] = Nil,
  managingOrganization: Seq[ReferenceType] = Nil,
  note: Seq[AnnotationType] = Nil) extends DomainResourcable
      


/** The Care Team includes all the people and organizations who plan to participate in the coordination and delivery of care for a patient.
*/
case class CareTeamu46Participant(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  role: Option[CodeableConceptType] = None,
  member: Option[ReferenceType] = None,
  onBehalfOf: Option[ReferenceType] = None,
  period: Option[PeriodType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait CareTeamStatusu45list

object CareTeamStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[CareTeamStatusu45list]): CareTeamStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CareTeamStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[CareTeamStatusu45list] = Seq(ProposedValue3, ActiveValue15, SuspendedValue5, InactiveValue5, Enteredu45inu45errorValue19)
}

case object ProposedValue3 extends CareTeamStatusu45list { override def toString = "proposed" }
case object ActiveValue15 extends CareTeamStatusu45list { override def toString = "active" }
case object SuspendedValue5 extends CareTeamStatusu45list { override def toString = "suspended" }
case object InactiveValue5 extends CareTeamStatusu45list { override def toString = "inactive" }
case object Enteredu45inu45errorValue19 extends CareTeamStatusu45list { override def toString = "entered-in-error" }


/** Indicates the status of the care team.If the element is present, it must have either a @value, an @id, or extensions
*/
case class CareTeamStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[CareTeamStatusu45list]}
}

      


/** The resource ChargeItem describes the provision of healthcare provider products for a certain patient, therefore referring not only to the product, but containing in addition details of the provision, like date, time, amounts and participating organizations and persons. Main Usage of the ChargeItem is to enable the billing process and internal cost allocation.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ChargeItemType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  definition: Seq[UriType] = Nil,
  status: ChargeItemStatus,
  partOf: Seq[ReferenceType] = Nil,
  code: CodeableConceptType,
  subject: ReferenceType,
  context: Option[ReferenceType] = None,
  occurrenceDateTime: Option[DateTimeType] = None,
  occurrencePeriod: Option[PeriodType] = None,
  occurrenceTiming: Option[TimingType] = None,
  participant: Seq[ChargeItemu46Participant] = Nil,
  performingOrganization: Option[ReferenceType] = None,
  requestingOrganization: Option[ReferenceType] = None,
  quantity: Option[Quantityable] = None,
  bodysite: Seq[CodeableConceptType] = Nil,
  factorOverride: Option[DecimalType] = None,
  priceOverride: Option[MoneyType] = None,
  overrideReason: Option[StringTypeType] = None,
  enterer: Option[ReferenceType] = None,
  enteredDate: Option[DateTimeType] = None,
  reason: Seq[CodeableConceptType] = Nil,
  service: Seq[ReferenceType] = Nil,
  account: Seq[ReferenceType] = Nil,
  note: Seq[AnnotationType] = Nil,
  supportingInformation: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** The resource ChargeItem describes the provision of healthcare provider products for a certain patient, therefore referring not only to the product, but containing in addition details of the provision, like date, time, amounts and participating organizations and persons. Main Usage of the ChargeItem is to enable the billing process and internal cost allocation.
*/
case class ChargeItemu46Participant(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  role: Option[CodeableConceptType] = None,
  actor: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ChargeItemStatusu45list

object ChargeItemStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ChargeItemStatusu45list]): ChargeItemStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ChargeItemStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ChargeItemStatusu45list] = Seq(PlannedValue5, Billable, Notu45billable, Aborted, Billed, Enteredu45inu45errorValue20, UnknownValue10)
}

case object PlannedValue5 extends ChargeItemStatusu45list { override def toString = "planned" }
case object Billable extends ChargeItemStatusu45list { override def toString = "billable" }
case object Notu45billable extends ChargeItemStatusu45list { override def toString = "not-billable" }
case object Aborted extends ChargeItemStatusu45list { override def toString = "aborted" }
case object Billed extends ChargeItemStatusu45list { override def toString = "billed" }
case object Enteredu45inu45errorValue20 extends ChargeItemStatusu45list { override def toString = "entered-in-error" }
case object UnknownValue10 extends ChargeItemStatusu45list { override def toString = "unknown" }


/** Codes identifying the stage lifecycle stage of a ChargeItemIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ChargeItemStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ChargeItemStatusu45list]}
}

      


/** A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ClaimType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[FinancialResourceStatusCodes] = None,
  typeValue: Option[CodeableConceptType] = None,
  subType: Seq[CodeableConceptType] = Nil,
  use: Option[Use] = None,
  patient: Option[ReferenceType] = None,
  billablePeriod: Option[PeriodType] = None,
  created: Option[DateTimeType] = None,
  enterer: Option[ReferenceType] = None,
  insurer: Option[ReferenceType] = None,
  provider: Option[ReferenceType] = None,
  organization: Option[ReferenceType] = None,
  priority: Option[CodeableConceptType] = None,
  fundsReserve: Option[CodeableConceptType] = None,
  related: Seq[Claimu46Related] = Nil,
  prescription: Option[ReferenceType] = None,
  originalPrescription: Option[ReferenceType] = None,
  payee: Option[Claimu46Payee] = None,
  referral: Option[ReferenceType] = None,
  facility: Option[ReferenceType] = None,
  careTeam: Seq[Claimu46CareTeam] = Nil,
  information: Seq[Claimu46Information] = Nil,
  diagnosis: Seq[Claimu46Diagnosis] = Nil,
  procedure: Seq[Claimu46Procedure] = Nil,
  insurance: Seq[Claimu46Insurance] = Nil,
  accident: Option[Claimu46Accident] = None,
  employmentImpacted: Option[PeriodType] = None,
  hospitalization: Option[PeriodType] = None,
  item: Seq[Claimu46Item] = Nil,
  total: Option[MoneyType] = None) extends DomainResourcable
      


/** A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.
*/
case class Claimu46Related(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  claim: Option[ReferenceType] = None,
  relationship: Option[CodeableConceptType] = None,
  reference: Option[IdentifierType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.
*/
case class Claimu46Payee(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: CodeableConceptType,
  resourceType: Option[CodingType] = None,
  party: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.
*/
case class Claimu46CareTeam(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  provider: ReferenceType,
  responsible: Option[BooleanTypeType] = None,
  role: Option[CodeableConceptType] = None,
  qualification: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.
*/
case class Claimu46Information(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  category: CodeableConceptType,
  code: Option[CodeableConceptType] = None,
  timingDate: Option[DateType] = None,
  timingPeriod: Option[PeriodType] = None,
  valueString: Option[StringTypeType] = None,
  valueQuantity: Option[Quantityable] = None,
  valueAttachment: Option[AttachmentType] = None,
  valueReference: Option[ReferenceType] = None,
  reason: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.
*/
case class Claimu46Diagnosis(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  diagnosisCodeableConcept: Option[CodeableConceptType] = None,
  diagnosisReference: Option[ReferenceType] = None,
  typeValue: Seq[CodeableConceptType] = Nil,
  packageCode: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.
*/
case class Claimu46Procedure(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  date: Option[DateTimeType] = None,
  procedureCodeableConcept: Option[CodeableConceptType] = None,
  procedureReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.
*/
case class Claimu46Insurance(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  focal: BooleanTypeType,
  coverage: ReferenceType,
  businessArrangement: Option[StringTypeType] = None,
  preAuthRef: Seq[StringTypeType] = Nil,
  claimResponse: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.
*/
case class Claimu46Accident(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  date: DateType,
  typeValue: Option[CodeableConceptType] = None,
  locationAddress: Option[AddressType2] = None,
  locationReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.
*/
case class Claimu46Item(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  careTeamLinkId: Seq[PositiveIntType] = Nil,
  diagnosisLinkId: Seq[PositiveIntType] = Nil,
  procedureLinkId: Seq[PositiveIntType] = Nil,
  informationLinkId: Seq[PositiveIntType] = Nil,
  revenue: Option[CodeableConceptType] = None,
  category: Option[CodeableConceptType] = None,
  service: Option[CodeableConceptType] = None,
  modifier: Seq[CodeableConceptType] = Nil,
  programCode: Seq[CodeableConceptType] = Nil,
  servicedDate: Option[DateType] = None,
  servicedPeriod: Option[PeriodType] = None,
  locationCodeableConcept: Option[CodeableConceptType] = None,
  locationAddress: Option[AddressType2] = None,
  locationReference: Option[ReferenceType] = None,
  quantity: Option[Quantityable] = None,
  unitPrice: Option[MoneyType] = None,
  factor: Option[DecimalType] = None,
  net: Option[MoneyType] = None,
  udi: Seq[ReferenceType] = Nil,
  bodySite: Option[CodeableConceptType] = None,
  subSite: Seq[CodeableConceptType] = Nil,
  encounter: Seq[ReferenceType] = Nil,
  detail: Seq[Claimu46Detail] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.
*/
case class Claimu46Detail(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  revenue: Option[CodeableConceptType] = None,
  category: Option[CodeableConceptType] = None,
  service: Option[CodeableConceptType] = None,
  modifier: Seq[CodeableConceptType] = Nil,
  programCode: Seq[CodeableConceptType] = Nil,
  quantity: Option[Quantityable] = None,
  unitPrice: Option[MoneyType] = None,
  factor: Option[DecimalType] = None,
  net: Option[MoneyType] = None,
  udi: Seq[ReferenceType] = Nil,
  subDetail: Seq[Claimu46SubDetail] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.
*/
case class Claimu46SubDetail(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  revenue: Option[CodeableConceptType] = None,
  category: Option[CodeableConceptType] = None,
  service: Option[CodeableConceptType] = None,
  modifier: Seq[CodeableConceptType] = Nil,
  programCode: Seq[CodeableConceptType] = Nil,
  quantity: Option[Quantityable] = None,
  unitPrice: Option[MoneyType] = None,
  factor: Option[DecimalType] = None,
  net: Option[MoneyType] = None,
  udi: Seq[ReferenceType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait Useu45list

object Useu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[Useu45list]): Useu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Useu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Useu45list] = Seq(CompleteValue, ProposedValue4, Exploratory, OtherValue3)
}

case object CompleteValue extends Useu45list { override def toString = "complete" }
case object ProposedValue4 extends Useu45list { override def toString = "proposed" }
case object Exploratory extends Useu45list { override def toString = "exploratory" }
case object OtherValue3 extends Useu45list { override def toString = "other" }


/** Complete, proposed, exploratory, otherIf the element is present, it must have either a @value, an @id, or extensions
*/
case class Use(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[Useu45list]}
}

      

sealed trait FinancialResourceStatusCodesu45list

object FinancialResourceStatusCodesu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[FinancialResourceStatusCodesu45list]): FinancialResourceStatusCodesu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: FinancialResourceStatusCodesu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[FinancialResourceStatusCodesu45list] = Seq(ActiveValue16, CancelledValue9, DraftValue6, Enteredu45inu45errorValue21)
}

case object ActiveValue16 extends FinancialResourceStatusCodesu45list { override def toString = "active" }
case object CancelledValue9 extends FinancialResourceStatusCodesu45list { override def toString = "cancelled" }
case object DraftValue6 extends FinancialResourceStatusCodesu45list { override def toString = "draft" }
case object Enteredu45inu45errorValue21 extends FinancialResourceStatusCodesu45list { override def toString = "entered-in-error" }


/** A code specifying the state of the resource instance.If the element is present, it must have either a @value, an @id, or extensions
*/
case class FinancialResourceStatusCodes(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[FinancialResourceStatusCodesu45list]}
}

      


/** This resource provides the adjudication details from the processing of a Claim resource.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ClaimResponseType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[FinancialResourceStatusCodes] = None,
  patient: Option[ReferenceType] = None,
  created: Option[DateTimeType] = None,
  insurer: Option[ReferenceType] = None,
  requestProvider: Option[ReferenceType] = None,
  requestOrganization: Option[ReferenceType] = None,
  request: Option[ReferenceType] = None,
  outcome: Option[CodeableConceptType] = None,
  disposition: Option[StringTypeType] = None,
  payeeType: Option[CodeableConceptType] = None,
  item: Seq[ClaimResponseu46Item] = Nil,
  addItem: Seq[ClaimResponseu46AddItem] = Nil,
  error: Seq[ClaimResponseu46Error] = Nil,
  totalCost: Option[MoneyType] = None,
  unallocDeductable: Option[MoneyType] = None,
  totalBenefit: Option[MoneyType] = None,
  payment: Option[ClaimResponseu46Payment] = None,
  reserved: Option[CodingType] = None,
  form: Option[CodeableConceptType] = None,
  processNote: Seq[ClaimResponseu46ProcessNote] = Nil,
  communicationRequest: Seq[ReferenceType] = Nil,
  insurance: Seq[ClaimResponseu46Insurance] = Nil) extends DomainResourcable
      


/** This resource provides the adjudication details from the processing of a Claim resource.
*/
case class ClaimResponseu46Item(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequenceLinkId: PositiveIntType,
  noteNumber: Seq[PositiveIntType] = Nil,
  adjudication: Seq[ClaimResponseu46Adjudication] = Nil,
  detail: Seq[ClaimResponseu46Detail] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides the adjudication details from the processing of a Claim resource.
*/
case class ClaimResponseu46Adjudication(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  category: CodeableConceptType,
  reason: Option[CodeableConceptType] = None,
  amount: Option[MoneyType] = None,
  value: Option[DecimalType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides the adjudication details from the processing of a Claim resource.
*/
case class ClaimResponseu46Detail(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequenceLinkId: PositiveIntType,
  noteNumber: Seq[PositiveIntType] = Nil,
  adjudication: Seq[ClaimResponseu46Adjudication] = Nil,
  subDetail: Seq[ClaimResponseu46SubDetail] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides the adjudication details from the processing of a Claim resource.
*/
case class ClaimResponseu46SubDetail(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequenceLinkId: PositiveIntType,
  noteNumber: Seq[PositiveIntType] = Nil,
  adjudication: Seq[ClaimResponseu46Adjudication] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides the adjudication details from the processing of a Claim resource.
*/
case class ClaimResponseu46AddItem(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequenceLinkId: Seq[PositiveIntType] = Nil,
  revenue: Option[CodeableConceptType] = None,
  category: Option[CodeableConceptType] = None,
  service: Option[CodeableConceptType] = None,
  modifier: Seq[CodeableConceptType] = Nil,
  fee: Option[MoneyType] = None,
  noteNumber: Seq[PositiveIntType] = Nil,
  adjudication: Seq[ClaimResponseu46Adjudication] = Nil,
  detail: Seq[ClaimResponseu46Detail1] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides the adjudication details from the processing of a Claim resource.
*/
case class ClaimResponseu46Detail1(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  revenue: Option[CodeableConceptType] = None,
  category: Option[CodeableConceptType] = None,
  service: Option[CodeableConceptType] = None,
  modifier: Seq[CodeableConceptType] = Nil,
  fee: Option[MoneyType] = None,
  noteNumber: Seq[PositiveIntType] = Nil,
  adjudication: Seq[ClaimResponseu46Adjudication] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides the adjudication details from the processing of a Claim resource.
*/
case class ClaimResponseu46Error(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequenceLinkId: Option[PositiveIntType] = None,
  detailSequenceLinkId: Option[PositiveIntType] = None,
  subdetailSequenceLinkId: Option[PositiveIntType] = None,
  code: CodeableConceptType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides the adjudication details from the processing of a Claim resource.
*/
case class ClaimResponseu46Payment(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: Option[CodeableConceptType] = None,
  adjustment: Option[MoneyType] = None,
  adjustmentReason: Option[CodeableConceptType] = None,
  date: Option[DateType] = None,
  amount: Option[MoneyType] = None,
  identifier: Option[IdentifierType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides the adjudication details from the processing of a Claim resource.
*/
case class ClaimResponseu46ProcessNote(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  number: Option[PositiveIntType] = None,
  typeValue: Option[CodeableConceptType] = None,
  text: Option[StringTypeType] = None,
  language: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides the adjudication details from the processing of a Claim resource.
*/
case class ClaimResponseu46Insurance(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  focal: BooleanTypeType,
  coverage: ReferenceType,
  businessArrangement: Option[StringTypeType] = None,
  preAuthRef: Seq[StringTypeType] = Nil,
  claimResponse: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A record of a clinical assessment performed to determine what problem(s) may affect the patient and before planning the treatments or management strategies that are best to manage a patient's condition. Assessments are often 1:1 with a clinical consultation / encounter,  but this varies greatly depending on the clinical workflow. This resource is called "ClinicalImpression" rather than "ClinicalAssessment" to avoid confusion with the recording of assessment tools such as Apgar score.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ClinicalImpressionType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: ClinicalImpressionStatus,
  code: Option[CodeableConceptType] = None,
  description: Option[StringTypeType] = None,
  subject: ReferenceType,
  context: Option[ReferenceType] = None,
  effectiveDateTime: Option[DateTimeType] = None,
  effectivePeriod: Option[PeriodType] = None,
  date: Option[DateTimeType] = None,
  assessor: Option[ReferenceType] = None,
  previous: Option[ReferenceType] = None,
  problem: Seq[ReferenceType] = Nil,
  investigation: Seq[ClinicalImpressionu46Investigation] = Nil,
  protocol: Seq[UriType] = Nil,
  summary: Option[StringTypeType] = None,
  finding: Seq[ClinicalImpressionu46Finding] = Nil,
  prognosisCodeableConcept: Seq[CodeableConceptType] = Nil,
  prognosisReference: Seq[ReferenceType] = Nil,
  action: Seq[ReferenceType] = Nil,
  note: Seq[AnnotationType] = Nil) extends DomainResourcable
      


/** A record of a clinical assessment performed to determine what problem(s) may affect the patient and before planning the treatments or management strategies that are best to manage a patient's condition. Assessments are often 1:1 with a clinical consultation / encounter,  but this varies greatly depending on the clinical workflow. This resource is called "ClinicalImpression" rather than "ClinicalAssessment" to avoid confusion with the recording of assessment tools such as Apgar score.
*/
case class ClinicalImpressionu46Investigation(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: CodeableConceptType,
  item: Seq[ReferenceType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A record of a clinical assessment performed to determine what problem(s) may affect the patient and before planning the treatments or management strategies that are best to manage a patient's condition. Assessments are often 1:1 with a clinical consultation / encounter,  but this varies greatly depending on the clinical workflow. This resource is called "ClinicalImpression" rather than "ClinicalAssessment" to avoid confusion with the recording of assessment tools such as Apgar score.
*/
case class ClinicalImpressionu46Finding(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  itemCodeableConcept: Option[CodeableConceptType] = None,
  itemReference: Option[ReferenceType] = None,
  basis: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ClinicalImpressionStatusu45list

object ClinicalImpressionStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ClinicalImpressionStatusu45list]): ClinicalImpressionStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ClinicalImpressionStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ClinicalImpressionStatusu45list] = Seq(DraftValue7, CompletedValue10, Enteredu45inu45errorValue22)
}

case object DraftValue7 extends ClinicalImpressionStatusu45list { override def toString = "draft" }
case object CompletedValue10 extends ClinicalImpressionStatusu45list { override def toString = "completed" }
case object Enteredu45inu45errorValue22 extends ClinicalImpressionStatusu45list { override def toString = "entered-in-error" }


/** The workflow state of a clinical impression.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ClinicalImpressionStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ClinicalImpressionStatusu45list]}
}

      


/** A code system resource specifies a set of codes drawn from one or more code systems.If the element is present, it must have either a @value, an @id, or extensions
*/
case class CodeSystemType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: Option[UriType] = None,
  identifier: Option[IdentifierType] = None,
  version: Option[StringTypeType] = None,
  name: Option[StringTypeType] = None,
  title: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  description: Option[MarkdownType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  purpose: Option[MarkdownType] = None,
  copyright: Option[MarkdownType] = None,
  caseSensitive: Option[BooleanTypeType] = None,
  valueSet: Option[UriType] = None,
  hierarchyMeaning: Option[CodeSystemHierarchyMeaning] = None,
  compositional: Option[BooleanTypeType] = None,
  versionNeeded: Option[BooleanTypeType] = None,
  content: CodeSystemContentMode,
  count: Option[UnsignedIntType] = None,
  filter: Seq[CodeSystemu46Filter] = Nil,
  property: Seq[CodeSystemu46Property] = Nil,
  concept: Seq[CodeSystemu46Concept] = Nil) extends DomainResourcable
      


/** A code system resource specifies a set of codes drawn from one or more code systems.
*/
case class CodeSystemu46Filter(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: CodeType,
  description: Option[StringTypeType] = None,
  operator: Seq[FilterOperator] = Nil,
  value: StringTypeType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A code system resource specifies a set of codes drawn from one or more code systems.
*/
case class CodeSystemu46Property(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: CodeType,
  uri: Option[UriType] = None,
  description: Option[StringTypeType] = None,
  typeValue: PropertyType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A code system resource specifies a set of codes drawn from one or more code systems.
*/
case class CodeSystemu46Concept(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: CodeType,
  display: Option[StringTypeType] = None,
  definition: Option[StringTypeType] = None,
  designation: Seq[CodeSystemu46Designation] = Nil,
  property: Seq[CodeSystemu46Property1] = Nil,
  concept: Seq[CodeSystemu46Concept] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A code system resource specifies a set of codes drawn from one or more code systems.
*/
case class CodeSystemu46Designation(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  language: Option[CodeType] = None,
  use: Option[CodingType] = None,
  value: StringTypeType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A code system resource specifies a set of codes drawn from one or more code systems.
*/
case class CodeSystemu46Property1(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: CodeType,
  valueCode: Option[CodeType] = None,
  valueCoding: Option[CodingType] = None,
  valueString: Option[StringTypeType] = None,
  valueInteger: Option[IntegerType] = None,
  valueBoolean: Option[BooleanTypeType] = None,
  valueDateTime: Option[DateTimeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait FilterOperatoru45list

object FilterOperatoru45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[FilterOperatoru45list]): FilterOperatoru45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: FilterOperatoru45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[FilterOperatoru45list] = Seq(U61, Isu45a, Descendentu45of, Isu45notu45a, Regex, InValue3, Notu45inValue, Generalizes, ExistsValue)
}

case object U61 extends FilterOperatoru45list { override def toString = "=" }
case object Isu45a extends FilterOperatoru45list { override def toString = "is-a" }
case object Descendentu45of extends FilterOperatoru45list { override def toString = "descendent-of" }
case object Isu45notu45a extends FilterOperatoru45list { override def toString = "is-not-a" }
case object Regex extends FilterOperatoru45list { override def toString = "regex" }
case object InValue3 extends FilterOperatoru45list { override def toString = "in" }
case object Notu45inValue extends FilterOperatoru45list { override def toString = "not-in" }
case object Generalizes extends FilterOperatoru45list { override def toString = "generalizes" }
case object ExistsValue extends FilterOperatoru45list { override def toString = "exists" }


/** The kind of operation to perform as a part of a property based filter.If the element is present, it must have either a @value, an @id, or extensions
*/
case class FilterOperator(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[FilterOperatoru45list]}
}

      

sealed trait PropertyTypeu45list

object PropertyTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[PropertyTypeu45list]): PropertyTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PropertyTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[PropertyTypeu45list] = Seq(CodeValue2, CodingValue2, StringTypeValue4, IntegerValue3, BooleanTypeValue3, DateTimeValue3)
}

case object CodeValue2 extends PropertyTypeu45list { override def toString = "code" }
case object CodingValue2 extends PropertyTypeu45list { override def toString = "Coding" }
case object StringTypeValue4 extends PropertyTypeu45list { override def toString = "string" }
case object IntegerValue3 extends PropertyTypeu45list { override def toString = "integer" }
case object BooleanTypeValue3 extends PropertyTypeu45list { override def toString = "boolean" }
case object DateTimeValue3 extends PropertyTypeu45list { override def toString = "dateTime" }


/** The type of a property valueIf the element is present, it must have either a @value, an @id, or extensions
*/
case class PropertyType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[PropertyTypeu45list]}
}

      

sealed trait CodeSystemHierarchyMeaningu45list

object CodeSystemHierarchyMeaningu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[CodeSystemHierarchyMeaningu45list]): CodeSystemHierarchyMeaningu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CodeSystemHierarchyMeaningu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[CodeSystemHierarchyMeaningu45list] = Seq(Groupedu45by, Isu45aValue, Partu45of, Classifiedu45with)
}

case object Groupedu45by extends CodeSystemHierarchyMeaningu45list { override def toString = "grouped-by" }
case object Isu45aValue extends CodeSystemHierarchyMeaningu45list { override def toString = "is-a" }
case object Partu45of extends CodeSystemHierarchyMeaningu45list { override def toString = "part-of" }
case object Classifiedu45with extends CodeSystemHierarchyMeaningu45list { override def toString = "classified-with" }


/** The meaning of the hierarchy of concepts in a code systemIf the element is present, it must have either a @value, an @id, or extensions
*/
case class CodeSystemHierarchyMeaning(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[CodeSystemHierarchyMeaningu45list]}
}

      

sealed trait CodeSystemContentModeu45list

object CodeSystemContentModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[CodeSystemContentModeu45list]): CodeSystemContentModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CodeSystemContentModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[CodeSystemContentModeu45list] = Seq(Notu45present, ExampleValue, Fragment, CompleteValue2)
}

case object Notu45present extends CodeSystemContentModeu45list { override def toString = "not-present" }
case object ExampleValue extends CodeSystemContentModeu45list { override def toString = "example" }
case object Fragment extends CodeSystemContentModeu45list { override def toString = "fragment" }
case object CompleteValue2 extends CodeSystemContentModeu45list { override def toString = "complete" }


/** How much of the content of the code system - the concepts and codes it defines - are represented in a code system resourceIf the element is present, it must have either a @value, an @id, or extensions
*/
case class CodeSystemContentMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[CodeSystemContentModeu45list]}
}

      


/** An occurrence of information being transmitted; e.g. an alert that was sent to a responsible provider, a public health agency was notified about a reportable condition.If the element is present, it must have either a @value, an @id, or extensions
*/
case class CommunicationType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  definition: Seq[ReferenceType] = Nil,
  basedOn: Seq[ReferenceType] = Nil,
  partOf: Seq[ReferenceType] = Nil,
  status: EventStatus,
  notDone: Option[BooleanTypeType] = None,
  notDoneReason: Option[CodeableConceptType] = None,
  category: Seq[CodeableConceptType] = Nil,
  medium: Seq[CodeableConceptType] = Nil,
  subject: Option[ReferenceType] = None,
  recipient: Seq[ReferenceType] = Nil,
  topic: Seq[ReferenceType] = Nil,
  context: Option[ReferenceType] = None,
  sent: Option[DateTimeType] = None,
  received: Option[DateTimeType] = None,
  sender: Option[ReferenceType] = None,
  reasonCode: Seq[CodeableConceptType] = Nil,
  reasonReference: Seq[ReferenceType] = Nil,
  payload: Seq[Communicationu46Payload] = Nil,
  note: Seq[AnnotationType] = Nil) extends DomainResourcable
      


/** An occurrence of information being transmitted; e.g. an alert that was sent to a responsible provider, a public health agency was notified about a reportable condition.
*/
case class Communicationu46Payload(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  contentString: Option[StringTypeType] = None,
  contentAttachment: Option[AttachmentType] = None,
  contentReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait EventStatusu45list

object EventStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[EventStatusu45list]): EventStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: EventStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[EventStatusu45list] = Seq(Preparation, Inu45progressValue6, SuspendedValue6, AbortedValue, CompletedValue11, Enteredu45inu45errorValue23, UnknownValue11)
}

case object Preparation extends EventStatusu45list { override def toString = "preparation" }
case object Inu45progressValue6 extends EventStatusu45list { override def toString = "in-progress" }
case object SuspendedValue6 extends EventStatusu45list { override def toString = "suspended" }
case object AbortedValue extends EventStatusu45list { override def toString = "aborted" }
case object CompletedValue11 extends EventStatusu45list { override def toString = "completed" }
case object Enteredu45inu45errorValue23 extends EventStatusu45list { override def toString = "entered-in-error" }
case object UnknownValue11 extends EventStatusu45list { override def toString = "unknown" }


/** The status of the communication.If the element is present, it must have either a @value, an @id, or extensions
*/
case class EventStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[EventStatusu45list]}
}

      


/** A request to convey information; e.g. the CDS system proposes that an alert be sent to a responsible provider, the CDS system proposes that the public health agency be notified about a reportable condition.If the element is present, it must have either a @value, an @id, or extensions
*/
case class CommunicationRequestType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  basedOn: Seq[ReferenceType] = Nil,
  replaces: Seq[ReferenceType] = Nil,
  groupIdentifier: Option[IdentifierType] = None,
  status: RequestStatus,
  category: Seq[CodeableConceptType] = Nil,
  priority: Option[RequestPriority] = None,
  medium: Seq[CodeableConceptType] = Nil,
  subject: Option[ReferenceType] = None,
  recipient: Seq[ReferenceType] = Nil,
  topic: Seq[ReferenceType] = Nil,
  context: Option[ReferenceType] = None,
  payload: Seq[CommunicationRequestu46Payload] = Nil,
  occurrenceDateTime: Option[DateTimeType] = None,
  occurrencePeriod: Option[PeriodType] = None,
  authoredOn: Option[DateTimeType] = None,
  sender: Option[ReferenceType] = None,
  requester: Option[CommunicationRequestu46Requester] = None,
  reasonCode: Seq[CodeableConceptType] = Nil,
  reasonReference: Seq[ReferenceType] = Nil,
  note: Seq[AnnotationType] = Nil) extends DomainResourcable
      


/** A request to convey information; e.g. the CDS system proposes that an alert be sent to a responsible provider, the CDS system proposes that the public health agency be notified about a reportable condition.
*/
case class CommunicationRequestu46Payload(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  contentString: Option[StringTypeType] = None,
  contentAttachment: Option[AttachmentType] = None,
  contentReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A request to convey information; e.g. the CDS system proposes that an alert be sent to a responsible provider, the CDS system proposes that the public health agency be notified about a reportable condition.
*/
case class CommunicationRequestu46Requester(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  agent: ReferenceType,
  onBehalfOf: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait RequestStatusu45list

object RequestStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[RequestStatusu45list]): RequestStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RequestStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[RequestStatusu45list] = Seq(DraftValue3, ActiveValue10, SuspendedValue3, CancelledValue5, CompletedValue7, Enteredu45inu45errorValue13, UnknownValue5)
}

case object DraftValue3 extends RequestStatusu45list { override def toString = "draft" }
case object ActiveValue10 extends RequestStatusu45list { override def toString = "active" }
case object SuspendedValue3 extends RequestStatusu45list { override def toString = "suspended" }
case object CancelledValue5 extends RequestStatusu45list { override def toString = "cancelled" }
case object CompletedValue7 extends RequestStatusu45list { override def toString = "completed" }
case object Enteredu45inu45errorValue13 extends RequestStatusu45list { override def toString = "entered-in-error" }
case object UnknownValue5 extends RequestStatusu45list { override def toString = "unknown" }


/** The status of the communication request.If the element is present, it must have either a @value, an @id, or extensions
*/
case class RequestStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[RequestStatusu45list]}
}

      

sealed trait RequestPriorityu45list

object RequestPriorityu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[RequestPriorityu45list]): RequestPriorityu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RequestPriorityu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[RequestPriorityu45list] = Seq(Routine, Urgent, Asap, Stat)
}

case object Routine extends RequestPriorityu45list { override def toString = "routine" }
case object Urgent extends RequestPriorityu45list { override def toString = "urgent" }
case object Asap extends RequestPriorityu45list { override def toString = "asap" }
case object Stat extends RequestPriorityu45list { override def toString = "stat" }


/** Codes indicating the relative importance of a communication request.If the element is present, it must have either a @value, an @id, or extensions
*/
case class RequestPriority(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[RequestPriorityu45list]}
}

      


/** A compartment definition that defines how resources are accessed on a server.If the element is present, it must have either a @value, an @id, or extensions
*/
case class CompartmentDefinitionType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: UriType,
  name: StringTypeType,
  title: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  description: Option[MarkdownType] = None,
  purpose: Option[MarkdownType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  code: CompartmentType,
  search: BooleanTypeType,
  resource: Seq[CompartmentDefinitionu46Resource] = Nil) extends DomainResourcable
      


/** A compartment definition that defines how resources are accessed on a server.
*/
case class CompartmentDefinitionu46Resource(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: ResourceTypeType,
  param: Seq[StringTypeType] = Nil,
  documentation: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait CompartmentTypeu45list

object CompartmentTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[CompartmentTypeu45list]): CompartmentTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CompartmentTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[CompartmentTypeu45list] = Seq(PatientValue2, EncounterValue2, RelatedPersonValue2, PractitionerValue2, DeviceValue2)
}

case object PatientValue2 extends CompartmentTypeu45list { override def toString = "Patient" }
case object EncounterValue2 extends CompartmentTypeu45list { override def toString = "Encounter" }
case object RelatedPersonValue2 extends CompartmentTypeu45list { override def toString = "RelatedPerson" }
case object PractitionerValue2 extends CompartmentTypeu45list { override def toString = "Practitioner" }
case object DeviceValue2 extends CompartmentTypeu45list { override def toString = "Device" }


/** Which compartment a compartment definition describesIf the element is present, it must have either a @value, an @id, or extensions
*/
case class CompartmentType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[CompartmentTypeu45list]}
}

      


/** A set of healthcare-related information that is assembled together into a single logical document that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. While a Composition defines the structure, it does not actually contain the content: rather the full content of a document is contained in a Bundle, of which the Composition is the first resource contained.If the element is present, it must have either a @value, an @id, or extensions
*/
case class CompositionType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  status: CompositionStatus,
  typeValue: CodeableConceptType,
  classValue: Option[CodeableConceptType] = None,
  subject: ReferenceType,
  encounter: Option[ReferenceType] = None,
  date: DateTimeType,
  author: Seq[ReferenceType] = Nil,
  title: StringTypeType,
  confidentiality: Option[ConfidentialityClassification] = None,
  attester: Seq[Compositionu46Attester] = Nil,
  custodian: Option[ReferenceType] = None,
  relatesTo: Seq[Compositionu46RelatesTo] = Nil,
  event: Seq[Compositionu46Event] = Nil,
  section: Seq[Compositionu46Section] = Nil) extends DomainResourcable
      


/** A set of healthcare-related information that is assembled together into a single logical document that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. While a Composition defines the structure, it does not actually contain the content: rather the full content of a document is contained in a Bundle, of which the Composition is the first resource contained.
*/
case class Compositionu46Attester(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  mode: Seq[CompositionAttestationMode] = Nil,
  time: Option[DateTimeType] = None,
  party: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A set of healthcare-related information that is assembled together into a single logical document that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. While a Composition defines the structure, it does not actually contain the content: rather the full content of a document is contained in a Bundle, of which the Composition is the first resource contained.
*/
case class Compositionu46RelatesTo(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: DocumentRelationshipType,
  targetIdentifier: Option[IdentifierType] = None,
  targetReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A set of healthcare-related information that is assembled together into a single logical document that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. While a Composition defines the structure, it does not actually contain the content: rather the full content of a document is contained in a Bundle, of which the Composition is the first resource contained.
*/
case class Compositionu46Event(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: Seq[CodeableConceptType] = Nil,
  period: Option[PeriodType] = None,
  detail: Seq[ReferenceType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A set of healthcare-related information that is assembled together into a single logical document that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. While a Composition defines the structure, it does not actually contain the content: rather the full content of a document is contained in a Bundle, of which the Composition is the first resource contained.
*/
case class Compositionu46Section(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  title: Option[StringTypeType] = None,
  code: Option[CodeableConceptType] = None,
  text: Option[NarrativeType] = None,
  mode: Option[ListMode] = None,
  orderedBy: Option[CodeableConceptType] = None,
  entry: Seq[ReferenceType] = Nil,
  emptyReason: Option[CodeableConceptType] = None,
  section: Seq[Compositionu46Section] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait CompositionStatusu45list

object CompositionStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[CompositionStatusu45list]): CompositionStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CompositionStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[CompositionStatusu45list] = Seq(Preliminary, Final, Amended, Enteredu45inu45errorValue24)
}

case object Preliminary extends CompositionStatusu45list { override def toString = "preliminary" }
case object Final extends CompositionStatusu45list { override def toString = "final" }
case object Amended extends CompositionStatusu45list { override def toString = "amended" }
case object Enteredu45inu45errorValue24 extends CompositionStatusu45list { override def toString = "entered-in-error" }


/** The workflow/clinical status of the composition.If the element is present, it must have either a @value, an @id, or extensions
*/
case class CompositionStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[CompositionStatusu45list]}
}

      

sealed trait ConfidentialityClassificationu45list

object ConfidentialityClassificationu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ConfidentialityClassificationu45list]): ConfidentialityClassificationu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ConfidentialityClassificationu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ConfidentialityClassificationu45list] = Seq(UValue, L, M, NValue, RValue, V)
}

case object UValue extends ConfidentialityClassificationu45list { override def toString = "U" }
case object L extends ConfidentialityClassificationu45list { override def toString = "L" }
case object M extends ConfidentialityClassificationu45list { override def toString = "M" }
case object NValue extends ConfidentialityClassificationu45list { override def toString = "N" }
case object RValue extends ConfidentialityClassificationu45list { override def toString = "R" }
case object V extends ConfidentialityClassificationu45list { override def toString = "V" }


/** Codes specifying the level of confidentiality of the composition.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ConfidentialityClassification(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ConfidentialityClassificationu45list]}
}

      

sealed trait DocumentRelationshipTypeu45list

object DocumentRelationshipTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[DocumentRelationshipTypeu45list]): DocumentRelationshipTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DocumentRelationshipTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DocumentRelationshipTypeu45list] = Seq(ReplacesValue, Transforms, Signs, Appends)
}

case object ReplacesValue extends DocumentRelationshipTypeu45list { override def toString = "replaces" }
case object Transforms extends DocumentRelationshipTypeu45list { override def toString = "transforms" }
case object Signs extends DocumentRelationshipTypeu45list { override def toString = "signs" }
case object Appends extends DocumentRelationshipTypeu45list { override def toString = "appends" }


/** The type of relationship between documents.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DocumentRelationshipType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[DocumentRelationshipTypeu45list]}
}

      

sealed trait CompositionAttestationModeu45list

object CompositionAttestationModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[CompositionAttestationModeu45list]): CompositionAttestationModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CompositionAttestationModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[CompositionAttestationModeu45list] = Seq(Personal, Professional, Legal, OfficialValue2)
}

case object Personal extends CompositionAttestationModeu45list { override def toString = "personal" }
case object Professional extends CompositionAttestationModeu45list { override def toString = "professional" }
case object Legal extends CompositionAttestationModeu45list { override def toString = "legal" }
case object OfficialValue2 extends CompositionAttestationModeu45list { override def toString = "official" }


/** The way in which a person authenticated a composition.If the element is present, it must have either a @value, an @id, or extensions
*/
case class CompositionAttestationMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[CompositionAttestationModeu45list]}
}

      

sealed trait ListModeu45list

object ListModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ListModeu45list]): ListModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ListModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ListModeu45list] = Seq(Working, Snapshot, Changes)
}

case object Working extends ListModeu45list { override def toString = "working" }
case object Snapshot extends ListModeu45list { override def toString = "snapshot" }
case object Changes extends ListModeu45list { override def toString = "changes" }


/** The processing mode that applies to this section.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ListMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ListModeu45list]}
}

      


/** A statement of relationships from one set of concepts to one or more other concepts - either code systems or data elements, or classes in class models.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ConceptMapType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: Option[UriType] = None,
  identifier: Option[IdentifierType] = None,
  version: Option[StringTypeType] = None,
  name: Option[StringTypeType] = None,
  title: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  description: Option[MarkdownType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  purpose: Option[MarkdownType] = None,
  copyright: Option[MarkdownType] = None,
  sourceUri: Option[UriType] = None,
  sourceReference: Option[ReferenceType] = None,
  targetUri: Option[UriType] = None,
  targetReference: Option[ReferenceType] = None,
  group: Seq[ConceptMapu46Group] = Nil) extends DomainResourcable
      


/** A statement of relationships from one set of concepts to one or more other concepts - either code systems or data elements, or classes in class models.
*/
case class ConceptMapu46Group(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  source: Option[UriType] = None,
  sourceVersion: Option[StringTypeType] = None,
  target: Option[UriType] = None,
  targetVersion: Option[StringTypeType] = None,
  element: Seq[ConceptMapu46Element] = Nil,
  unmapped: Option[ConceptMapu46Unmapped] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A statement of relationships from one set of concepts to one or more other concepts - either code systems or data elements, or classes in class models.
*/
case class ConceptMapu46Element(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: Option[CodeType] = None,
  display: Option[StringTypeType] = None,
  target: Seq[ConceptMapu46Target] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A statement of relationships from one set of concepts to one or more other concepts - either code systems or data elements, or classes in class models.
*/
case class ConceptMapu46Target(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: Option[CodeType] = None,
  display: Option[StringTypeType] = None,
  equivalence: Option[ConceptMapEquivalence] = None,
  comment: Option[StringTypeType] = None,
  dependsOn: Seq[ConceptMapu46DependsOn] = Nil,
  product: Seq[ConceptMapu46DependsOn] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A statement of relationships from one set of concepts to one or more other concepts - either code systems or data elements, or classes in class models.
*/
case class ConceptMapu46DependsOn(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  property: UriType,
  system: Option[UriType] = None,
  code: StringTypeType,
  display: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A statement of relationships from one set of concepts to one or more other concepts - either code systems or data elements, or classes in class models.
*/
case class ConceptMapu46Unmapped(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  mode: ConceptMapGroupUnmappedMode,
  code: Option[CodeType] = None,
  display: Option[StringTypeType] = None,
  url: Option[UriType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ConceptMapGroupUnmappedModeu45list

object ConceptMapGroupUnmappedModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ConceptMapGroupUnmappedModeu45list]): ConceptMapGroupUnmappedModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ConceptMapGroupUnmappedModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ConceptMapGroupUnmappedModeu45list] = Seq(Provided, Fixed, Otheru45map)
}

case object Provided extends ConceptMapGroupUnmappedModeu45list { override def toString = "provided" }
case object Fixed extends ConceptMapGroupUnmappedModeu45list { override def toString = "fixed" }
case object Otheru45map extends ConceptMapGroupUnmappedModeu45list { override def toString = "other-map" }


/** Defines which action to take if there is no match in the group.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ConceptMapGroupUnmappedMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ConceptMapGroupUnmappedModeu45list]}
}

      


/** A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ConditionType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  clinicalStatus: Option[ConditionClinicalStatusCodes] = None,
  verificationStatus: Option[ConditionVerificationStatus] = None,
  category: Seq[CodeableConceptType] = Nil,
  severity: Option[CodeableConceptType] = None,
  code: Option[CodeableConceptType] = None,
  bodySite: Seq[CodeableConceptType] = Nil,
  subject: ReferenceType,
  context: Option[ReferenceType] = None,
  onsetDateTime: Option[DateTimeType] = None,
  onsetAge: Option[AgeType] = None,
  onsetPeriod: Option[PeriodType] = None,
  onsetRange: Option[RangeTypeType] = None,
  onsetString: Option[StringTypeType] = None,
  abatementDateTime: Option[DateTimeType] = None,
  abatementAge: Option[AgeType] = None,
  abatementBoolean: Option[BooleanTypeType] = None,
  abatementPeriod: Option[PeriodType] = None,
  abatementRange: Option[RangeTypeType] = None,
  abatementString: Option[StringTypeType] = None,
  assertedDate: Option[DateTimeType] = None,
  asserter: Option[ReferenceType] = None,
  stage: Option[Conditionu46Stage] = None,
  evidence: Seq[Conditionu46Evidence] = Nil,
  note: Seq[AnnotationType] = Nil) extends DomainResourcable
      


/** A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern.
*/
case class Conditionu46Stage(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  summary: Option[CodeableConceptType] = None,
  assessment: Seq[ReferenceType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern.
*/
case class Conditionu46Evidence(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: Seq[CodeableConceptType] = Nil,
  detail: Seq[ReferenceType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ConditionVerificationStatusu45list

object ConditionVerificationStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ConditionVerificationStatusu45list]): ConditionVerificationStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ConditionVerificationStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ConditionVerificationStatusu45list] = Seq(Provisional, Differential, Confirmed, Refuted, Enteredu45inu45errorValue12, UnknownValue4)
}

case object Provisional extends ConditionVerificationStatusu45list { override def toString = "provisional" }
case object Differential extends ConditionVerificationStatusu45list { override def toString = "differential" }
case object Confirmed extends ConditionVerificationStatusu45list { override def toString = "confirmed" }
case object Refuted extends ConditionVerificationStatusu45list { override def toString = "refuted" }
case object Enteredu45inu45errorValue12 extends ConditionVerificationStatusu45list { override def toString = "entered-in-error" }
case object UnknownValue4 extends ConditionVerificationStatusu45list { override def toString = "unknown" }


/** The verification status to support or decline the clinical status of the condition or diagnosis.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ConditionVerificationStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ConditionVerificationStatusu45list]}
}

      

sealed trait ConditionClinicalStatusCodesu45list

object ConditionClinicalStatusCodesu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ConditionClinicalStatusCodesu45list]): ConditionClinicalStatusCodesu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ConditionClinicalStatusCodesu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ConditionClinicalStatusCodesu45list] = Seq(ActiveValue9, Recurrence, InactiveValue2, Remission, Resolved)
}

case object ActiveValue9 extends ConditionClinicalStatusCodesu45list { override def toString = "active" }
case object Recurrence extends ConditionClinicalStatusCodesu45list { override def toString = "recurrence" }
case object InactiveValue2 extends ConditionClinicalStatusCodesu45list { override def toString = "inactive" }
case object Remission extends ConditionClinicalStatusCodesu45list { override def toString = "remission" }
case object Resolved extends ConditionClinicalStatusCodesu45list { override def toString = "resolved" }


/** The clinical status of the condition or diagnosis.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ConditionClinicalStatusCodes(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ConditionClinicalStatusCodesu45list]}
}

      


/** A record of a healthcare consumerâ€™s policy choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ConsentType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  status: ConsentState,
  category: Seq[CodeableConceptType] = Nil,
  patient: ReferenceType,
  period: Option[PeriodType] = None,
  dateTime: Option[DateTimeType] = None,
  consentingParty: Seq[ReferenceType] = Nil,
  actor: Seq[Consentu46Actor] = Nil,
  action: Seq[CodeableConceptType] = Nil,
  organization: Seq[ReferenceType] = Nil,
  sourceAttachment: Option[AttachmentType] = None,
  sourceIdentifier: Option[IdentifierType] = None,
  sourceReference: Option[ReferenceType] = None,
  policy: Seq[Consentu46Policy] = Nil,
  policyRule: Option[UriType] = None,
  securityLabel: Seq[CodingType] = Nil,
  purpose: Seq[CodingType] = Nil,
  dataPeriod: Option[PeriodType] = None,
  data: Seq[Consentu46Data] = Nil,
  except: Seq[Consentu46Except] = Nil) extends DomainResourcable
      


/** A record of a healthcare consumerâ€™s policy choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.
*/
case class Consentu46Actor(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  role: CodeableConceptType,
  reference: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A record of a healthcare consumerâ€™s policy choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.
*/
case class Consentu46Policy(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  authority: Option[UriType] = None,
  uri: Option[UriType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A record of a healthcare consumerâ€™s policy choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.
*/
case class Consentu46Data(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  meaning: ConsentDataMeaning,
  reference: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A record of a healthcare consumerâ€™s policy choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.
*/
case class Consentu46Except(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: ConsentExceptType,
  period: Option[PeriodType] = None,
  actor: Seq[Consentu46Actor1] = Nil,
  action: Seq[CodeableConceptType] = Nil,
  securityLabel: Seq[CodingType] = Nil,
  purpose: Seq[CodingType] = Nil,
  classValue: Seq[CodingType] = Nil,
  code: Seq[CodingType] = Nil,
  dataPeriod: Option[PeriodType] = None,
  data: Seq[Consentu46Data1] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A record of a healthcare consumerâ€™s policy choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.
*/
case class Consentu46Actor1(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  role: CodeableConceptType,
  reference: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A record of a healthcare consumerâ€™s policy choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.
*/
case class Consentu46Data1(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  meaning: ConsentDataMeaning,
  reference: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ConsentDataMeaningu45list

object ConsentDataMeaningu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ConsentDataMeaningu45list]): ConsentDataMeaningu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ConsentDataMeaningu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ConsentDataMeaningu45list] = Seq(InstanceValue2, Related, Dependents, Authoredby)
}

case object InstanceValue2 extends ConsentDataMeaningu45list { override def toString = "instance" }
case object Related extends ConsentDataMeaningu45list { override def toString = "related" }
case object Dependents extends ConsentDataMeaningu45list { override def toString = "dependents" }
case object Authoredby extends ConsentDataMeaningu45list { override def toString = "authoredby" }


/** How a resource reference is interpreted when testing consent restrictionsIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ConsentDataMeaning(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ConsentDataMeaningu45list]}
}

      

sealed trait ConsentStateu45list

object ConsentStateu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ConsentStateu45list]): ConsentStateu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ConsentStateu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ConsentStateu45list] = Seq(DraftValue8, ProposedValue5, ActiveValue17, RejectedValue, InactiveValue6, Enteredu45inu45errorValue25)
}

case object DraftValue8 extends ConsentStateu45list { override def toString = "draft" }
case object ProposedValue5 extends ConsentStateu45list { override def toString = "proposed" }
case object ActiveValue17 extends ConsentStateu45list { override def toString = "active" }
case object RejectedValue extends ConsentStateu45list { override def toString = "rejected" }
case object InactiveValue6 extends ConsentStateu45list { override def toString = "inactive" }
case object Enteredu45inu45errorValue25 extends ConsentStateu45list { override def toString = "entered-in-error" }


/** Indicates the state of the consentIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ConsentState(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ConsentStateu45list]}
}

      

sealed trait ConsentExceptTypeu45list

object ConsentExceptTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ConsentExceptTypeu45list]): ConsentExceptTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ConsentExceptTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ConsentExceptTypeu45list] = Seq(Deny, Permit)
}

case object Deny extends ConsentExceptTypeu45list { override def toString = "deny" }
case object Permit extends ConsentExceptTypeu45list { override def toString = "permit" }


/** How an exception statement is applied, such as adding additional consent or removing consentIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ConsentExceptType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ConsentExceptTypeu45list]}
}

      


/** A formal agreement between parties regarding the conduct of business, exchange of information or other matters.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ContractType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  status: Option[ContractResourceStatusCodes] = None,
  issued: Option[DateTimeType] = None,
  applies: Option[PeriodType] = None,
  subject: Seq[ReferenceType] = Nil,
  topic: Seq[ReferenceType] = Nil,
  authority: Seq[ReferenceType] = Nil,
  domain: Seq[ReferenceType] = Nil,
  typeValue: Option[CodeableConceptType] = None,
  subType: Seq[CodeableConceptType] = Nil,
  action: Seq[CodeableConceptType] = Nil,
  actionReason: Seq[CodeableConceptType] = Nil,
  decisionType: Option[CodeableConceptType] = None,
  contentDerivative: Option[CodeableConceptType] = None,
  securityLabel: Seq[CodingType] = Nil,
  agent: Seq[Contractu46Agent] = Nil,
  signer: Seq[Contractu46Signer] = Nil,
  valuedItem: Seq[Contractu46ValuedItem] = Nil,
  term: Seq[Contractu46Term] = Nil,
  bindingAttachment: Option[AttachmentType] = None,
  bindingReference: Option[ReferenceType] = None,
  friendly: Seq[Contractu46Friendly] = Nil,
  legal: Seq[Contractu46Legal] = Nil,
  rule: Seq[Contractu46Rule] = Nil) extends DomainResourcable
      


/** A formal agreement between parties regarding the conduct of business, exchange of information or other matters.
*/
case class Contractu46Agent(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  actor: ReferenceType,
  role: Seq[CodeableConceptType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A formal agreement between parties regarding the conduct of business, exchange of information or other matters.
*/
case class Contractu46Signer(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: CodingType,
  party: ReferenceType,
  signature: Seq[SignatureType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A formal agreement between parties regarding the conduct of business, exchange of information or other matters.
*/
case class Contractu46ValuedItem(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  entityCodeableConcept: Option[CodeableConceptType] = None,
  entityReference: Option[ReferenceType] = None,
  identifier: Option[IdentifierType] = None,
  effectiveTime: Option[DateTimeType] = None,
  quantity: Option[Quantityable] = None,
  unitPrice: Option[MoneyType] = None,
  factor: Option[DecimalType] = None,
  points: Option[DecimalType] = None,
  net: Option[MoneyType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A formal agreement between parties regarding the conduct of business, exchange of information or other matters.
*/
case class Contractu46Term(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  issued: Option[DateTimeType] = None,
  applies: Option[PeriodType] = None,
  typeValue: Option[CodeableConceptType] = None,
  subType: Option[CodeableConceptType] = None,
  topic: Seq[ReferenceType] = Nil,
  action: Seq[CodeableConceptType] = Nil,
  actionReason: Seq[CodeableConceptType] = Nil,
  securityLabel: Seq[CodingType] = Nil,
  agent: Seq[Contractu46Agent1] = Nil,
  text: Option[StringTypeType] = None,
  valuedItem: Seq[Contractu46ValuedItem1] = Nil,
  group: Seq[Contractu46Term] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A formal agreement between parties regarding the conduct of business, exchange of information or other matters.
*/
case class Contractu46Agent1(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  actor: ReferenceType,
  role: Seq[CodeableConceptType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A formal agreement between parties regarding the conduct of business, exchange of information or other matters.
*/
case class Contractu46ValuedItem1(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  entityCodeableConcept: Option[CodeableConceptType] = None,
  entityReference: Option[ReferenceType] = None,
  identifier: Option[IdentifierType] = None,
  effectiveTime: Option[DateTimeType] = None,
  quantity: Option[Quantityable] = None,
  unitPrice: Option[MoneyType] = None,
  factor: Option[DecimalType] = None,
  points: Option[DecimalType] = None,
  net: Option[MoneyType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A formal agreement between parties regarding the conduct of business, exchange of information or other matters.
*/
case class Contractu46Friendly(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  contentAttachment: Option[AttachmentType] = None,
  contentReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A formal agreement between parties regarding the conduct of business, exchange of information or other matters.
*/
case class Contractu46Legal(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  contentAttachment: Option[AttachmentType] = None,
  contentReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A formal agreement between parties regarding the conduct of business, exchange of information or other matters.
*/
case class Contractu46Rule(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  contentAttachment: Option[AttachmentType] = None,
  contentReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ContractResourceStatusCodesu45list

object ContractResourceStatusCodesu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ContractResourceStatusCodesu45list]): ContractResourceStatusCodesu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ContractResourceStatusCodesu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ContractResourceStatusCodesu45list] = Seq(AmendedValue, Appended, CancelledValue10, Disputed, Enteredu45inu45errorValue26, Executable, Executed, Negotiable, Offered, Policy, RejectedValue2, Renewed, Revoked, ResolvedValue2, Terminated)
}

case object AmendedValue extends ContractResourceStatusCodesu45list { override def toString = "amended" }
case object Appended extends ContractResourceStatusCodesu45list { override def toString = "appended" }
case object CancelledValue10 extends ContractResourceStatusCodesu45list { override def toString = "cancelled" }
case object Disputed extends ContractResourceStatusCodesu45list { override def toString = "disputed" }
case object Enteredu45inu45errorValue26 extends ContractResourceStatusCodesu45list { override def toString = "entered-in-error" }
case object Executable extends ContractResourceStatusCodesu45list { override def toString = "executable" }
case object Executed extends ContractResourceStatusCodesu45list { override def toString = "executed" }
case object Negotiable extends ContractResourceStatusCodesu45list { override def toString = "negotiable" }
case object Offered extends ContractResourceStatusCodesu45list { override def toString = "offered" }
case object Policy extends ContractResourceStatusCodesu45list { override def toString = "policy" }
case object RejectedValue2 extends ContractResourceStatusCodesu45list { override def toString = "rejected" }
case object Renewed extends ContractResourceStatusCodesu45list { override def toString = "renewed" }
case object Revoked extends ContractResourceStatusCodesu45list { override def toString = "revoked" }
case object ResolvedValue2 extends ContractResourceStatusCodesu45list { override def toString = "resolved" }
case object Terminated extends ContractResourceStatusCodesu45list { override def toString = "terminated" }


/** A code specifying the state of the resource instance.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ContractResourceStatusCodes(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ContractResourceStatusCodesu45list]}
}

      


/** Financial instrument which may be used to reimburse or pay for health care products and services.If the element is present, it must have either a @value, an @id, or extensions
*/
case class CoverageType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[FinancialResourceStatusCodes] = None,
  typeValue: Option[CodeableConceptType] = None,
  policyHolder: Option[ReferenceType] = None,
  subscriber: Option[ReferenceType] = None,
  subscriberId: Option[StringTypeType] = None,
  beneficiary: Option[ReferenceType] = None,
  relationship: Option[CodeableConceptType] = None,
  period: Option[PeriodType] = None,
  payor: Seq[ReferenceType] = Nil,
  grouping: Option[Coverageu46Grouping] = None,
  dependent: Option[StringTypeType] = None,
  sequence: Option[StringTypeType] = None,
  order: Option[PositiveIntType] = None,
  network: Option[StringTypeType] = None,
  contract: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** Financial instrument which may be used to reimburse or pay for health care products and services.
*/
case class Coverageu46Grouping(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  group: Option[StringTypeType] = None,
  groupDisplay: Option[StringTypeType] = None,
  subGroup: Option[StringTypeType] = None,
  subGroupDisplay: Option[StringTypeType] = None,
  plan: Option[StringTypeType] = None,
  planDisplay: Option[StringTypeType] = None,
  subPlan: Option[StringTypeType] = None,
  subPlanDisplay: Option[StringTypeType] = None,
  classValue: Option[StringTypeType] = None,
  classDisplay: Option[StringTypeType] = None,
  subClass: Option[StringTypeType] = None,
  subClassDisplay: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The formal description of a single piece of information that can be gathered and reported.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DataElementType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: Option[UriType] = None,
  identifier: Seq[IdentifierType] = Nil,
  version: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  name: Option[StringTypeType] = None,
  title: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  copyright: Option[MarkdownType] = None,
  stringency: Option[DataElementStringency] = None,
  mapping: Seq[DataElementu46Mapping] = Nil,
  element: Seq[ElementDefinitionType] = Nil) extends DomainResourcable
      


/** The formal description of a single piece of information that can be gathered and reported.
*/
case class DataElementu46Mapping(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identity: IdType,
  uri: Option[UriType] = None,
  name: Option[StringTypeType] = None,
  comment: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait DataElementStringencyu45list

object DataElementStringencyu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[DataElementStringencyu45list]): DataElementStringencyu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DataElementStringencyu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DataElementStringencyu45list] = Seq(Comparable, Fullyu45specified, EquivalentValue, Convertable, Scaleable, Flexible)
}

case object Comparable extends DataElementStringencyu45list { override def toString = "comparable" }
case object Fullyu45specified extends DataElementStringencyu45list { override def toString = "fully-specified" }
case object EquivalentValue extends DataElementStringencyu45list { override def toString = "equivalent" }
case object Convertable extends DataElementStringencyu45list { override def toString = "convertable" }
case object Scaleable extends DataElementStringencyu45list { override def toString = "scaleable" }
case object Flexible extends DataElementStringencyu45list { override def toString = "flexible" }


/** Indicates the degree of precision of the data element definition.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DataElementStringency(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[DataElementStringencyu45list]}
}

      


/** Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DetectedIssueType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  status: ObservationStatus,
  category: Option[CodeableConceptType] = None,
  severity: Option[DetectedIssueSeverity] = None,
  patient: Option[ReferenceType] = None,
  date: Option[DateTimeType] = None,
  author: Option[ReferenceType] = None,
  implicated: Seq[ReferenceType] = Nil,
  detail: Option[StringTypeType] = None,
  reference: Option[UriType] = None,
  mitigation: Seq[DetectedIssueu46Mitigation] = Nil) extends DomainResourcable
      


/** Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc.
*/
case class DetectedIssueu46Mitigation(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  action: CodeableConceptType,
  date: Option[DateTimeType] = None,
  author: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ObservationStatusu45list

object ObservationStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ObservationStatusu45list]): ObservationStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ObservationStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ObservationStatusu45list] = Seq(Registered, PreliminaryValue, FinalValue, AmendedValue2, Corrected, CancelledValue11, Enteredu45inu45errorValue27, UnknownValue12)
}

case object Registered extends ObservationStatusu45list { override def toString = "registered" }
case object PreliminaryValue extends ObservationStatusu45list { override def toString = "preliminary" }
case object FinalValue extends ObservationStatusu45list { override def toString = "final" }
case object AmendedValue2 extends ObservationStatusu45list { override def toString = "amended" }
case object Corrected extends ObservationStatusu45list { override def toString = "corrected" }
case object CancelledValue11 extends ObservationStatusu45list { override def toString = "cancelled" }
case object Enteredu45inu45errorValue27 extends ObservationStatusu45list { override def toString = "entered-in-error" }
case object UnknownValue12 extends ObservationStatusu45list { override def toString = "unknown" }


/** Indicates the status of the identified issueIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ObservationStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ObservationStatusu45list]}
}

      

sealed trait DetectedIssueSeverityu45list

object DetectedIssueSeverityu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[DetectedIssueSeverityu45list]): DetectedIssueSeverityu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DetectedIssueSeverityu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DetectedIssueSeverityu45list] = Seq(HighValue, ModerateValue, LowValue)
}

case object HighValue extends DetectedIssueSeverityu45list { override def toString = "high" }
case object ModerateValue extends DetectedIssueSeverityu45list { override def toString = "moderate" }
case object LowValue extends DetectedIssueSeverityu45list { override def toString = "low" }


/** Indicates the potential degree of impact of the identified issue on the patient.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DetectedIssueSeverity(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[DetectedIssueSeverityu45list]}
}

      


/** This resource identifies an instance or a type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device.  Medical devices include durable (reusable) medical equipment, implantable devices, as well as disposable equipment used for diagnostic, treatment, and research for healthcare and public health.  Non-medical devices may include items such as a machine, cellphone, computer, application, etc.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DeviceType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  udi: Option[Deviceu46Udi] = None,
  status: Option[FHIRDeviceStatus] = None,
  typeValue: Option[CodeableConceptType] = None,
  lotNumber: Option[StringTypeType] = None,
  manufacturer: Option[StringTypeType] = None,
  manufactureDate: Option[DateTimeType] = None,
  expirationDate: Option[DateTimeType] = None,
  model: Option[StringTypeType] = None,
  version: Option[StringTypeType] = None,
  patient: Option[ReferenceType] = None,
  owner: Option[ReferenceType] = None,
  contact: Seq[ContactPointType] = Nil,
  location: Option[ReferenceType] = None,
  url: Option[UriType] = None,
  note: Seq[AnnotationType] = Nil,
  safety: Seq[CodeableConceptType] = Nil) extends DomainResourcable
      


/** This resource identifies an instance or a type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device.  Medical devices include durable (reusable) medical equipment, implantable devices, as well as disposable equipment used for diagnostic, treatment, and research for healthcare and public health.  Non-medical devices may include items such as a machine, cellphone, computer, application, etc.
*/
case class Deviceu46Udi(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  deviceIdentifier: Option[StringTypeType] = None,
  name: Option[StringTypeType] = None,
  jurisdiction: Option[UriType] = None,
  carrierHRF: Option[StringTypeType] = None,
  carrierAIDC: Option[Base64BinaryTypeType] = None,
  issuer: Option[UriType] = None,
  entryType: Option[UDIEntryType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait FHIRDeviceStatusu45list

object FHIRDeviceStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[FHIRDeviceStatusu45list]): FHIRDeviceStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: FHIRDeviceStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[FHIRDeviceStatusu45list] = Seq(ActiveValue18, InactiveValue7, Enteredu45inu45errorValue28, UnknownValue13)
}

case object ActiveValue18 extends FHIRDeviceStatusu45list { override def toString = "active" }
case object InactiveValue7 extends FHIRDeviceStatusu45list { override def toString = "inactive" }
case object Enteredu45inu45errorValue28 extends FHIRDeviceStatusu45list { override def toString = "entered-in-error" }
case object UnknownValue13 extends FHIRDeviceStatusu45list { override def toString = "unknown" }


/** The availability status of the device.If the element is present, it must have either a @value, an @id, or extensions
*/
case class FHIRDeviceStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[FHIRDeviceStatusu45list]}
}

      

sealed trait UDIEntryTypeu45list

object UDIEntryTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[UDIEntryTypeu45list]): UDIEntryTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: UDIEntryTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[UDIEntryTypeu45list] = Seq(Barcode, Rfid, Manual, Card, Selfu45reported, UnknownValue14)
}

case object Barcode extends UDIEntryTypeu45list { override def toString = "barcode" }
case object Rfid extends UDIEntryTypeu45list { override def toString = "rfid" }
case object Manual extends UDIEntryTypeu45list { override def toString = "manual" }
case object Card extends UDIEntryTypeu45list { override def toString = "card" }
case object Selfu45reported extends UDIEntryTypeu45list { override def toString = "self-reported" }
case object UnknownValue14 extends UDIEntryTypeu45list { override def toString = "unknown" }


/** Codes to identify how UDI data was enteredIf the element is present, it must have either a @value, an @id, or extensions
*/
case class UDIEntryType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[UDIEntryTypeu45list]}
}

      


/** The characteristics, operational status and capabilities of a medical-related component of a medical device.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DeviceComponentType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: IdentifierType,
  typeValue: CodeableConceptType,
  lastSystemChange: Option[InstantType] = None,
  source: Option[ReferenceType] = None,
  parent: Option[ReferenceType] = None,
  operationalStatus: Seq[CodeableConceptType] = Nil,
  parameterGroup: Option[CodeableConceptType] = None,
  measurementPrinciple: Option[MeasmntPrinciple] = None,
  productionSpecification: Seq[DeviceComponentu46ProductionSpecification] = Nil,
  languageCode: Option[CodeableConceptType] = None) extends DomainResourcable
      


/** The characteristics, operational status and capabilities of a medical-related component of a medical device.
*/
case class DeviceComponentu46ProductionSpecification(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  specType: Option[CodeableConceptType] = None,
  componentId: Option[IdentifierType] = None,
  productionSpec: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait MeasmntPrincipleu45list

object MeasmntPrincipleu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[MeasmntPrincipleu45list]): MeasmntPrincipleu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MeasmntPrincipleu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[MeasmntPrincipleu45list] = Seq(OtherValue4, Chemical, Electrical, Impedance, Nuclear, Optical, Thermal, Biological, Mechanical, Acoustical, ManualValue)
}

case object OtherValue4 extends MeasmntPrincipleu45list { override def toString = "other" }
case object Chemical extends MeasmntPrincipleu45list { override def toString = "chemical" }
case object Electrical extends MeasmntPrincipleu45list { override def toString = "electrical" }
case object Impedance extends MeasmntPrincipleu45list { override def toString = "impedance" }
case object Nuclear extends MeasmntPrincipleu45list { override def toString = "nuclear" }
case object Optical extends MeasmntPrincipleu45list { override def toString = "optical" }
case object Thermal extends MeasmntPrincipleu45list { override def toString = "thermal" }
case object Biological extends MeasmntPrincipleu45list { override def toString = "biological" }
case object Mechanical extends MeasmntPrincipleu45list { override def toString = "mechanical" }
case object Acoustical extends MeasmntPrincipleu45list { override def toString = "acoustical" }
case object ManualValue extends MeasmntPrincipleu45list { override def toString = "manual" }


/** Different measurement principle supported by the device.If the element is present, it must have either a @value, an @id, or extensions
*/
case class MeasmntPrinciple(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[MeasmntPrincipleu45list]}
}

      


/** Describes a measurement, calculation or setting capability of a medical device.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DeviceMetricType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: IdentifierType,
  typeValue: CodeableConceptType,
  unit: Option[CodeableConceptType] = None,
  source: Option[ReferenceType] = None,
  parent: Option[ReferenceType] = None,
  operationalStatus: Option[DeviceMetricOperationalStatus] = None,
  color: Option[DeviceMetricColor] = None,
  category: DeviceMetricCategory,
  measurementPeriod: Option[TimingType] = None,
  calibration: Seq[DeviceMetricu46Calibration] = Nil) extends DomainResourcable
      


/** Describes a measurement, calculation or setting capability of a medical device.
*/
case class DeviceMetricu46Calibration(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: Option[DeviceMetricCalibrationType] = None,
  state: Option[DeviceMetricCalibrationState] = None,
  time: Option[InstantType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait DeviceMetricCalibrationTypeu45list

object DeviceMetricCalibrationTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[DeviceMetricCalibrationTypeu45list]): DeviceMetricCalibrationTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DeviceMetricCalibrationTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DeviceMetricCalibrationTypeu45list] = Seq(Unspecified, Offset, Gain, Twou45point)
}

case object Unspecified extends DeviceMetricCalibrationTypeu45list { override def toString = "unspecified" }
case object Offset extends DeviceMetricCalibrationTypeu45list { override def toString = "offset" }
case object Gain extends DeviceMetricCalibrationTypeu45list { override def toString = "gain" }
case object Twou45point extends DeviceMetricCalibrationTypeu45list { override def toString = "two-point" }


/** Describes the type of a metric calibration.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DeviceMetricCalibrationType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[DeviceMetricCalibrationTypeu45list]}
}

      

sealed trait DeviceMetricColoru45list

object DeviceMetricColoru45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[DeviceMetricColoru45list]): DeviceMetricColoru45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DeviceMetricColoru45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DeviceMetricColoru45list] = Seq(Black, Red, Green, Yellow, Blue, Magenta, Cyan, White)
}

case object Black extends DeviceMetricColoru45list { override def toString = "black" }
case object Red extends DeviceMetricColoru45list { override def toString = "red" }
case object Green extends DeviceMetricColoru45list { override def toString = "green" }
case object Yellow extends DeviceMetricColoru45list { override def toString = "yellow" }
case object Blue extends DeviceMetricColoru45list { override def toString = "blue" }
case object Magenta extends DeviceMetricColoru45list { override def toString = "magenta" }
case object Cyan extends DeviceMetricColoru45list { override def toString = "cyan" }
case object White extends DeviceMetricColoru45list { override def toString = "white" }


/** Describes the typical color of representation.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DeviceMetricColor(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[DeviceMetricColoru45list]}
}

      

sealed trait DeviceMetricCalibrationStateu45list

object DeviceMetricCalibrationStateu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[DeviceMetricCalibrationStateu45list]): DeviceMetricCalibrationStateu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DeviceMetricCalibrationStateu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DeviceMetricCalibrationStateu45list] = Seq(Notu45calibrated, Calibrationu45required, Calibrated, UnspecifiedValue)
}

case object Notu45calibrated extends DeviceMetricCalibrationStateu45list { override def toString = "not-calibrated" }
case object Calibrationu45required extends DeviceMetricCalibrationStateu45list { override def toString = "calibration-required" }
case object Calibrated extends DeviceMetricCalibrationStateu45list { override def toString = "calibrated" }
case object UnspecifiedValue extends DeviceMetricCalibrationStateu45list { override def toString = "unspecified" }


/** Describes the state of a metric calibration.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DeviceMetricCalibrationState(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[DeviceMetricCalibrationStateu45list]}
}

      

sealed trait DeviceMetricOperationalStatusu45list

object DeviceMetricOperationalStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[DeviceMetricOperationalStatusu45list]): DeviceMetricOperationalStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DeviceMetricOperationalStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DeviceMetricOperationalStatusu45list] = Seq(On, OffValue, Standby, Enteredu45inu45errorValue29)
}

case object On extends DeviceMetricOperationalStatusu45list { override def toString = "on" }
case object OffValue extends DeviceMetricOperationalStatusu45list { override def toString = "off" }
case object Standby extends DeviceMetricOperationalStatusu45list { override def toString = "standby" }
case object Enteredu45inu45errorValue29 extends DeviceMetricOperationalStatusu45list { override def toString = "entered-in-error" }


/** Describes the operational status of the DeviceMetric.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DeviceMetricOperationalStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[DeviceMetricOperationalStatusu45list]}
}

      

sealed trait DeviceMetricCategoryu45list

object DeviceMetricCategoryu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[DeviceMetricCategoryu45list]): DeviceMetricCategoryu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DeviceMetricCategoryu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DeviceMetricCategoryu45list] = Seq(Measurement, Setting, Calculation, UnspecifiedValue2)
}

case object Measurement extends DeviceMetricCategoryu45list { override def toString = "measurement" }
case object Setting extends DeviceMetricCategoryu45list { override def toString = "setting" }
case object Calculation extends DeviceMetricCategoryu45list { override def toString = "calculation" }
case object UnspecifiedValue2 extends DeviceMetricCategoryu45list { override def toString = "unspecified" }


/** Describes the category of the metric.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DeviceMetricCategory(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[DeviceMetricCategoryu45list]}
}

      


/** Represents a request for a patient to employ a medical device. The device may be an implantable device, or an external assistive device, such as a walker.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DeviceRequestType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  definition: Seq[ReferenceType] = Nil,
  basedOn: Seq[ReferenceType] = Nil,
  priorRequest: Seq[ReferenceType] = Nil,
  groupIdentifier: Option[IdentifierType] = None,
  status: Option[RequestStatus] = None,
  intent: CodeableConceptType,
  priority: Option[RequestPriority] = None,
  codeReference: Option[ReferenceType] = None,
  codeCodeableConcept: Option[CodeableConceptType] = None,
  subject: ReferenceType,
  context: Option[ReferenceType] = None,
  occurrenceDateTime: Option[DateTimeType] = None,
  occurrencePeriod: Option[PeriodType] = None,
  occurrenceTiming: Option[TimingType] = None,
  authoredOn: Option[DateTimeType] = None,
  requester: Option[DeviceRequestu46Requester] = None,
  performerType: Option[CodeableConceptType] = None,
  performer: Option[ReferenceType] = None,
  reasonCode: Seq[CodeableConceptType] = Nil,
  reasonReference: Seq[ReferenceType] = Nil,
  supportingInfo: Seq[ReferenceType] = Nil,
  note: Seq[AnnotationType] = Nil,
  relevantHistory: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** Represents a request for a patient to employ a medical device. The device may be an implantable device, or an external assistive device, such as a walker.
*/
case class DeviceRequestu46Requester(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  agent: ReferenceType,
  onBehalfOf: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A record of a device being used by a patient where the record is the result of a report from the patient or another clinician.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DeviceUseStatementType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: DeviceUseStatementStatus,
  subject: ReferenceType,
  whenUsed: Option[PeriodType] = None,
  timingTiming: Option[TimingType] = None,
  timingPeriod: Option[PeriodType] = None,
  timingDateTime: Option[DateTimeType] = None,
  recordedOn: Option[DateTimeType] = None,
  source: Option[ReferenceType] = None,
  device: ReferenceType,
  indication: Seq[CodeableConceptType] = Nil,
  bodySite: Option[CodeableConceptType] = None,
  note: Seq[AnnotationType] = Nil) extends DomainResourcable
      

sealed trait DeviceUseStatementStatusu45list

object DeviceUseStatementStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[DeviceUseStatementStatusu45list]): DeviceUseStatementStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DeviceUseStatementStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DeviceUseStatementStatusu45list] = Seq(ActiveValue8, CompletedValue6, Enteredu45inu45errorValue11, IntendedValue, StoppedValue3, Onu45holdValue4)
}

case object ActiveValue8 extends DeviceUseStatementStatusu45list { override def toString = "active" }
case object CompletedValue6 extends DeviceUseStatementStatusu45list { override def toString = "completed" }
case object Enteredu45inu45errorValue11 extends DeviceUseStatementStatusu45list { override def toString = "entered-in-error" }
case object IntendedValue extends DeviceUseStatementStatusu45list { override def toString = "intended" }
case object StoppedValue3 extends DeviceUseStatementStatusu45list { override def toString = "stopped" }
case object Onu45holdValue4 extends DeviceUseStatementStatusu45list { override def toString = "on-hold" }


/** A coded concept indicating the current status of a the Device UsageIf the element is present, it must have either a @value, an @id, or extensions
*/
case class DeviceUseStatementStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[DeviceUseStatementStatusu45list]}
}

      


/** The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretations, and formatted representation of diagnostic reports.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DiagnosticReportType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  basedOn: Seq[ReferenceType] = Nil,
  status: DiagnosticReportStatus,
  category: Option[CodeableConceptType] = None,
  code: CodeableConceptType,
  subject: Option[ReferenceType] = None,
  context: Option[ReferenceType] = None,
  effectiveDateTime: Option[DateTimeType] = None,
  effectivePeriod: Option[PeriodType] = None,
  issued: Option[InstantType] = None,
  performer: Seq[DiagnosticReportu46Performer] = Nil,
  specimen: Seq[ReferenceType] = Nil,
  result: Seq[ReferenceType] = Nil,
  imagingStudy: Seq[ReferenceType] = Nil,
  image: Seq[DiagnosticReportu46Image] = Nil,
  conclusion: Option[StringTypeType] = None,
  codedDiagnosis: Seq[CodeableConceptType] = Nil,
  presentedForm: Seq[AttachmentType] = Nil) extends DomainResourcable
      


/** The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretations, and formatted representation of diagnostic reports.
*/
case class DiagnosticReportu46Performer(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  role: Option[CodeableConceptType] = None,
  actor: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretations, and formatted representation of diagnostic reports.
*/
case class DiagnosticReportu46Image(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  comment: Option[StringTypeType] = None,
  link: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait DiagnosticReportStatusu45list

object DiagnosticReportStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[DiagnosticReportStatusu45list]): DiagnosticReportStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DiagnosticReportStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DiagnosticReportStatusu45list] = Seq(RegisteredValue, PartialValue, PreliminaryValue2, FinalValue2, AmendedValue3, CorrectedValue, AppendedValue, CancelledValue12, Enteredu45inu45errorValue30, UnknownValue15)
}

case object RegisteredValue extends DiagnosticReportStatusu45list { override def toString = "registered" }
case object PartialValue extends DiagnosticReportStatusu45list { override def toString = "partial" }
case object PreliminaryValue2 extends DiagnosticReportStatusu45list { override def toString = "preliminary" }
case object FinalValue2 extends DiagnosticReportStatusu45list { override def toString = "final" }
case object AmendedValue3 extends DiagnosticReportStatusu45list { override def toString = "amended" }
case object CorrectedValue extends DiagnosticReportStatusu45list { override def toString = "corrected" }
case object AppendedValue extends DiagnosticReportStatusu45list { override def toString = "appended" }
case object CancelledValue12 extends DiagnosticReportStatusu45list { override def toString = "cancelled" }
case object Enteredu45inu45errorValue30 extends DiagnosticReportStatusu45list { override def toString = "entered-in-error" }
case object UnknownValue15 extends DiagnosticReportStatusu45list { override def toString = "unknown" }


/** The status of the diagnostic report as a whole.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DiagnosticReportStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[DiagnosticReportStatusu45list]}
}

      


/** A collection of documents compiled for a purpose together with metadata that applies to the collection.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DocumentManifestType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  masterIdentifier: Option[IdentifierType] = None,
  identifier: Seq[IdentifierType] = Nil,
  status: DocumentReferenceStatus,
  typeValue: Option[CodeableConceptType] = None,
  subject: Option[ReferenceType] = None,
  created: Option[DateTimeType] = None,
  author: Seq[ReferenceType] = Nil,
  recipient: Seq[ReferenceType] = Nil,
  source: Option[UriType] = None,
  description: Option[StringTypeType] = None,
  content: Seq[DocumentManifestu46Content] = Nil,
  related: Seq[DocumentManifestu46Related] = Nil) extends DomainResourcable
      


/** A collection of documents compiled for a purpose together with metadata that applies to the collection.
*/
case class DocumentManifestu46Content(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  pAttachment: Option[AttachmentType] = None,
  pReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A collection of documents compiled for a purpose together with metadata that applies to the collection.
*/
case class DocumentManifestu46Related(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  ref: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A reference to a document.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DocumentReferenceType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  masterIdentifier: Option[IdentifierType] = None,
  identifier: Seq[IdentifierType] = Nil,
  status: DocumentReferenceStatus,
  docStatus: Option[CompositionStatus] = None,
  typeValue: CodeableConceptType,
  classValue: Option[CodeableConceptType] = None,
  subject: Option[ReferenceType] = None,
  created: Option[DateTimeType] = None,
  indexed: InstantType,
  author: Seq[ReferenceType] = Nil,
  authenticator: Option[ReferenceType] = None,
  custodian: Option[ReferenceType] = None,
  relatesTo: Seq[DocumentReferenceu46RelatesTo] = Nil,
  description: Option[StringTypeType] = None,
  securityLabel: Seq[CodeableConceptType] = Nil,
  content: Seq[DocumentReferenceu46Content] = Nil,
  context: Option[DocumentReferenceu46Context] = None) extends DomainResourcable
      


/** A reference to a document.
*/
case class DocumentReferenceu46RelatesTo(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: DocumentRelationshipType,
  target: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A reference to a document.
*/
case class DocumentReferenceu46Content(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  attachment: AttachmentType,
  format: Option[CodingType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A reference to a document.
*/
case class DocumentReferenceu46Context(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  encounter: Option[ReferenceType] = None,
  event: Seq[CodeableConceptType] = Nil,
  period: Option[PeriodType] = None,
  facilityType: Option[CodeableConceptType] = None,
  practiceSetting: Option[CodeableConceptType] = None,
  sourcePatientInfo: Option[ReferenceType] = None,
  related: Seq[DocumentReferenceu46Related] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A reference to a document.
*/
case class DocumentReferenceu46Related(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  ref: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The EligibilityRequest provides patient and insurance coverage information to an insurer for them to respond, in the form of an EligibilityResponse, with information regarding whether the stated coverage is valid and in-force and optionally to provide the insurance details of the policy.If the element is present, it must have either a @value, an @id, or extensions
*/
case class EligibilityRequestType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[FinancialResourceStatusCodes] = None,
  priority: Option[CodeableConceptType] = None,
  patient: Option[ReferenceType] = None,
  servicedDate: Option[DateType] = None,
  servicedPeriod: Option[PeriodType] = None,
  created: Option[DateTimeType] = None,
  enterer: Option[ReferenceType] = None,
  provider: Option[ReferenceType] = None,
  organization: Option[ReferenceType] = None,
  insurer: Option[ReferenceType] = None,
  facility: Option[ReferenceType] = None,
  coverage: Option[ReferenceType] = None,
  businessArrangement: Option[StringTypeType] = None,
  benefitCategory: Option[CodeableConceptType] = None,
  benefitSubCategory: Option[CodeableConceptType] = None) extends DomainResourcable
      


/** This resource provides eligibility and plan details from the processing of an Eligibility resource.If the element is present, it must have either a @value, an @id, or extensions
*/
case class EligibilityResponseType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[FinancialResourceStatusCodes] = None,
  created: Option[DateTimeType] = None,
  requestProvider: Option[ReferenceType] = None,
  requestOrganization: Option[ReferenceType] = None,
  request: Option[ReferenceType] = None,
  outcome: Option[CodeableConceptType] = None,
  disposition: Option[StringTypeType] = None,
  insurer: Option[ReferenceType] = None,
  inforce: Option[BooleanTypeType] = None,
  insurance: Seq[EligibilityResponseu46Insurance] = Nil,
  form: Option[CodeableConceptType] = None,
  error: Seq[EligibilityResponseu46Error] = Nil) extends DomainResourcable
      


/** This resource provides eligibility and plan details from the processing of an Eligibility resource.
*/
case class EligibilityResponseu46Insurance(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  coverage: Option[ReferenceType] = None,
  contract: Option[ReferenceType] = None,
  benefitBalance: Seq[EligibilityResponseu46BenefitBalance] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides eligibility and plan details from the processing of an Eligibility resource.
*/
case class EligibilityResponseu46BenefitBalance(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  category: CodeableConceptType,
  subCategory: Option[CodeableConceptType] = None,
  excluded: Option[BooleanTypeType] = None,
  name: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  network: Option[CodeableConceptType] = None,
  unit: Option[CodeableConceptType] = None,
  term: Option[CodeableConceptType] = None,
  financial: Seq[EligibilityResponseu46Financial] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides eligibility and plan details from the processing of an Eligibility resource.
*/
case class EligibilityResponseu46Financial(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: CodeableConceptType,
  allowedUnsignedInt: Option[UnsignedIntType] = None,
  allowedString: Option[StringTypeType] = None,
  allowedMoney: Option[MoneyType] = None,
  usedUnsignedInt: Option[UnsignedIntType] = None,
  usedMoney: Option[MoneyType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides eligibility and plan details from the processing of an Eligibility resource.
*/
case class EligibilityResponseu46Error(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: CodeableConceptType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.If the element is present, it must have either a @value, an @id, or extensions
*/
case class EncounterType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: EncounterStatus,
  statusHistory: Seq[Encounteru46StatusHistory] = Nil,
  classValue: Option[CodingType] = None,
  classHistory: Seq[Encounteru46ClassHistory] = Nil,
  typeValue: Seq[CodeableConceptType] = Nil,
  priority: Option[CodeableConceptType] = None,
  subject: Option[ReferenceType] = None,
  episodeOfCare: Seq[ReferenceType] = Nil,
  incomingReferral: Seq[ReferenceType] = Nil,
  participant: Seq[Encounteru46Participant] = Nil,
  appointment: Option[ReferenceType] = None,
  period: Option[PeriodType] = None,
  length: Option[DurationType] = None,
  reason: Seq[CodeableConceptType] = Nil,
  diagnosis: Seq[Encounteru46Diagnosis] = Nil,
  account: Seq[ReferenceType] = Nil,
  hospitalization: Option[Encounteru46Hospitalization] = None,
  location: Seq[Encounteru46Location] = Nil,
  serviceProvider: Option[ReferenceType] = None,
  partOf: Option[ReferenceType] = None) extends DomainResourcable
      


/** An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.
*/
case class Encounteru46StatusHistory(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  status: EncounterStatus,
  period: PeriodType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.
*/
case class Encounteru46ClassHistory(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  classValue: CodingType,
  period: PeriodType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.
*/
case class Encounteru46Participant(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: Seq[CodeableConceptType] = Nil,
  period: Option[PeriodType] = None,
  individual: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.
*/
case class Encounteru46Diagnosis(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  condition: ReferenceType,
  role: Option[CodeableConceptType] = None,
  rank: Option[PositiveIntType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.
*/
case class Encounteru46Hospitalization(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  preAdmissionIdentifier: Option[IdentifierType] = None,
  origin: Option[ReferenceType] = None,
  admitSource: Option[CodeableConceptType] = None,
  reAdmission: Option[CodeableConceptType] = None,
  dietPreference: Seq[CodeableConceptType] = Nil,
  specialCourtesy: Seq[CodeableConceptType] = Nil,
  specialArrangement: Seq[CodeableConceptType] = Nil,
  destination: Option[ReferenceType] = None,
  dischargeDisposition: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.
*/
case class Encounteru46Location(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  location: ReferenceType,
  status: Option[EncounterLocationStatus] = None,
  period: Option[PeriodType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait EncounterLocationStatusu45list

object EncounterLocationStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[EncounterLocationStatusu45list]): EncounterLocationStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: EncounterLocationStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[EncounterLocationStatusu45list] = Seq(PlannedValue4, ActiveValue7, Reserved, CompletedValue5)
}

case object PlannedValue4 extends EncounterLocationStatusu45list { override def toString = "planned" }
case object ActiveValue7 extends EncounterLocationStatusu45list { override def toString = "active" }
case object Reserved extends EncounterLocationStatusu45list { override def toString = "reserved" }
case object CompletedValue5 extends EncounterLocationStatusu45list { override def toString = "completed" }


/** The status of the location.If the element is present, it must have either a @value, an @id, or extensions
*/
case class EncounterLocationStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[EncounterLocationStatusu45list]}
}

      

sealed trait EncounterStatusu45list

object EncounterStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[EncounterStatusu45list]): EncounterStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: EncounterStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[EncounterStatusu45list] = Seq(PlannedValue3, Arrived, Triaged, Inu45progressValue4, Onleave, FinishedValue, CancelledValue4, Enteredu45inu45errorValue10, UnknownValue3)
}

case object PlannedValue3 extends EncounterStatusu45list { override def toString = "planned" }
case object Arrived extends EncounterStatusu45list { override def toString = "arrived" }
case object Triaged extends EncounterStatusu45list { override def toString = "triaged" }
case object Inu45progressValue4 extends EncounterStatusu45list { override def toString = "in-progress" }
case object Onleave extends EncounterStatusu45list { override def toString = "onleave" }
case object FinishedValue extends EncounterStatusu45list { override def toString = "finished" }
case object CancelledValue4 extends EncounterStatusu45list { override def toString = "cancelled" }
case object Enteredu45inu45errorValue10 extends EncounterStatusu45list { override def toString = "entered-in-error" }
case object UnknownValue3 extends EncounterStatusu45list { override def toString = "unknown" }


/** Current state of the encounterIf the element is present, it must have either a @value, an @id, or extensions
*/
case class EncounterStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[EncounterStatusu45list]}
}

      


/** The technical details of an endpoint that can be used for electronic services, such as for web services providing XDS.b or a REST endpoint for another FHIR server. This may include any security context information.If the element is present, it must have either a @value, an @id, or extensions
*/
case class EndpointType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: EndpointStatus,
  connectionType: CodingType,
  name: Option[StringTypeType] = None,
  managingOrganization: Option[ReferenceType] = None,
  contact: Seq[ContactPointType] = Nil,
  period: Option[PeriodType] = None,
  payloadType: Seq[CodeableConceptType] = Nil,
  payloadMimeType: Seq[CodeType] = Nil,
  address: UriType,
  header: Seq[StringTypeType] = Nil) extends DomainResourcable
      

sealed trait EndpointStatusu45list

object EndpointStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[EndpointStatusu45list]): EndpointStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: EndpointStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[EndpointStatusu45list] = Seq(ActiveValue19, SuspendedValue7, ErrorValue4, OffValue2, Enteredu45inu45errorValue31, Test)
}

case object ActiveValue19 extends EndpointStatusu45list { override def toString = "active" }
case object SuspendedValue7 extends EndpointStatusu45list { override def toString = "suspended" }
case object ErrorValue4 extends EndpointStatusu45list { override def toString = "error" }
case object OffValue2 extends EndpointStatusu45list { override def toString = "off" }
case object Enteredu45inu45errorValue31 extends EndpointStatusu45list { override def toString = "entered-in-error" }
case object Test extends EndpointStatusu45list { override def toString = "test" }


/** The status of the endpointIf the element is present, it must have either a @value, an @id, or extensions
*/
case class EndpointStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[EndpointStatusu45list]}
}

      


/** This resource provides the insurance enrollment details to the insurer regarding a specified coverage.If the element is present, it must have either a @value, an @id, or extensions
*/
case class EnrollmentRequestType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[FinancialResourceStatusCodes] = None,
  created: Option[DateTimeType] = None,
  insurer: Option[ReferenceType] = None,
  provider: Option[ReferenceType] = None,
  organization: Option[ReferenceType] = None,
  subject: Option[ReferenceType] = None,
  coverage: Option[ReferenceType] = None) extends DomainResourcable
      


/** This resource provides enrollment and plan details from the processing of an Enrollment resource.If the element is present, it must have either a @value, an @id, or extensions
*/
case class EnrollmentResponseType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[FinancialResourceStatusCodes] = None,
  request: Option[ReferenceType] = None,
  outcome: Option[CodeableConceptType] = None,
  disposition: Option[StringTypeType] = None,
  created: Option[DateTimeType] = None,
  organization: Option[ReferenceType] = None,
  requestProvider: Option[ReferenceType] = None,
  requestOrganization: Option[ReferenceType] = None) extends DomainResourcable
      


/** An association between a patient and an organization / healthcare provider(s) during which time encounters may occur. The managing organization assumes a level of responsibility for the patient during this time.If the element is present, it must have either a @value, an @id, or extensions
*/
case class EpisodeOfCareType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: EpisodeOfCareStatus,
  statusHistory: Seq[EpisodeOfCareu46StatusHistory] = Nil,
  typeValue: Seq[CodeableConceptType] = Nil,
  diagnosis: Seq[EpisodeOfCareu46Diagnosis] = Nil,
  patient: ReferenceType,
  managingOrganization: Option[ReferenceType] = None,
  period: Option[PeriodType] = None,
  referralRequest: Seq[ReferenceType] = Nil,
  careManager: Option[ReferenceType] = None,
  team: Seq[ReferenceType] = Nil,
  account: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** An association between a patient and an organization / healthcare provider(s) during which time encounters may occur. The managing organization assumes a level of responsibility for the patient during this time.
*/
case class EpisodeOfCareu46StatusHistory(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  status: EpisodeOfCareStatus,
  period: PeriodType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** An association between a patient and an organization / healthcare provider(s) during which time encounters may occur. The managing organization assumes a level of responsibility for the patient during this time.
*/
case class EpisodeOfCareu46Diagnosis(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  condition: ReferenceType,
  role: Option[CodeableConceptType] = None,
  rank: Option[PositiveIntType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait EpisodeOfCareStatusu45list

object EpisodeOfCareStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[EpisodeOfCareStatusu45list]): EpisodeOfCareStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: EpisodeOfCareStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[EpisodeOfCareStatusu45list] = Seq(PlannedValue2, Waitlist, ActiveValue6, Onhold, Finished, CancelledValue3, Enteredu45inu45errorValue9)
}

case object PlannedValue2 extends EpisodeOfCareStatusu45list { override def toString = "planned" }
case object Waitlist extends EpisodeOfCareStatusu45list { override def toString = "waitlist" }
case object ActiveValue6 extends EpisodeOfCareStatusu45list { override def toString = "active" }
case object Onhold extends EpisodeOfCareStatusu45list { override def toString = "onhold" }
case object Finished extends EpisodeOfCareStatusu45list { override def toString = "finished" }
case object CancelledValue3 extends EpisodeOfCareStatusu45list { override def toString = "cancelled" }
case object Enteredu45inu45errorValue9 extends EpisodeOfCareStatusu45list { override def toString = "entered-in-error" }


/** The status of the episode of care.If the element is present, it must have either a @value, an @id, or extensions
*/
case class EpisodeOfCareStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[EpisodeOfCareStatusu45list]}
}

      


/** Resource to define constraints on the Expansion of a FHIR ValueSet.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ExpansionProfileType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: Option[UriType] = None,
  identifier: Option[IdentifierType] = None,
  version: Option[StringTypeType] = None,
  name: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  description: Option[MarkdownType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  fixedVersion: Seq[ExpansionProfileu46FixedVersion] = Nil,
  excludedSystem: Option[ExpansionProfileu46ExcludedSystem] = None,
  includeDesignations: Option[BooleanTypeType] = None,
  designation: Option[ExpansionProfileu46Designation] = None,
  includeDefinition: Option[BooleanTypeType] = None,
  activeOnly: Option[BooleanTypeType] = None,
  excludeNested: Option[BooleanTypeType] = None,
  excludeNotForUI: Option[BooleanTypeType] = None,
  excludePostCoordinated: Option[BooleanTypeType] = None,
  displayLanguage: Option[CodeType] = None,
  limitedExpansion: Option[BooleanTypeType] = None) extends DomainResourcable
      


/** Resource to define constraints on the Expansion of a FHIR ValueSet.
*/
case class ExpansionProfileu46FixedVersion(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  system: UriType,
  version: StringTypeType,
  mode: SystemVersionProcessingMode,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Resource to define constraints on the Expansion of a FHIR ValueSet.
*/
case class ExpansionProfileu46ExcludedSystem(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  system: UriType,
  version: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Resource to define constraints on the Expansion of a FHIR ValueSet.
*/
case class ExpansionProfileu46Designation(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  include: Option[ExpansionProfileu46Include] = None,
  exclude: Option[ExpansionProfileu46Exclude] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Resource to define constraints on the Expansion of a FHIR ValueSet.
*/
case class ExpansionProfileu46Include(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  designation: Seq[ExpansionProfileu46Designation1] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Resource to define constraints on the Expansion of a FHIR ValueSet.
*/
case class ExpansionProfileu46Designation1(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  language: Option[CodeType] = None,
  use: Option[CodingType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Resource to define constraints on the Expansion of a FHIR ValueSet.
*/
case class ExpansionProfileu46Exclude(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  designation: Seq[ExpansionProfileu46Designation2] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Resource to define constraints on the Expansion of a FHIR ValueSet.
*/
case class ExpansionProfileu46Designation2(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  language: Option[CodeType] = None,
  use: Option[CodingType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait SystemVersionProcessingModeu45list

object SystemVersionProcessingModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[SystemVersionProcessingModeu45list]): SystemVersionProcessingModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SystemVersionProcessingModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SystemVersionProcessingModeu45list] = Seq(Default, Check, Override)
}

case object Default extends SystemVersionProcessingModeu45list { override def toString = "default" }
case object Check extends SystemVersionProcessingModeu45list { override def toString = "check" }
case object Override extends SystemVersionProcessingModeu45list { override def toString = "override" }


/** How to manage the intersection between a fixed version in a value set, and a fixed version of the system in the expansion profileIf the element is present, it must have either a @value, an @id, or extensions
*/
case class SystemVersionProcessingMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[SystemVersionProcessingModeu45list]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ExplanationOfBenefitType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[ExplanationOfBenefitStatus] = None,
  typeValue: Option[CodeableConceptType] = None,
  subType: Seq[CodeableConceptType] = Nil,
  patient: Option[ReferenceType] = None,
  billablePeriod: Option[PeriodType] = None,
  created: Option[DateTimeType] = None,
  enterer: Option[ReferenceType] = None,
  insurer: Option[ReferenceType] = None,
  provider: Option[ReferenceType] = None,
  organization: Option[ReferenceType] = None,
  referral: Option[ReferenceType] = None,
  facility: Option[ReferenceType] = None,
  claim: Option[ReferenceType] = None,
  claimResponse: Option[ReferenceType] = None,
  outcome: Option[CodeableConceptType] = None,
  disposition: Option[StringTypeType] = None,
  related: Seq[ExplanationOfBenefitu46Related] = Nil,
  prescription: Option[ReferenceType] = None,
  originalPrescription: Option[ReferenceType] = None,
  payee: Option[ExplanationOfBenefitu46Payee] = None,
  information: Seq[ExplanationOfBenefitu46Information] = Nil,
  careTeam: Seq[ExplanationOfBenefitu46CareTeam] = Nil,
  diagnosis: Seq[ExplanationOfBenefitu46Diagnosis] = Nil,
  procedure: Seq[ExplanationOfBenefitu46Procedure] = Nil,
  precedence: Option[PositiveIntType] = None,
  insurance: Option[ExplanationOfBenefitu46Insurance] = None,
  accident: Option[ExplanationOfBenefitu46Accident] = None,
  employmentImpacted: Option[PeriodType] = None,
  hospitalization: Option[PeriodType] = None,
  item: Seq[ExplanationOfBenefitu46Item] = Nil,
  addItem: Seq[ExplanationOfBenefitu46AddItem] = Nil,
  totalCost: Option[MoneyType] = None,
  unallocDeductable: Option[MoneyType] = None,
  totalBenefit: Option[MoneyType] = None,
  payment: Option[ExplanationOfBenefitu46Payment] = None,
  form: Option[CodeableConceptType] = None,
  processNote: Seq[ExplanationOfBenefitu46ProcessNote] = Nil,
  benefitBalance: Seq[ExplanationOfBenefitu46BenefitBalance] = Nil) extends DomainResourcable
      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46Related(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  claim: Option[ReferenceType] = None,
  relationship: Option[CodeableConceptType] = None,
  reference: Option[IdentifierType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46Payee(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: Option[CodeableConceptType] = None,
  resourceType: Option[CodeableConceptType] = None,
  party: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46Information(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  category: CodeableConceptType,
  code: Option[CodeableConceptType] = None,
  timingDate: Option[DateType] = None,
  timingPeriod: Option[PeriodType] = None,
  valueString: Option[StringTypeType] = None,
  valueQuantity: Option[Quantityable] = None,
  valueAttachment: Option[AttachmentType] = None,
  valueReference: Option[ReferenceType] = None,
  reason: Option[CodingType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46CareTeam(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  provider: ReferenceType,
  responsible: Option[BooleanTypeType] = None,
  role: Option[CodeableConceptType] = None,
  qualification: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46Diagnosis(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  diagnosisCodeableConcept: Option[CodeableConceptType] = None,
  diagnosisReference: Option[ReferenceType] = None,
  typeValue: Seq[CodeableConceptType] = Nil,
  packageCode: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46Procedure(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  date: Option[DateTimeType] = None,
  procedureCodeableConcept: Option[CodeableConceptType] = None,
  procedureReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46Insurance(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  coverage: Option[ReferenceType] = None,
  preAuthRef: Seq[StringTypeType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46Accident(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  date: Option[DateType] = None,
  typeValue: Option[CodeableConceptType] = None,
  locationAddress: Option[AddressType2] = None,
  locationReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46Item(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  careTeamLinkId: Seq[PositiveIntType] = Nil,
  diagnosisLinkId: Seq[PositiveIntType] = Nil,
  procedureLinkId: Seq[PositiveIntType] = Nil,
  informationLinkId: Seq[PositiveIntType] = Nil,
  revenue: Option[CodeableConceptType] = None,
  category: Option[CodeableConceptType] = None,
  service: Option[CodeableConceptType] = None,
  modifier: Seq[CodeableConceptType] = Nil,
  programCode: Seq[CodeableConceptType] = Nil,
  servicedDate: Option[DateType] = None,
  servicedPeriod: Option[PeriodType] = None,
  locationCodeableConcept: Option[CodeableConceptType] = None,
  locationAddress: Option[AddressType2] = None,
  locationReference: Option[ReferenceType] = None,
  quantity: Option[Quantityable] = None,
  unitPrice: Option[MoneyType] = None,
  factor: Option[DecimalType] = None,
  net: Option[MoneyType] = None,
  udi: Seq[ReferenceType] = Nil,
  bodySite: Option[CodeableConceptType] = None,
  subSite: Seq[CodeableConceptType] = Nil,
  encounter: Seq[ReferenceType] = Nil,
  noteNumber: Seq[PositiveIntType] = Nil,
  adjudication: Seq[ExplanationOfBenefitu46Adjudication] = Nil,
  detail: Seq[ExplanationOfBenefitu46Detail] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46Adjudication(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  category: CodeableConceptType,
  reason: Option[CodeableConceptType] = None,
  amount: Option[MoneyType] = None,
  value: Option[DecimalType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46Detail(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  typeValue: CodeableConceptType,
  revenue: Option[CodeableConceptType] = None,
  category: Option[CodeableConceptType] = None,
  service: Option[CodeableConceptType] = None,
  modifier: Seq[CodeableConceptType] = Nil,
  programCode: Seq[CodeableConceptType] = Nil,
  quantity: Option[Quantityable] = None,
  unitPrice: Option[MoneyType] = None,
  factor: Option[DecimalType] = None,
  net: Option[MoneyType] = None,
  udi: Seq[ReferenceType] = Nil,
  noteNumber: Seq[PositiveIntType] = Nil,
  adjudication: Seq[ExplanationOfBenefitu46Adjudication] = Nil,
  subDetail: Seq[ExplanationOfBenefitu46SubDetail] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46SubDetail(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequence: PositiveIntType,
  typeValue: CodeableConceptType,
  revenue: Option[CodeableConceptType] = None,
  category: Option[CodeableConceptType] = None,
  service: Option[CodeableConceptType] = None,
  modifier: Seq[CodeableConceptType] = Nil,
  programCode: Seq[CodeableConceptType] = Nil,
  quantity: Option[Quantityable] = None,
  unitPrice: Option[MoneyType] = None,
  factor: Option[DecimalType] = None,
  net: Option[MoneyType] = None,
  udi: Seq[ReferenceType] = Nil,
  noteNumber: Seq[PositiveIntType] = Nil,
  adjudication: Seq[ExplanationOfBenefitu46Adjudication] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46AddItem(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequenceLinkId: Seq[PositiveIntType] = Nil,
  revenue: Option[CodeableConceptType] = None,
  category: Option[CodeableConceptType] = None,
  service: Option[CodeableConceptType] = None,
  modifier: Seq[CodeableConceptType] = Nil,
  fee: Option[MoneyType] = None,
  noteNumber: Seq[PositiveIntType] = Nil,
  adjudication: Seq[ExplanationOfBenefitu46Adjudication] = Nil,
  detail: Seq[ExplanationOfBenefitu46Detail1] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46Detail1(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  revenue: Option[CodeableConceptType] = None,
  category: Option[CodeableConceptType] = None,
  service: Option[CodeableConceptType] = None,
  modifier: Seq[CodeableConceptType] = Nil,
  fee: Option[MoneyType] = None,
  noteNumber: Seq[PositiveIntType] = Nil,
  adjudication: Seq[ExplanationOfBenefitu46Adjudication] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46Payment(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: Option[CodeableConceptType] = None,
  adjustment: Option[MoneyType] = None,
  adjustmentReason: Option[CodeableConceptType] = None,
  date: Option[DateType] = None,
  amount: Option[MoneyType] = None,
  identifier: Option[IdentifierType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46ProcessNote(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  number: Option[PositiveIntType] = None,
  typeValue: Option[CodeableConceptType] = None,
  text: Option[StringTypeType] = None,
  language: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46BenefitBalance(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  category: CodeableConceptType,
  subCategory: Option[CodeableConceptType] = None,
  excluded: Option[BooleanTypeType] = None,
  name: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  network: Option[CodeableConceptType] = None,
  unit: Option[CodeableConceptType] = None,
  term: Option[CodeableConceptType] = None,
  financial: Seq[ExplanationOfBenefitu46Financial] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
*/
case class ExplanationOfBenefitu46Financial(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: CodeableConceptType,
  allowedUnsignedInt: Option[UnsignedIntType] = None,
  allowedString: Option[StringTypeType] = None,
  allowedMoney: Option[MoneyType] = None,
  usedUnsignedInt: Option[UnsignedIntType] = None,
  usedMoney: Option[MoneyType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ExplanationOfBenefitStatusu45list

object ExplanationOfBenefitStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ExplanationOfBenefitStatusu45list]): ExplanationOfBenefitStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ExplanationOfBenefitStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ExplanationOfBenefitStatusu45list] = Seq(ActiveValue20, CancelledValue13, DraftValue9, Enteredu45inu45errorValue32)
}

case object ActiveValue20 extends ExplanationOfBenefitStatusu45list { override def toString = "active" }
case object CancelledValue13 extends ExplanationOfBenefitStatusu45list { override def toString = "cancelled" }
case object DraftValue9 extends ExplanationOfBenefitStatusu45list { override def toString = "draft" }
case object Enteredu45inu45errorValue32 extends ExplanationOfBenefitStatusu45list { override def toString = "entered-in-error" }


/** A code specifying the state of the resource instance.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ExplanationOfBenefitStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ExplanationOfBenefitStatusu45list]}
}

      


/** Significant health events and conditions for a person related to the patient relevant in the context of care for the patient.If the element is present, it must have either a @value, an @id, or extensions
*/
case class FamilyMemberHistoryType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  definition: Seq[ReferenceType] = Nil,
  status: FamilyHistoryStatus,
  notDone: Option[BooleanTypeType] = None,
  notDoneReason: Option[CodeableConceptType] = None,
  patient: ReferenceType,
  date: Option[DateTimeType] = None,
  name: Option[StringTypeType] = None,
  relationship: CodeableConceptType,
  gender: Option[AdministrativeGender] = None,
  bornPeriod: Option[PeriodType] = None,
  bornDate: Option[DateType] = None,
  bornString: Option[StringTypeType] = None,
  ageAge: Option[AgeType] = None,
  ageRange: Option[RangeTypeType] = None,
  ageString: Option[StringTypeType] = None,
  estimatedAge: Option[BooleanTypeType] = None,
  deceasedBoolean: Option[BooleanTypeType] = None,
  deceasedAge: Option[AgeType] = None,
  deceasedRange: Option[RangeTypeType] = None,
  deceasedDate: Option[DateType] = None,
  deceasedString: Option[StringTypeType] = None,
  reasonCode: Seq[CodeableConceptType] = Nil,
  reasonReference: Seq[ReferenceType] = Nil,
  note: Seq[AnnotationType] = Nil,
  condition: Seq[FamilyMemberHistoryu46Condition] = Nil) extends DomainResourcable
      


/** Significant health events and conditions for a person related to the patient relevant in the context of care for the patient.
*/
case class FamilyMemberHistoryu46Condition(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: CodeableConceptType,
  outcome: Option[CodeableConceptType] = None,
  onsetAge: Option[AgeType] = None,
  onsetRange: Option[RangeTypeType] = None,
  onsetPeriod: Option[PeriodType] = None,
  onsetString: Option[StringTypeType] = None,
  note: Seq[AnnotationType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait FamilyHistoryStatusu45list

object FamilyHistoryStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[FamilyHistoryStatusu45list]): FamilyHistoryStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: FamilyHistoryStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[FamilyHistoryStatusu45list] = Seq(PartialValue2, CompletedValue12, Enteredu45inu45errorValue33, Healthu45unknown)
}

case object PartialValue2 extends FamilyHistoryStatusu45list { override def toString = "partial" }
case object CompletedValue12 extends FamilyHistoryStatusu45list { override def toString = "completed" }
case object Enteredu45inu45errorValue33 extends FamilyHistoryStatusu45list { override def toString = "entered-in-error" }
case object Healthu45unknown extends FamilyHistoryStatusu45list { override def toString = "health-unknown" }


/** A code that identifies the status of the family history record.If the element is present, it must have either a @value, an @id, or extensions
*/
case class FamilyHistoryStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[FamilyHistoryStatusu45list]}
}

      


/** Prospective warnings of potential issues when providing care to the patient.If the element is present, it must have either a @value, an @id, or extensions
*/
case class FlagType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: FlagStatus,
  category: Option[CodeableConceptType] = None,
  code: CodeableConceptType,
  subject: ReferenceType,
  period: Option[PeriodType] = None,
  encounter: Option[ReferenceType] = None,
  author: Option[ReferenceType] = None) extends DomainResourcable
      

sealed trait FlagStatusu45list

object FlagStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[FlagStatusu45list]): FlagStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: FlagStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[FlagStatusu45list] = Seq(ActiveValue5, InactiveValue, Enteredu45inu45errorValue8)
}

case object ActiveValue5 extends FlagStatusu45list { override def toString = "active" }
case object InactiveValue extends FlagStatusu45list { override def toString = "inactive" }
case object Enteredu45inu45errorValue8 extends FlagStatusu45list { override def toString = "entered-in-error" }


/** Indicates whether this flag is active and needs to be displayed to a user, or whether it is no longer needed or entered in error.If the element is present, it must have either a @value, an @id, or extensions
*/
case class FlagStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[FlagStatusu45list]}
}

      


/** Describes the intended objective(s) for a patient, group or organization care, for example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, etc.If the element is present, it must have either a @value, an @id, or extensions
*/
case class GoalType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: GoalStatus,
  category: Seq[CodeableConceptType] = Nil,
  priority: Option[CodeableConceptType] = None,
  description: CodeableConceptType,
  subject: Option[ReferenceType] = None,
  startDate: Option[DateType] = None,
  startCodeableConcept: Option[CodeableConceptType] = None,
  target: Option[Goalu46Target] = None,
  statusDate: Option[DateType] = None,
  statusReason: Option[StringTypeType] = None,
  expressedBy: Option[ReferenceType] = None,
  addresses: Seq[ReferenceType] = Nil,
  note: Seq[AnnotationType] = Nil,
  outcomeCode: Seq[CodeableConceptType] = Nil,
  outcomeReference: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** Describes the intended objective(s) for a patient, group or organization care, for example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, etc.
*/
case class Goalu46Target(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  measure: Option[CodeableConceptType] = None,
  detailQuantity: Option[Quantityable] = None,
  detailRange: Option[RangeTypeType] = None,
  detailCodeableConcept: Option[CodeableConceptType] = None,
  dueDate: Option[DateType] = None,
  dueDuration: Option[DurationType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait GoalStatusu45list

object GoalStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[GoalStatusu45list]): GoalStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: GoalStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[GoalStatusu45list] = Seq(ProposedValue, Accepted, PlannedValue, Inu45progressValue3, Onu45target, Aheadu45ofu45target, Behindu45target, Sustaining, Achieved, Onu45holdValue3, CancelledValue2, Enteredu45inu45errorValue7, Rejected)
}

case object ProposedValue extends GoalStatusu45list { override def toString = "proposed" }
case object Accepted extends GoalStatusu45list { override def toString = "accepted" }
case object PlannedValue extends GoalStatusu45list { override def toString = "planned" }
case object Inu45progressValue3 extends GoalStatusu45list { override def toString = "in-progress" }
case object Onu45target extends GoalStatusu45list { override def toString = "on-target" }
case object Aheadu45ofu45target extends GoalStatusu45list { override def toString = "ahead-of-target" }
case object Behindu45target extends GoalStatusu45list { override def toString = "behind-target" }
case object Sustaining extends GoalStatusu45list { override def toString = "sustaining" }
case object Achieved extends GoalStatusu45list { override def toString = "achieved" }
case object Onu45holdValue3 extends GoalStatusu45list { override def toString = "on-hold" }
case object CancelledValue2 extends GoalStatusu45list { override def toString = "cancelled" }
case object Enteredu45inu45errorValue7 extends GoalStatusu45list { override def toString = "entered-in-error" }
case object Rejected extends GoalStatusu45list { override def toString = "rejected" }


/** Indicates whether the goal has been met and is still being targetedIf the element is present, it must have either a @value, an @id, or extensions
*/
case class GoalStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[GoalStatusu45list]}
}

      


/** A formal computable definition of a graph of resources - that is, a coherent set of resources that form a graph by following references. The Graph Definition resource defines a set and makes rules about the set.If the element is present, it must have either a @value, an @id, or extensions
*/
case class GraphDefinitionType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: Option[UriType] = None,
  version: Option[StringTypeType] = None,
  name: StringTypeType,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  description: Option[MarkdownType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  purpose: Option[MarkdownType] = None,
  start: ResourceTypeType,
  profile: Option[UriType] = None,
  link: Seq[GraphDefinitionu46Link] = Nil) extends DomainResourcable
      


/** A formal computable definition of a graph of resources - that is, a coherent set of resources that form a graph by following references. The Graph Definition resource defines a set and makes rules about the set.
*/
case class GraphDefinitionu46Link(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  path: StringTypeType,
  sliceName: Option[StringTypeType] = None,
  min: Option[IntegerType] = None,
  max: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  target: Seq[GraphDefinitionu46Target] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A formal computable definition of a graph of resources - that is, a coherent set of resources that form a graph by following references. The Graph Definition resource defines a set and makes rules about the set.
*/
case class GraphDefinitionu46Target(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: ResourceTypeType,
  profile: Option[UriType] = None,
  compartment: Seq[GraphDefinitionu46Compartment] = Nil,
  link: Seq[GraphDefinitionu46Link] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A formal computable definition of a graph of resources - that is, a coherent set of resources that form a graph by following references. The Graph Definition resource defines a set and makes rules about the set.
*/
case class GraphDefinitionu46Compartment(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: CompartmentType,
  rule: GraphCompartmentRule,
  expression: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait GraphCompartmentRuleu45list

object GraphCompartmentRuleu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[GraphCompartmentRuleu45list]): GraphCompartmentRuleu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: GraphCompartmentRuleu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[GraphCompartmentRuleu45list] = Seq(Identical, Matching, Different, Custom)
}

case object Identical extends GraphCompartmentRuleu45list { override def toString = "identical" }
case object Matching extends GraphCompartmentRuleu45list { override def toString = "matching" }
case object Different extends GraphCompartmentRuleu45list { override def toString = "different" }
case object Custom extends GraphCompartmentRuleu45list { override def toString = "custom" }


/** How a compartment must be linkedIf the element is present, it must have either a @value, an @id, or extensions
*/
case class GraphCompartmentRule(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[GraphCompartmentRuleu45list]}
}

      


/** Represents a defined collection of entities that may be discussed or acted upon collectively but which are not expected to act collectively and are not formally or legally recognized; i.e. a collection of entities that isn't an Organization.If the element is present, it must have either a @value, an @id, or extensions
*/
case class GroupType2(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  active: Option[BooleanTypeType] = None,
  typeValue: GroupType,
  actual: BooleanTypeType,
  code: Option[CodeableConceptType] = None,
  name: Option[StringTypeType] = None,
  quantity: Option[UnsignedIntType] = None,
  characteristic: Seq[Groupu46Characteristic] = Nil,
  member: Seq[Groupu46Member] = Nil) extends DomainResourcable
      


/** Represents a defined collection of entities that may be discussed or acted upon collectively but which are not expected to act collectively and are not formally or legally recognized; i.e. a collection of entities that isn't an Organization.
*/
case class Groupu46Characteristic(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: CodeableConceptType,
  valueCodeableConcept: Option[CodeableConceptType] = None,
  valueBoolean: Option[BooleanTypeType] = None,
  valueQuantity: Option[Quantityable] = None,
  valueRange: Option[RangeTypeType] = None,
  exclude: BooleanTypeType,
  period: Option[PeriodType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Represents a defined collection of entities that may be discussed or acted upon collectively but which are not expected to act collectively and are not formally or legally recognized; i.e. a collection of entities that isn't an Organization.
*/
case class Groupu46Member(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  entity: ReferenceType,
  period: Option[PeriodType] = None,
  inactive: Option[BooleanTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait GroupTypeu45list

object GroupTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[GroupTypeu45list]): GroupTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: GroupTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[GroupTypeu45list] = Seq(PersonValue3, Animal, PractitionerValue5, DeviceValue4, MedicationValue4, SubstanceValue3)
}

case object PersonValue3 extends GroupTypeu45list { override def toString = "person" }
case object Animal extends GroupTypeu45list { override def toString = "animal" }
case object PractitionerValue5 extends GroupTypeu45list { override def toString = "practitioner" }
case object DeviceValue4 extends GroupTypeu45list { override def toString = "device" }
case object MedicationValue4 extends GroupTypeu45list { override def toString = "medication" }
case object SubstanceValue3 extends GroupTypeu45list { override def toString = "substance" }


/** Types of resources that are part of groupIf the element is present, it must have either a @value, an @id, or extensions
*/
case class GroupType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[GroupTypeu45list]}
}

      


/** A guidance response is the formal response to a guidance request, including any output parameters returned by the evaluation, as well as the description of any proposed actions to be taken.If the element is present, it must have either a @value, an @id, or extensions
*/
case class GuidanceResponseType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  requestId: Option[IdType] = None,
  identifier: Option[IdentifierType] = None,
  module: ReferenceType,
  status: GuidanceResponseStatus,
  subject: Option[ReferenceType] = None,
  context: Option[ReferenceType] = None,
  occurrenceDateTime: Option[DateTimeType] = None,
  performer: Option[ReferenceType] = None,
  reasonCodeableConcept: Option[CodeableConceptType] = None,
  reasonReference: Option[ReferenceType] = None,
  note: Seq[AnnotationType] = Nil,
  evaluationMessage: Seq[ReferenceType] = Nil,
  outputParameters: Option[ReferenceType] = None,
  result: Option[ReferenceType] = None,
  dataRequirement: Seq[DataRequirementType] = Nil) extends DomainResourcable
      

sealed trait GuidanceResponseStatusu45list

object GuidanceResponseStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[GuidanceResponseStatusu45list]): GuidanceResponseStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: GuidanceResponseStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[GuidanceResponseStatusu45list] = Seq(SuccessType, Datau45requested, Datau45required, Inu45progressValue2, FailureType, Enteredu45inu45errorValue6)
}

case object SuccessType extends GuidanceResponseStatusu45list { override def toString = "success" }
case object Datau45requested extends GuidanceResponseStatusu45list { override def toString = "data-requested" }
case object Datau45required extends GuidanceResponseStatusu45list { override def toString = "data-required" }
case object Inu45progressValue2 extends GuidanceResponseStatusu45list { override def toString = "in-progress" }
case object FailureType extends GuidanceResponseStatusu45list { override def toString = "failure" }
case object Enteredu45inu45errorValue6 extends GuidanceResponseStatusu45list { override def toString = "entered-in-error" }


/** The status of a guidance responseIf the element is present, it must have either a @value, an @id, or extensions
*/
case class GuidanceResponseStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[GuidanceResponseStatusu45list]}
}

      


/** The details of a healthcare service available at a location.If the element is present, it must have either a @value, an @id, or extensions
*/
case class HealthcareServiceType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  active: Option[BooleanTypeType] = None,
  providedBy: Option[ReferenceType] = None,
  category: Option[CodeableConceptType] = None,
  typeValue: Seq[CodeableConceptType] = Nil,
  specialty: Seq[CodeableConceptType] = Nil,
  location: Seq[ReferenceType] = Nil,
  name: Option[StringTypeType] = None,
  comment: Option[StringTypeType] = None,
  extraDetails: Option[StringTypeType] = None,
  photo: Option[AttachmentType] = None,
  telecom: Seq[ContactPointType] = Nil,
  coverageArea: Seq[ReferenceType] = Nil,
  serviceProvisionCode: Seq[CodeableConceptType] = Nil,
  eligibility: Option[CodeableConceptType] = None,
  eligibilityNote: Option[StringTypeType] = None,
  programName: Seq[StringTypeType] = Nil,
  characteristic: Seq[CodeableConceptType] = Nil,
  referralMethod: Seq[CodeableConceptType] = Nil,
  appointmentRequired: Option[BooleanTypeType] = None,
  availableTime: Seq[HealthcareServiceu46AvailableTime] = Nil,
  notAvailable: Seq[HealthcareServiceu46NotAvailable] = Nil,
  availabilityExceptions: Option[StringTypeType] = None,
  endpoint: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** The details of a healthcare service available at a location.
*/
case class HealthcareServiceu46AvailableTime(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  daysOfWeek: Seq[DaysOfWeek] = Nil,
  allDay: Option[BooleanTypeType] = None,
  availableStartTime: Option[TimeType] = None,
  availableEndTime: Option[TimeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The details of a healthcare service available at a location.
*/
case class HealthcareServiceu46NotAvailable(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  description: StringTypeType,
  during: Option[PeriodType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait DaysOfWeeku45list

object DaysOfWeeku45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[DaysOfWeeku45list]): DaysOfWeeku45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DaysOfWeeku45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DaysOfWeeku45list] = Seq(Mon, Tue, Wed, Thu, Fri, Sat, Sun)
}

case object Mon extends DaysOfWeeku45list { override def toString = "mon" }
case object Tue extends DaysOfWeeku45list { override def toString = "tue" }
case object Wed extends DaysOfWeeku45list { override def toString = "wed" }
case object Thu extends DaysOfWeeku45list { override def toString = "thu" }
case object Fri extends DaysOfWeeku45list { override def toString = "fri" }
case object Sat extends DaysOfWeeku45list { override def toString = "sat" }
case object Sun extends DaysOfWeeku45list { override def toString = "sun" }


/** The days of the week.If the element is present, it must have either a @value, an @id, or extensions
*/
case class DaysOfWeek(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[DaysOfWeeku45list]}
}

      


/** A text description of the DICOM SOP instances selected in the ImagingManifest; or the reason for, or significance of, the selection.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ImagingManifestType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  patient: ReferenceType,
  authoringTime: Option[DateTimeType] = None,
  author: Option[ReferenceType] = None,
  description: Option[StringTypeType] = None,
  study: Seq[ImagingManifestu46Study] = Nil) extends DomainResourcable
      


/** A text description of the DICOM SOP instances selected in the ImagingManifest; or the reason for, or significance of, the selection.
*/
case class ImagingManifestu46Study(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  uid: OidType,
  imagingStudy: Option[ReferenceType] = None,
  endpoint: Seq[ReferenceType] = Nil,
  series: Seq[ImagingManifestu46Series] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A text description of the DICOM SOP instances selected in the ImagingManifest; or the reason for, or significance of, the selection.
*/
case class ImagingManifestu46Series(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  uid: OidType,
  endpoint: Seq[ReferenceType] = Nil,
  instance: Seq[ImagingManifestu46Instance] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A text description of the DICOM SOP instances selected in the ImagingManifest; or the reason for, or significance of, the selection.
*/
case class ImagingManifestu46Instance(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sopClass: OidType,
  uid: OidType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Representation of the content produced in a DICOM imaging study. A study comprises a set of series, each of which includes a set of Service-Object Pair Instances (SOP Instances - images or other data) acquired or produced in a common context.  A series is of only one modality (e.g. X-ray, CT, MR, ultrasound), but a study may have multiple series of different modalities.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ImagingStudyType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  uid: OidType,
  accession: Option[IdentifierType] = None,
  identifier: Seq[IdentifierType] = Nil,
  availability: Option[InstanceAvailability] = None,
  modalityList: Seq[CodingType] = Nil,
  patient: ReferenceType,
  context: Option[ReferenceType] = None,
  started: Option[DateTimeType] = None,
  basedOn: Seq[ReferenceType] = Nil,
  referrer: Option[ReferenceType] = None,
  interpreter: Seq[ReferenceType] = Nil,
  endpoint: Seq[ReferenceType] = Nil,
  numberOfSeries: Option[UnsignedIntType] = None,
  numberOfInstances: Option[UnsignedIntType] = None,
  procedureReference: Seq[ReferenceType] = Nil,
  procedureCode: Seq[CodeableConceptType] = Nil,
  reason: Option[CodeableConceptType] = None,
  description: Option[StringTypeType] = None,
  series: Seq[ImagingStudyu46Series] = Nil) extends DomainResourcable
      


/** Representation of the content produced in a DICOM imaging study. A study comprises a set of series, each of which includes a set of Service-Object Pair Instances (SOP Instances - images or other data) acquired or produced in a common context.  A series is of only one modality (e.g. X-ray, CT, MR, ultrasound), but a study may have multiple series of different modalities.
*/
case class ImagingStudyu46Series(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  uid: OidType,
  number: Option[UnsignedIntType] = None,
  modality: CodingType,
  description: Option[StringTypeType] = None,
  numberOfInstances: Option[UnsignedIntType] = None,
  availability: Option[InstanceAvailability] = None,
  endpoint: Seq[ReferenceType] = Nil,
  bodySite: Option[CodingType] = None,
  laterality: Option[CodingType] = None,
  started: Option[DateTimeType] = None,
  performer: Seq[ReferenceType] = Nil,
  instance: Seq[ImagingStudyu46Instance] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Representation of the content produced in a DICOM imaging study. A study comprises a set of series, each of which includes a set of Service-Object Pair Instances (SOP Instances - images or other data) acquired or produced in a common context.  A series is of only one modality (e.g. X-ray, CT, MR, ultrasound), but a study may have multiple series of different modalities.
*/
case class ImagingStudyu46Instance(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  uid: OidType,
  number: Option[UnsignedIntType] = None,
  sopClass: OidType,
  title: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait InstanceAvailabilityu45list

object InstanceAvailabilityu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[InstanceAvailabilityu45list]): InstanceAvailabilityu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: InstanceAvailabilityu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[InstanceAvailabilityu45list] = Seq(ONLINE, OFFLINE, NEARLINE, UNAVAILABLE)
}

case object ONLINE extends InstanceAvailabilityu45list { override def toString = "ONLINE" }
case object OFFLINE extends InstanceAvailabilityu45list { override def toString = "OFFLINE" }
case object NEARLINE extends InstanceAvailabilityu45list { override def toString = "NEARLINE" }
case object UNAVAILABLE extends InstanceAvailabilityu45list { override def toString = "UNAVAILABLE" }


/** Availability of the resourceIf the element is present, it must have either a @value, an @id, or extensions
*/
case class InstanceAvailability(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[InstanceAvailabilityu45list]}
}

      


/** Describes the event of a patient being administered a vaccination or a record of a vaccination as reported by a patient, a clinician or another party and may include vaccine reaction information and what vaccination protocol was followed.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ImmunizationType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: ImmunizationStatusCodes,
  notGiven: BooleanTypeType,
  vaccineCode: CodeableConceptType,
  patient: ReferenceType,
  encounter: Option[ReferenceType] = None,
  date: Option[DateTimeType] = None,
  primarySource: BooleanTypeType,
  reportOrigin: Option[CodeableConceptType] = None,
  location: Option[ReferenceType] = None,
  manufacturer: Option[ReferenceType] = None,
  lotNumber: Option[StringTypeType] = None,
  expirationDate: Option[DateType] = None,
  site: Option[CodeableConceptType] = None,
  route: Option[CodeableConceptType] = None,
  doseQuantity: Option[Quantityable] = None,
  practitioner: Seq[Immunizationu46Practitioner] = Nil,
  note: Seq[AnnotationType] = Nil,
  explanation: Option[Immunizationu46Explanation] = None,
  reaction: Seq[Immunizationu46Reaction] = Nil,
  vaccinationProtocol: Seq[Immunizationu46VaccinationProtocol] = Nil) extends DomainResourcable
      


/** Describes the event of a patient being administered a vaccination or a record of a vaccination as reported by a patient, a clinician or another party and may include vaccine reaction information and what vaccination protocol was followed.
*/
case class Immunizationu46Practitioner(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  role: Option[CodeableConceptType] = None,
  actor: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Describes the event of a patient being administered a vaccination or a record of a vaccination as reported by a patient, a clinician or another party and may include vaccine reaction information and what vaccination protocol was followed.
*/
case class Immunizationu46Explanation(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  reason: Seq[CodeableConceptType] = Nil,
  reasonNotGiven: Seq[CodeableConceptType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Describes the event of a patient being administered a vaccination or a record of a vaccination as reported by a patient, a clinician or another party and may include vaccine reaction information and what vaccination protocol was followed.
*/
case class Immunizationu46Reaction(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  date: Option[DateTimeType] = None,
  detail: Option[ReferenceType] = None,
  reported: Option[BooleanTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Describes the event of a patient being administered a vaccination or a record of a vaccination as reported by a patient, a clinician or another party and may include vaccine reaction information and what vaccination protocol was followed.
*/
case class Immunizationu46VaccinationProtocol(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  doseSequence: Option[PositiveIntType] = None,
  description: Option[StringTypeType] = None,
  authority: Option[ReferenceType] = None,
  series: Option[StringTypeType] = None,
  seriesDoses: Option[PositiveIntType] = None,
  targetDisease: Seq[CodeableConceptType] = Nil,
  doseStatus: CodeableConceptType,
  doseStatusReason: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ImmunizationStatusCodesu45list

object ImmunizationStatusCodesu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ImmunizationStatusCodesu45list]): ImmunizationStatusCodesu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ImmunizationStatusCodesu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ImmunizationStatusCodesu45list] = Seq(CompletedValue13, Enteredu45inu45errorValue34)
}

case object CompletedValue13 extends ImmunizationStatusCodesu45list { override def toString = "completed" }
case object Enteredu45inu45errorValue34 extends ImmunizationStatusCodesu45list { override def toString = "entered-in-error" }


/** A set of codes indicating the current status of an ImmunizationIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ImmunizationStatusCodes(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ImmunizationStatusCodesu45list]}
}

      


/** A patient's point-in-time immunization and recommendation (i.e. forecasting a patient's immunization eligibility according to a published schedule) with optional supporting justification.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ImmunizationRecommendationType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  patient: ReferenceType,
  recommendation: Seq[ImmunizationRecommendationu46Recommendation] = Nil) extends DomainResourcable
      


/** A patient's point-in-time immunization and recommendation (i.e. forecasting a patient's immunization eligibility according to a published schedule) with optional supporting justification.
*/
case class ImmunizationRecommendationu46Recommendation(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  date: DateTimeType,
  vaccineCode: Option[CodeableConceptType] = None,
  targetDisease: Option[CodeableConceptType] = None,
  doseNumber: Option[PositiveIntType] = None,
  forecastStatus: CodeableConceptType,
  dateCriterion: Seq[ImmunizationRecommendationu46DateCriterion] = Nil,
  protocol: Option[ImmunizationRecommendationu46Protocol] = None,
  supportingImmunization: Seq[ReferenceType] = Nil,
  supportingPatientInformation: Seq[ReferenceType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A patient's point-in-time immunization and recommendation (i.e. forecasting a patient's immunization eligibility according to a published schedule) with optional supporting justification.
*/
case class ImmunizationRecommendationu46DateCriterion(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: CodeableConceptType,
  value: DateTimeType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A patient's point-in-time immunization and recommendation (i.e. forecasting a patient's immunization eligibility according to a published schedule) with optional supporting justification.
*/
case class ImmunizationRecommendationu46Protocol(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  doseSequence: Option[PositiveIntType] = None,
  description: Option[StringTypeType] = None,
  authority: Option[ReferenceType] = None,
  series: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A set of rules of how FHIR is used to solve a particular problem. This resource is used to gather all the parts of an implementation guide into a logical whole and to publish a computable definition of all the parts.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ImplementationGuideType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: UriType,
  version: Option[StringTypeType] = None,
  name: StringTypeType,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  description: Option[MarkdownType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  copyright: Option[MarkdownType] = None,
  fhirVersion: Option[IdType] = None,
  dependency: Seq[ImplementationGuideu46Dependency] = Nil,
  packageValue: Seq[ImplementationGuideu46Package] = Nil,
  global: Seq[ImplementationGuideu46Global] = Nil,
  binary: Seq[UriType] = Nil,
  page: Option[ImplementationGuideu46Page] = None) extends DomainResourcable
      


/** A set of rules of how FHIR is used to solve a particular problem. This resource is used to gather all the parts of an implementation guide into a logical whole and to publish a computable definition of all the parts.
*/
case class ImplementationGuideu46Dependency(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: GuideDependencyType,
  uri: UriType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A set of rules of how FHIR is used to solve a particular problem. This resource is used to gather all the parts of an implementation guide into a logical whole and to publish a computable definition of all the parts.
*/
case class ImplementationGuideu46Package(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: StringTypeType,
  description: Option[StringTypeType] = None,
  resource: Seq[ImplementationGuideu46Resource] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A set of rules of how FHIR is used to solve a particular problem. This resource is used to gather all the parts of an implementation guide into a logical whole and to publish a computable definition of all the parts.
*/
case class ImplementationGuideu46Resource(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  example: BooleanTypeType,
  name: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  acronym: Option[StringTypeType] = None,
  sourceUri: Option[UriType] = None,
  sourceReference: Option[ReferenceType] = None,
  exampleFor: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A set of rules of how FHIR is used to solve a particular problem. This resource is used to gather all the parts of an implementation guide into a logical whole and to publish a computable definition of all the parts.
*/
case class ImplementationGuideu46Global(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: ResourceTypeType,
  profile: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A set of rules of how FHIR is used to solve a particular problem. This resource is used to gather all the parts of an implementation guide into a logical whole and to publish a computable definition of all the parts.
*/
case class ImplementationGuideu46Page(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  source: UriType,
  title: StringTypeType,
  kind: GuidePageKind,
  typeValue: Seq[ResourceTypeType] = Nil,
  packageValue: Seq[StringTypeType] = Nil,
  format: Option[CodeType] = None,
  page: Seq[ImplementationGuideu46Page] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait GuideDependencyTypeu45list

object GuideDependencyTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[GuideDependencyTypeu45list]): GuideDependencyTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: GuideDependencyTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[GuideDependencyTypeu45list] = Seq(ReferenceValue5, Inclusion)
}

case object ReferenceValue5 extends GuideDependencyTypeu45list { override def toString = "reference" }
case object Inclusion extends GuideDependencyTypeu45list { override def toString = "inclusion" }


/** How a dependency is represented when the guide is published.If the element is present, it must have either a @value, an @id, or extensions
*/
case class GuideDependencyType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[GuideDependencyTypeu45list]}
}

      

sealed trait GuidePageKindu45list

object GuidePageKindu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[GuidePageKindu45list]): GuidePageKindu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: GuidePageKindu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[GuidePageKindu45list] = Seq(Page, ExampleValue2, ListTypeValue3, IncludeValue, Directory, Dictionary, Toc, ResourceValue3)
}

case object Page extends GuidePageKindu45list { override def toString = "page" }
case object ExampleValue2 extends GuidePageKindu45list { override def toString = "example" }
case object ListTypeValue3 extends GuidePageKindu45list { override def toString = "list" }
case object IncludeValue extends GuidePageKindu45list { override def toString = "include" }
case object Directory extends GuidePageKindu45list { override def toString = "directory" }
case object Dictionary extends GuidePageKindu45list { override def toString = "dictionary" }
case object Toc extends GuidePageKindu45list { override def toString = "toc" }
case object ResourceValue3 extends GuidePageKindu45list { override def toString = "resource" }


/** The kind of an included page.If the element is present, it must have either a @value, an @id, or extensions
*/
case class GuidePageKind(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[GuidePageKindu45list]}
}

      


/** The Library resource is a general-purpose container for knowledge asset definitions. It can be used to describe and expose existing knowledge assets such as logic libraries and information model descriptions, as well as to describe a collection of knowledge assets.If the element is present, it must have either a @value, an @id, or extensions
*/
case class LibraryType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: Option[UriType] = None,
  identifier: Seq[IdentifierType] = Nil,
  version: Option[StringTypeType] = None,
  name: Option[StringTypeType] = None,
  title: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  typeValue: CodeableConceptType,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  description: Option[MarkdownType] = None,
  purpose: Option[MarkdownType] = None,
  usage: Option[StringTypeType] = None,
  approvalDate: Option[DateType] = None,
  lastReviewDate: Option[DateType] = None,
  effectivePeriod: Option[PeriodType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  topic: Seq[CodeableConceptType] = Nil,
  contributor: Seq[ContributorType2] = Nil,
  contact: Seq[ContactDetailType] = Nil,
  copyright: Option[MarkdownType] = None,
  relatedArtifact: Seq[RelatedArtifactType] = Nil,
  parameter: Seq[ParameterDefinitionType] = Nil,
  dataRequirement: Seq[DataRequirementType] = Nil,
  content: Seq[AttachmentType] = Nil) extends DomainResourcable
      


/** Identifies two or more records (resource instances) that are referring to the same real-world "occurrence".If the element is present, it must have either a @value, an @id, or extensions
*/
case class LinkageType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  active: Option[BooleanTypeType] = None,
  author: Option[ReferenceType] = None,
  item: Seq[Linkageu46Item] = Nil) extends DomainResourcable
      


/** Identifies two or more records (resource instances) that are referring to the same real-world "occurrence".
*/
case class Linkageu46Item(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: LinkageTypeType,
  resource: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait LinkageTypeu45list

object LinkageTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[LinkageTypeu45list]): LinkageTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: LinkageTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[LinkageTypeu45list] = Seq(SourceValue3, Alternate, Historical)
}

case object SourceValue3 extends LinkageTypeu45list { override def toString = "source" }
case object Alternate extends LinkageTypeu45list { override def toString = "alternate" }
case object Historical extends LinkageTypeu45list { override def toString = "historical" }


/** Used to distinguish different roles a resource can play within a set of linked resourcesIf the element is present, it must have either a @value, an @id, or extensions
*/
case class LinkageTypeType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[LinkageTypeu45list]}
}

      


/** A set of information summarized from a list of other resources.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ListTypeType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: ListStatus,
  mode: ListMode,
  title: Option[StringTypeType] = None,
  code: Option[CodeableConceptType] = None,
  subject: Option[ReferenceType] = None,
  encounter: Option[ReferenceType] = None,
  date: Option[DateTimeType] = None,
  source: Option[ReferenceType] = None,
  orderedBy: Option[CodeableConceptType] = None,
  note: Seq[AnnotationType] = Nil,
  entry: Seq[Listu46Entry] = Nil,
  emptyReason: Option[CodeableConceptType] = None) extends DomainResourcable
      


/** A set of information summarized from a list of other resources.
*/
case class Listu46Entry(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  flag: Option[CodeableConceptType] = None,
  deleted: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  item: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ListStatusu45list

object ListStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ListStatusu45list]): ListStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ListStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ListStatusu45list] = Seq(Current, Retired, Enteredu45inu45errorValue5)
}

case object Current extends ListStatusu45list { override def toString = "current" }
case object Retired extends ListStatusu45list { override def toString = "retired" }
case object Enteredu45inu45errorValue5 extends ListStatusu45list { override def toString = "entered-in-error" }


/** The current state of the listIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ListStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ListStatusu45list]}
}

      


/** Details and position information for a physical place where services are provided  and resources and participants may be stored, found, contained or accommodated.If the element is present, it must have either a @value, an @id, or extensions
*/
case class LocationType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[LocationStatus] = None,
  operationalStatus: Option[CodingType] = None,
  name: Option[StringTypeType] = None,
  alias: Seq[StringTypeType] = Nil,
  description: Option[StringTypeType] = None,
  mode: Option[LocationMode] = None,
  typeValue: Option[CodeableConceptType] = None,
  telecom: Seq[ContactPointType] = Nil,
  address: Option[AddressType2] = None,
  physicalType: Option[CodeableConceptType] = None,
  position: Option[Locationu46Position] = None,
  managingOrganization: Option[ReferenceType] = None,
  partOf: Option[ReferenceType] = None,
  endpoint: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** Details and position information for a physical place where services are provided  and resources and participants may be stored, found, contained or accommodated.
*/
case class Locationu46Position(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  longitude: DecimalType,
  latitude: DecimalType,
  altitude: Option[DecimalType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait LocationModeu45list

object LocationModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[LocationModeu45list]): LocationModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: LocationModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[LocationModeu45list] = Seq(Instance, Kind)
}

case object Instance extends LocationModeu45list { override def toString = "instance" }
case object Kind extends LocationModeu45list { override def toString = "kind" }


/** Indicates whether a resource instance represents a specific location or a class of locations.If the element is present, it must have either a @value, an @id, or extensions
*/
case class LocationMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[LocationModeu45list]}
}

      

sealed trait LocationStatusu45list

object LocationStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[LocationStatusu45list]): LocationStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: LocationStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[LocationStatusu45list] = Seq(ActiveValue4, SuspendedValue2, Inactive)
}

case object ActiveValue4 extends LocationStatusu45list { override def toString = "active" }
case object SuspendedValue2 extends LocationStatusu45list { override def toString = "suspended" }
case object Inactive extends LocationStatusu45list { override def toString = "inactive" }


/** Indicates whether the location is still in use.If the element is present, it must have either a @value, an @id, or extensions
*/
case class LocationStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[LocationStatusu45list]}
}

      


/** The Measure resource provides the definition of a quality measure.If the element is present, it must have either a @value, an @id, or extensions
*/
case class MeasureType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: Option[UriType] = None,
  identifier: Seq[IdentifierType] = Nil,
  version: Option[StringTypeType] = None,
  name: Option[StringTypeType] = None,
  title: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  description: Option[MarkdownType] = None,
  purpose: Option[MarkdownType] = None,
  usage: Option[StringTypeType] = None,
  approvalDate: Option[DateType] = None,
  lastReviewDate: Option[DateType] = None,
  effectivePeriod: Option[PeriodType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  topic: Seq[CodeableConceptType] = Nil,
  contributor: Seq[ContributorType2] = Nil,
  contact: Seq[ContactDetailType] = Nil,
  copyright: Option[MarkdownType] = None,
  relatedArtifact: Seq[RelatedArtifactType] = Nil,
  library: Seq[ReferenceType] = Nil,
  disclaimer: Option[MarkdownType] = None,
  scoring: Option[CodeableConceptType] = None,
  compositeScoring: Option[CodeableConceptType] = None,
  typeValue: Seq[CodeableConceptType] = Nil,
  riskAdjustment: Option[StringTypeType] = None,
  rateAggregation: Option[StringTypeType] = None,
  rationale: Option[MarkdownType] = None,
  clinicalRecommendationStatement: Option[MarkdownType] = None,
  improvementNotation: Option[StringTypeType] = None,
  definition: Seq[MarkdownType] = Nil,
  guidance: Option[MarkdownType] = None,
  set: Option[StringTypeType] = None,
  group: Seq[Measureu46Group] = Nil,
  supplementalData: Seq[Measureu46SupplementalData] = Nil) extends DomainResourcable
      


/** The Measure resource provides the definition of a quality measure.
*/
case class Measureu46Group(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: IdentifierType,
  name: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  population: Seq[Measureu46Population] = Nil,
  stratifier: Seq[Measureu46Stratifier] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The Measure resource provides the definition of a quality measure.
*/
case class Measureu46Population(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  code: Option[CodeableConceptType] = None,
  name: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  criteria: StringTypeType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The Measure resource provides the definition of a quality measure.
*/
case class Measureu46Stratifier(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  criteria: Option[StringTypeType] = None,
  path: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The Measure resource provides the definition of a quality measure.
*/
case class Measureu46SupplementalData(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  usage: Seq[CodeableConceptType] = Nil,
  criteria: Option[StringTypeType] = None,
  path: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The MeasureReport resource contains the results of evaluating a measure.If the element is present, it must have either a @value, an @id, or extensions
*/
case class MeasureReportType2(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  status: MeasureReportStatus,
  typeValue: MeasureReportType,
  measure: ReferenceType,
  patient: Option[ReferenceType] = None,
  date: Option[DateTimeType] = None,
  reportingOrganization: Option[ReferenceType] = None,
  period: PeriodType,
  group: Seq[MeasureReportu46Group] = Nil,
  evaluatedResources: Option[ReferenceType] = None) extends DomainResourcable
      


/** The MeasureReport resource contains the results of evaluating a measure.
*/
case class MeasureReportu46Group(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: IdentifierType,
  population: Seq[MeasureReportu46Population] = Nil,
  measureScore: Option[DecimalType] = None,
  stratifier: Seq[MeasureReportu46Stratifier] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The MeasureReport resource contains the results of evaluating a measure.
*/
case class MeasureReportu46Population(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  code: Option[CodeableConceptType] = None,
  count: Option[IntegerType] = None,
  patients: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The MeasureReport resource contains the results of evaluating a measure.
*/
case class MeasureReportu46Stratifier(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  stratum: Seq[MeasureReportu46Stratum] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The MeasureReport resource contains the results of evaluating a measure.
*/
case class MeasureReportu46Stratum(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  value: StringTypeType,
  population: Seq[MeasureReportu46Population1] = Nil,
  measureScore: Option[DecimalType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The MeasureReport resource contains the results of evaluating a measure.
*/
case class MeasureReportu46Population1(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  code: Option[CodeableConceptType] = None,
  count: Option[IntegerType] = None,
  patients: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait MeasureReportStatusu45list

object MeasureReportStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[MeasureReportStatusu45list]): MeasureReportStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MeasureReportStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[MeasureReportStatusu45list] = Seq(CompleteValue3, PendingValue, ErrorValue5)
}

case object CompleteValue3 extends MeasureReportStatusu45list { override def toString = "complete" }
case object PendingValue extends MeasureReportStatusu45list { override def toString = "pending" }
case object ErrorValue5 extends MeasureReportStatusu45list { override def toString = "error" }


/** The status of the measure reportIf the element is present, it must have either a @value, an @id, or extensions
*/
case class MeasureReportStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[MeasureReportStatusu45list]}
}

      

sealed trait MeasureReportTypeu45list

object MeasureReportTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[MeasureReportTypeu45list]): MeasureReportTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MeasureReportTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[MeasureReportTypeu45list] = Seq(Individual, Patientu45list, Summary)
}

case object Individual extends MeasureReportTypeu45list { override def toString = "individual" }
case object Patientu45list extends MeasureReportTypeu45list { override def toString = "patient-list" }
case object Summary extends MeasureReportTypeu45list { override def toString = "summary" }


/** The type of the measure reportIf the element is present, it must have either a @value, an @id, or extensions
*/
case class MeasureReportType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[MeasureReportTypeu45list]}
}

      


/** A photo, video, or audio recording acquired or used in healthcare. The actual content may be inline or provided by direct reference.If the element is present, it must have either a @value, an @id, or extensions
*/
case class MediaType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  basedOn: Seq[ReferenceType] = Nil,
  typeValue: DigitalMediaType,
  subtype: Option[CodeableConceptType] = None,
  view: Option[CodeableConceptType] = None,
  subject: Option[ReferenceType] = None,
  context: Option[ReferenceType] = None,
  occurrenceDateTime: Option[DateTimeType] = None,
  occurrencePeriod: Option[PeriodType] = None,
  operator: Option[ReferenceType] = None,
  reasonCode: Seq[CodeableConceptType] = Nil,
  bodySite: Option[CodeableConceptType] = None,
  device: Option[ReferenceType] = None,
  height: Option[PositiveIntType] = None,
  width: Option[PositiveIntType] = None,
  frames: Option[PositiveIntType] = None,
  duration: Option[UnsignedIntType] = None,
  content: AttachmentType,
  note: Seq[AnnotationType] = Nil) extends DomainResourcable
      

sealed trait DigitalMediaTypeu45list

object DigitalMediaTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[DigitalMediaTypeu45list]): DigitalMediaTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DigitalMediaTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[DigitalMediaTypeu45list] = Seq(Photo, Video, Audio)
}

case object Photo extends DigitalMediaTypeu45list { override def toString = "photo" }
case object Video extends DigitalMediaTypeu45list { override def toString = "video" }
case object Audio extends DigitalMediaTypeu45list { override def toString = "audio" }


/** Whether the media is a photo, video, or audioIf the element is present, it must have either a @value, an @id, or extensions
*/
case class DigitalMediaType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[DigitalMediaTypeu45list]}
}

      


/** This resource is primarily used for the identification and definition of a medication. It covers the ingredients and the packaging for a medication.If the element is present, it must have either a @value, an @id, or extensions
*/
case class MedicationType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: Option[CodeableConceptType] = None,
  status: Option[MedicationStatus] = None,
  isBrand: Option[BooleanTypeType] = None,
  isOverTheCounter: Option[BooleanTypeType] = None,
  manufacturer: Option[ReferenceType] = None,
  form: Option[CodeableConceptType] = None,
  ingredient: Seq[Medicationu46Ingredient] = Nil,
  packageValue: Option[Medicationu46Package] = None,
  image: Seq[AttachmentType] = Nil) extends DomainResourcable
      


/** This resource is primarily used for the identification and definition of a medication. It covers the ingredients and the packaging for a medication.
*/
case class Medicationu46Ingredient(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  itemCodeableConcept: Option[CodeableConceptType] = None,
  itemReference: Option[ReferenceType] = None,
  isActive: Option[BooleanTypeType] = None,
  amount: Option[RatioType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource is primarily used for the identification and definition of a medication. It covers the ingredients and the packaging for a medication.
*/
case class Medicationu46Package(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  container: Option[CodeableConceptType] = None,
  content: Seq[Medicationu46Content] = Nil,
  batch: Seq[Medicationu46Batch] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource is primarily used for the identification and definition of a medication. It covers the ingredients and the packaging for a medication.
*/
case class Medicationu46Content(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  itemCodeableConcept: Option[CodeableConceptType] = None,
  itemReference: Option[ReferenceType] = None,
  amount: Option[Quantityable] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource is primarily used for the identification and definition of a medication. It covers the ingredients and the packaging for a medication.
*/
case class Medicationu46Batch(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  lotNumber: Option[StringTypeType] = None,
  expirationDate: Option[DateTimeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait MedicationStatusu45list

object MedicationStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[MedicationStatusu45list]): MedicationStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MedicationStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[MedicationStatusu45list] = Seq(ActiveValue21, InactiveValue8, Enteredu45inu45errorValue35)
}

case object ActiveValue21 extends MedicationStatusu45list { override def toString = "active" }
case object InactiveValue8 extends MedicationStatusu45list { override def toString = "inactive" }
case object Enteredu45inu45errorValue35 extends MedicationStatusu45list { override def toString = "entered-in-error" }


/** A coded concept defining if the medication is in active useIf the element is present, it must have either a @value, an @id, or extensions
*/
case class MedicationStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[MedicationStatusu45list]}
}

      


/** Describes the event of a patient consuming or otherwise being administered a medication.  This may be as simple as swallowing a tablet or it may be a long running infusion.  Related resources tie this event to the authorizing prescription, and the specific encounter between patient and health care practitioner.If the element is present, it must have either a @value, an @id, or extensions
*/
case class MedicationAdministrationType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  definition: Seq[ReferenceType] = Nil,
  partOf: Seq[ReferenceType] = Nil,
  status: MedicationAdministrationStatus,
  category: Option[CodeableConceptType] = None,
  medicationCodeableConcept: Option[CodeableConceptType] = None,
  medicationReference: Option[ReferenceType] = None,
  subject: ReferenceType,
  context: Option[ReferenceType] = None,
  supportingInformation: Seq[ReferenceType] = Nil,
  effectiveDateTime: Option[DateTimeType] = None,
  effectivePeriod: Option[PeriodType] = None,
  performer: Seq[MedicationAdministrationu46Performer] = Nil,
  notGiven: Option[BooleanTypeType] = None,
  reasonNotGiven: Seq[CodeableConceptType] = Nil,
  reasonCode: Seq[CodeableConceptType] = Nil,
  reasonReference: Seq[ReferenceType] = Nil,
  prescription: Option[ReferenceType] = None,
  device: Seq[ReferenceType] = Nil,
  note: Seq[AnnotationType] = Nil,
  dosage: Option[MedicationAdministrationu46Dosage] = None,
  eventHistory: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** Describes the event of a patient consuming or otherwise being administered a medication.  This may be as simple as swallowing a tablet or it may be a long running infusion.  Related resources tie this event to the authorizing prescription, and the specific encounter between patient and health care practitioner.
*/
case class MedicationAdministrationu46Performer(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  actor: ReferenceType,
  onBehalfOf: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Describes the event of a patient consuming or otherwise being administered a medication.  This may be as simple as swallowing a tablet or it may be a long running infusion.  Related resources tie this event to the authorizing prescription, and the specific encounter between patient and health care practitioner.
*/
case class MedicationAdministrationu46Dosage(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  text: Option[StringTypeType] = None,
  site: Option[CodeableConceptType] = None,
  route: Option[CodeableConceptType] = None,
  method: Option[CodeableConceptType] = None,
  dose: Option[Quantityable] = None,
  rateRatio: Option[RatioType] = None,
  rateQuantity: Option[Quantityable] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait MedicationAdministrationStatusu45list

object MedicationAdministrationStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[MedicationAdministrationStatusu45list]): MedicationAdministrationStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MedicationAdministrationStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[MedicationAdministrationStatusu45list] = Seq(Inu45progressValue, Onu45holdValue2, CompletedValue4, Enteredu45inu45errorValue4, StoppedValue2, UnknownValue2)
}

case object Inu45progressValue extends MedicationAdministrationStatusu45list { override def toString = "in-progress" }
case object Onu45holdValue2 extends MedicationAdministrationStatusu45list { override def toString = "on-hold" }
case object CompletedValue4 extends MedicationAdministrationStatusu45list { override def toString = "completed" }
case object Enteredu45inu45errorValue4 extends MedicationAdministrationStatusu45list { override def toString = "entered-in-error" }
case object StoppedValue2 extends MedicationAdministrationStatusu45list { override def toString = "stopped" }
case object UnknownValue2 extends MedicationAdministrationStatusu45list { override def toString = "unknown" }


/** A set of codes indicating the current status of a MedicationAdministration.If the element is present, it must have either a @value, an @id, or extensions
*/
case class MedicationAdministrationStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[MedicationAdministrationStatusu45list]}
}

      


/** Indicates that a medication product is to be or has been dispensed for a named person/patient.  This includes a description of the medication product (supply) provided and the instructions for administering the medication.  The medication dispense is the result of a pharmacy system responding to a medication order.If the element is present, it must have either a @value, an @id, or extensions
*/
case class MedicationDispenseType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  partOf: Seq[ReferenceType] = Nil,
  status: Option[MedicationDispenseStatus] = None,
  category: Option[CodeableConceptType] = None,
  medicationCodeableConcept: Option[CodeableConceptType] = None,
  medicationReference: Option[ReferenceType] = None,
  subject: Option[ReferenceType] = None,
  context: Option[ReferenceType] = None,
  supportingInformation: Seq[ReferenceType] = Nil,
  performer: Seq[MedicationDispenseu46Performer] = Nil,
  authorizingPrescription: Seq[ReferenceType] = Nil,
  typeValue: Option[CodeableConceptType] = None,
  quantity: Option[Quantityable] = None,
  daysSupply: Option[Quantityable] = None,
  whenPrepared: Option[DateTimeType] = None,
  whenHandedOver: Option[DateTimeType] = None,
  destination: Option[ReferenceType] = None,
  receiver: Seq[ReferenceType] = Nil,
  note: Seq[AnnotationType] = Nil,
  dosageInstruction: Seq[DosageType] = Nil,
  substitution: Option[MedicationDispenseu46Substitution] = None,
  detectedIssue: Seq[ReferenceType] = Nil,
  notDone: Option[BooleanTypeType] = None,
  notDoneReasonCodeableConcept: Option[CodeableConceptType] = None,
  notDoneReasonReference: Option[ReferenceType] = None,
  eventHistory: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** Indicates that a medication product is to be or has been dispensed for a named person/patient.  This includes a description of the medication product (supply) provided and the instructions for administering the medication.  The medication dispense is the result of a pharmacy system responding to a medication order.
*/
case class MedicationDispenseu46Performer(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  actor: ReferenceType,
  onBehalfOf: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Indicates that a medication product is to be or has been dispensed for a named person/patient.  This includes a description of the medication product (supply) provided and the instructions for administering the medication.  The medication dispense is the result of a pharmacy system responding to a medication order.
*/
case class MedicationDispenseu46Substitution(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  wasSubstituted: BooleanTypeType,
  typeValue: Option[CodeableConceptType] = None,
  reason: Seq[CodeableConceptType] = Nil,
  responsibleParty: Seq[ReferenceType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait MedicationDispenseStatusu45list

object MedicationDispenseStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[MedicationDispenseStatusu45list]): MedicationDispenseStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MedicationDispenseStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[MedicationDispenseStatusu45list] = Seq(PreparationValue, Inu45progressValue7, Onu45holdValue6, CompletedValue14, Enteredu45inu45errorValue36, StoppedValue4)
}

case object PreparationValue extends MedicationDispenseStatusu45list { override def toString = "preparation" }
case object Inu45progressValue7 extends MedicationDispenseStatusu45list { override def toString = "in-progress" }
case object Onu45holdValue6 extends MedicationDispenseStatusu45list { override def toString = "on-hold" }
case object CompletedValue14 extends MedicationDispenseStatusu45list { override def toString = "completed" }
case object Enteredu45inu45errorValue36 extends MedicationDispenseStatusu45list { override def toString = "entered-in-error" }
case object StoppedValue4 extends MedicationDispenseStatusu45list { override def toString = "stopped" }


/** A coded concept specifying the state of the dispense event.If the element is present, it must have either a @value, an @id, or extensions
*/
case class MedicationDispenseStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[MedicationDispenseStatusu45list]}
}

      


/** An order or request for both supply of the medication and the instructions for administration of the medication to a patient. The resource is called "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to generalize the use across inpatient and outpatient settings, including care plans, etc., and to harmonize with workflow patterns.If the element is present, it must have either a @value, an @id, or extensions
*/
case class MedicationRequestType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  definition: Seq[ReferenceType] = Nil,
  basedOn: Seq[ReferenceType] = Nil,
  groupIdentifier: Option[IdentifierType] = None,
  status: Option[MedicationRequestStatus] = None,
  intent: MedicationRequestIntent,
  category: Option[CodeableConceptType] = None,
  priority: Option[MedicationRequestPriority] = None,
  medicationCodeableConcept: Option[CodeableConceptType] = None,
  medicationReference: Option[ReferenceType] = None,
  subject: ReferenceType,
  context: Option[ReferenceType] = None,
  supportingInformation: Seq[ReferenceType] = Nil,
  authoredOn: Option[DateTimeType] = None,
  requester: Option[MedicationRequestu46Requester] = None,
  recorder: Option[ReferenceType] = None,
  reasonCode: Seq[CodeableConceptType] = Nil,
  reasonReference: Seq[ReferenceType] = Nil,
  note: Seq[AnnotationType] = Nil,
  dosageInstruction: Seq[DosageType] = Nil,
  dispenseRequest: Option[MedicationRequestu46DispenseRequest] = None,
  substitution: Option[MedicationRequestu46Substitution] = None,
  priorPrescription: Option[ReferenceType] = None,
  detectedIssue: Seq[ReferenceType] = Nil,
  eventHistory: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** An order or request for both supply of the medication and the instructions for administration of the medication to a patient. The resource is called "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to generalize the use across inpatient and outpatient settings, including care plans, etc., and to harmonize with workflow patterns.
*/
case class MedicationRequestu46Requester(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  agent: ReferenceType,
  onBehalfOf: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** An order or request for both supply of the medication and the instructions for administration of the medication to a patient. The resource is called "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to generalize the use across inpatient and outpatient settings, including care plans, etc., and to harmonize with workflow patterns.
*/
case class MedicationRequestu46DispenseRequest(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  validityPeriod: Option[PeriodType] = None,
  numberOfRepeatsAllowed: Option[PositiveIntType] = None,
  quantity: Option[Quantityable] = None,
  expectedSupplyDuration: Option[DurationType] = None,
  performer: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** An order or request for both supply of the medication and the instructions for administration of the medication to a patient. The resource is called "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to generalize the use across inpatient and outpatient settings, including care plans, etc., and to harmonize with workflow patterns.
*/
case class MedicationRequestu46Substitution(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  allowed: BooleanTypeType,
  reason: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait MedicationRequestStatusu45list

object MedicationRequestStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[MedicationRequestStatusu45list]): MedicationRequestStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MedicationRequestStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[MedicationRequestStatusu45list] = Seq(ActiveValue22, Onu45holdValue7, CancelledValue14, CompletedValue15, Enteredu45inu45errorValue37, StoppedValue5, DraftValue10, UnknownValue16)
}

case object ActiveValue22 extends MedicationRequestStatusu45list { override def toString = "active" }
case object Onu45holdValue7 extends MedicationRequestStatusu45list { override def toString = "on-hold" }
case object CancelledValue14 extends MedicationRequestStatusu45list { override def toString = "cancelled" }
case object CompletedValue15 extends MedicationRequestStatusu45list { override def toString = "completed" }
case object Enteredu45inu45errorValue37 extends MedicationRequestStatusu45list { override def toString = "entered-in-error" }
case object StoppedValue5 extends MedicationRequestStatusu45list { override def toString = "stopped" }
case object DraftValue10 extends MedicationRequestStatusu45list { override def toString = "draft" }
case object UnknownValue16 extends MedicationRequestStatusu45list { override def toString = "unknown" }


/** A coded concept specifying the state of the prescribing event. Describes the lifecycle of the prescriptionIf the element is present, it must have either a @value, an @id, or extensions
*/
case class MedicationRequestStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[MedicationRequestStatusu45list]}
}

      

sealed trait MedicationRequestPriorityu45list

object MedicationRequestPriorityu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[MedicationRequestPriorityu45list]): MedicationRequestPriorityu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MedicationRequestPriorityu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[MedicationRequestPriorityu45list] = Seq(RoutineValue, UrgentValue, StatValue, AsapValue)
}

case object RoutineValue extends MedicationRequestPriorityu45list { override def toString = "routine" }
case object UrgentValue extends MedicationRequestPriorityu45list { override def toString = "urgent" }
case object StatValue extends MedicationRequestPriorityu45list { override def toString = "stat" }
case object AsapValue extends MedicationRequestPriorityu45list { override def toString = "asap" }


/** Identifies the level of importance to be assigned to actioning the requestIf the element is present, it must have either a @value, an @id, or extensions
*/
case class MedicationRequestPriority(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[MedicationRequestPriorityu45list]}
}

      

sealed trait MedicationRequestIntentu45list

object MedicationRequestIntentu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[MedicationRequestIntentu45list]): MedicationRequestIntentu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MedicationRequestIntentu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[MedicationRequestIntentu45list] = Seq(ProposalValue, PlanValue, OrderValue, Instanceu45order)
}

case object ProposalValue extends MedicationRequestIntentu45list { override def toString = "proposal" }
case object PlanValue extends MedicationRequestIntentu45list { override def toString = "plan" }
case object OrderValue extends MedicationRequestIntentu45list { override def toString = "order" }
case object Instanceu45order extends MedicationRequestIntentu45list { override def toString = "instance-order" }


/** The kind of medication orderIf the element is present, it must have either a @value, an @id, or extensions
*/
case class MedicationRequestIntent(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[MedicationRequestIntentu45list]}
}

      


/** A record of a medication that is being consumed by a patient.   A MedicationStatement may indicate that the patient may be taking the medication now, or has taken the medication in the past or will be taking the medication in the future.  The source of this information can be the patient, significant other (such as a family member or spouse), or a clinician.  A common scenario where this information is captured is during the history taking process during a patient visit or stay.   The medication information may come from sources such as the patient's memory, from a prescription bottle,  or from a list of medications the patient, clinician or other party maintains 

The primary difference between a medication statement and a medication administration is that the medication administration has complete administration information and is based on actual administration information from the person who administered the medication.  A medication statement is often, if not always, less specific.  There is no required date/time when the medication was administered, in fact we only know that a source has reported the patient is taking this medication, where details such as time, quantity, or rate or even medication product may be incomplete or missing or less precise.  As stated earlier, the medication statement information may come from the patient's memory, from a prescription bottle or from a list of medications the patient, clinician or other party maintains.  Medication administration is more formal and is not missing detailed information.If the element is present, it must have either a @value, an @id, or extensions
*/
case class MedicationStatementType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  basedOn: Seq[ReferenceType] = Nil,
  partOf: Seq[ReferenceType] = Nil,
  context: Option[ReferenceType] = None,
  status: MedicationStatementStatus,
  category: Option[CodeableConceptType] = None,
  medicationCodeableConcept: Option[CodeableConceptType] = None,
  medicationReference: Option[ReferenceType] = None,
  effectiveDateTime: Option[DateTimeType] = None,
  effectivePeriod: Option[PeriodType] = None,
  dateAsserted: Option[DateTimeType] = None,
  informationSource: Option[ReferenceType] = None,
  subject: ReferenceType,
  derivedFrom: Seq[ReferenceType] = Nil,
  taken: MedicationStatementTaken,
  reasonNotTaken: Seq[CodeableConceptType] = Nil,
  reasonCode: Seq[CodeableConceptType] = Nil,
  reasonReference: Seq[ReferenceType] = Nil,
  note: Seq[AnnotationType] = Nil,
  dosage: Seq[DosageType] = Nil) extends DomainResourcable
      

sealed trait MedicationStatementStatusu45list

object MedicationStatementStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[MedicationStatementStatusu45list]): MedicationStatementStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MedicationStatementStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[MedicationStatementStatusu45list] = Seq(ActiveValue3, CompletedValue3, Enteredu45inu45errorValue3, Intended, StoppedValue, Onu45holdValue)
}

case object ActiveValue3 extends MedicationStatementStatusu45list { override def toString = "active" }
case object CompletedValue3 extends MedicationStatementStatusu45list { override def toString = "completed" }
case object Enteredu45inu45errorValue3 extends MedicationStatementStatusu45list { override def toString = "entered-in-error" }
case object Intended extends MedicationStatementStatusu45list { override def toString = "intended" }
case object StoppedValue extends MedicationStatementStatusu45list { override def toString = "stopped" }
case object Onu45holdValue extends MedicationStatementStatusu45list { override def toString = "on-hold" }


/** A coded concept indicating the current status of a MedicationStatement.If the element is present, it must have either a @value, an @id, or extensions
*/
case class MedicationStatementStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[MedicationStatementStatusu45list]}
}

      

sealed trait MedicationStatementTakenu45list

object MedicationStatementTakenu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[MedicationStatementTakenu45list]): MedicationStatementTakenu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MedicationStatementTakenu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[MedicationStatementTakenu45list] = Seq(Y, N, Unk, Na)
}

case object Y extends MedicationStatementTakenu45list { override def toString = "y" }
case object N extends MedicationStatementTakenu45list { override def toString = "n" }
case object Unk extends MedicationStatementTakenu45list { override def toString = "unk" }
case object Na extends MedicationStatementTakenu45list { override def toString = "na" }


/** A coded concept identifying level of certainty if patient has taken or has not taken the medicationIf the element is present, it must have either a @value, an @id, or extensions
*/
case class MedicationStatementTaken(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[MedicationStatementTakenu45list]}
}

      


/** Defines the characteristics of a message that can be shared between systems, including the type of event that initiates the message, the content to be transmitted and what response(s), if any, are permitted.If the element is present, it must have either a @value, an @id, or extensions
*/
case class MessageDefinitionType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: Option[UriType] = None,
  identifier: Option[IdentifierType] = None,
  version: Option[StringTypeType] = None,
  name: Option[StringTypeType] = None,
  title: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: DateTimeType,
  publisher: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  description: Option[MarkdownType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  purpose: Option[MarkdownType] = None,
  copyright: Option[MarkdownType] = None,
  base: Option[ReferenceType] = None,
  parent: Seq[ReferenceType] = Nil,
  replaces: Seq[ReferenceType] = Nil,
  event: CodingType,
  category: Option[MessageSignificanceCategory] = None,
  focus: Seq[MessageDefinitionu46Focus] = Nil,
  responseRequired: Option[BooleanTypeType] = None,
  allowedResponse: Seq[MessageDefinitionu46AllowedResponse] = Nil) extends DomainResourcable
      


/** Defines the characteristics of a message that can be shared between systems, including the type of event that initiates the message, the content to be transmitted and what response(s), if any, are permitted.
*/
case class MessageDefinitionu46Focus(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: ResourceTypeType,
  profile: Option[ReferenceType] = None,
  min: Option[UnsignedIntType] = None,
  max: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Defines the characteristics of a message that can be shared between systems, including the type of event that initiates the message, the content to be transmitted and what response(s), if any, are permitted.
*/
case class MessageDefinitionu46AllowedResponse(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  message: ReferenceType,
  situation: Option[MarkdownType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The header for a message exchange that is either requesting or responding to an action.  The reference(s) that are the subject of the action as well as other information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle.If the element is present, it must have either a @value, an @id, or extensions
*/
case class MessageHeaderType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  event: CodingType,
  destination: Seq[MessageHeaderu46Destination] = Nil,
  receiver: Option[ReferenceType] = None,
  sender: Option[ReferenceType] = None,
  timestamp: InstantType,
  enterer: Option[ReferenceType] = None,
  author: Option[ReferenceType] = None,
  source: MessageHeaderu46Source,
  responsible: Option[ReferenceType] = None,
  reason: Option[CodeableConceptType] = None,
  response: Option[MessageHeaderu46Response] = None,
  focus: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** The header for a message exchange that is either requesting or responding to an action.  The reference(s) that are the subject of the action as well as other information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle.
*/
case class MessageHeaderu46Destination(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: Option[StringTypeType] = None,
  target: Option[ReferenceType] = None,
  endpoint: UriType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The header for a message exchange that is either requesting or responding to an action.  The reference(s) that are the subject of the action as well as other information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle.
*/
case class MessageHeaderu46Source(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: Option[StringTypeType] = None,
  software: Option[StringTypeType] = None,
  version: Option[StringTypeType] = None,
  contact: Option[ContactPointType] = None,
  endpoint: UriType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** The header for a message exchange that is either requesting or responding to an action.  The reference(s) that are the subject of the action as well as other information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle.
*/
case class MessageHeaderu46Response(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: IdType,
  code: ResponseType,
  details: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ResponseTypeu45list

object ResponseTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ResponseTypeu45list]): ResponseTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ResponseTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ResponseTypeu45list] = Seq(Ok, Transientu45error, Fatalu45error)
}

case object Ok extends ResponseTypeu45list { override def toString = "ok" }
case object Transientu45error extends ResponseTypeu45list { override def toString = "transient-error" }
case object Fatalu45error extends ResponseTypeu45list { override def toString = "fatal-error" }


/** The kind of response to a messageIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ResponseType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ResponseTypeu45list]}
}

      


/** A curated namespace that issues unique symbols within that namespace for the identification of concepts, people, devices, etc.  Represents a "System" used within the Identifier and Coding data types.If the element is present, it must have either a @value, an @id, or extensions
*/
case class NamingSystemType2(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: StringTypeType,
  status: PublicationStatus,
  kind: NamingSystemType,
  date: DateTimeType,
  publisher: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  responsible: Option[StringTypeType] = None,
  typeValue: Option[CodeableConceptType] = None,
  description: Option[MarkdownType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  usage: Option[StringTypeType] = None,
  uniqueId: Seq[NamingSystemu46UniqueId] = Nil,
  replacedBy: Option[ReferenceType] = None) extends DomainResourcable
      


/** A curated namespace that issues unique symbols within that namespace for the identification of concepts, people, devices, etc.  Represents a "System" used within the Identifier and Coding data types.
*/
case class NamingSystemu46UniqueId(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: NamingSystemIdentifierType,
  value: StringTypeType,
  preferred: Option[BooleanTypeType] = None,
  comment: Option[StringTypeType] = None,
  period: Option[PeriodType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait NamingSystemIdentifierTypeu45list

object NamingSystemIdentifierTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[NamingSystemIdentifierTypeu45list]): NamingSystemIdentifierTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: NamingSystemIdentifierTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[NamingSystemIdentifierTypeu45list] = Seq(OidValue2, UuidValue3, UriValue3, OtherValue5)
}

case object OidValue2 extends NamingSystemIdentifierTypeu45list { override def toString = "oid" }
case object UuidValue3 extends NamingSystemIdentifierTypeu45list { override def toString = "uuid" }
case object UriValue3 extends NamingSystemIdentifierTypeu45list { override def toString = "uri" }
case object OtherValue5 extends NamingSystemIdentifierTypeu45list { override def toString = "other" }


/** Identifies the style of unique identifier used to identify a namespace.If the element is present, it must have either a @value, an @id, or extensions
*/
case class NamingSystemIdentifierType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[NamingSystemIdentifierTypeu45list]}
}

      

sealed trait NamingSystemTypeu45list

object NamingSystemTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[NamingSystemTypeu45list]): NamingSystemTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: NamingSystemTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[NamingSystemTypeu45list] = Seq(CodesystemValue3, IdentifierValue2, Root)
}

case object CodesystemValue3 extends NamingSystemTypeu45list { override def toString = "codesystem" }
case object IdentifierValue2 extends NamingSystemTypeu45list { override def toString = "identifier" }
case object Root extends NamingSystemTypeu45list { override def toString = "root" }


/** Identifies the purpose of the naming system.If the element is present, it must have either a @value, an @id, or extensions
*/
case class NamingSystemType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[NamingSystemTypeu45list]}
}

      


/** A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident.If the element is present, it must have either a @value, an @id, or extensions
*/
case class NutritionOrderType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[NutritionOrderStatus] = None,
  patient: ReferenceType,
  encounter: Option[ReferenceType] = None,
  dateTime: DateTimeType,
  orderer: Option[ReferenceType] = None,
  allergyIntolerance: Seq[ReferenceType] = Nil,
  foodPreferenceModifier: Seq[CodeableConceptType] = Nil,
  excludeFoodModifier: Seq[CodeableConceptType] = Nil,
  oralDiet: Option[NutritionOrderu46OralDiet] = None,
  supplement: Seq[NutritionOrderu46Supplement] = Nil,
  enteralFormula: Option[NutritionOrderu46EnteralFormula] = None) extends DomainResourcable
      


/** A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident.
*/
case class NutritionOrderu46OralDiet(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: Seq[CodeableConceptType] = Nil,
  schedule: Seq[TimingType] = Nil,
  nutrient: Seq[NutritionOrderu46Nutrient] = Nil,
  texture: Seq[NutritionOrderu46Texture] = Nil,
  fluidConsistencyType: Seq[CodeableConceptType] = Nil,
  instruction: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident.
*/
case class NutritionOrderu46Nutrient(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  modifier: Option[CodeableConceptType] = None,
  amount: Option[Quantityable] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident.
*/
case class NutritionOrderu46Texture(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  modifier: Option[CodeableConceptType] = None,
  foodType: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident.
*/
case class NutritionOrderu46Supplement(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: Option[CodeableConceptType] = None,
  productName: Option[StringTypeType] = None,
  schedule: Seq[TimingType] = Nil,
  quantity: Option[Quantityable] = None,
  instruction: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident.
*/
case class NutritionOrderu46EnteralFormula(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  baseFormulaType: Option[CodeableConceptType] = None,
  baseFormulaProductName: Option[StringTypeType] = None,
  additiveType: Option[CodeableConceptType] = None,
  additiveProductName: Option[StringTypeType] = None,
  caloricDensity: Option[Quantityable] = None,
  routeofAdministration: Option[CodeableConceptType] = None,
  administration: Seq[NutritionOrderu46Administration] = Nil,
  maxVolumeToDeliver: Option[Quantityable] = None,
  administrationInstruction: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident.
*/
case class NutritionOrderu46Administration(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  schedule: Option[TimingType] = None,
  quantity: Option[Quantityable] = None,
  rateQuantity: Option[Quantityable] = None,
  rateRatio: Option[RatioType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait NutritionOrderStatusu45list

object NutritionOrderStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[NutritionOrderStatusu45list]): NutritionOrderStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: NutritionOrderStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[NutritionOrderStatusu45list] = Seq(Proposed, DraftValue2, Planned, RequestedValue, ActiveValue2, Onu45hold, CompletedValue2, CancelledValue, Enteredu45inu45errorValue2)
}

case object Proposed extends NutritionOrderStatusu45list { override def toString = "proposed" }
case object DraftValue2 extends NutritionOrderStatusu45list { override def toString = "draft" }
case object Planned extends NutritionOrderStatusu45list { override def toString = "planned" }
case object RequestedValue extends NutritionOrderStatusu45list { override def toString = "requested" }
case object ActiveValue2 extends NutritionOrderStatusu45list { override def toString = "active" }
case object Onu45hold extends NutritionOrderStatusu45list { override def toString = "on-hold" }
case object CompletedValue2 extends NutritionOrderStatusu45list { override def toString = "completed" }
case object CancelledValue extends NutritionOrderStatusu45list { override def toString = "cancelled" }
case object Enteredu45inu45errorValue2 extends NutritionOrderStatusu45list { override def toString = "entered-in-error" }


/** Codes specifying the state of the request. Describes the lifecycle of the nutrition order.If the element is present, it must have either a @value, an @id, or extensions
*/
case class NutritionOrderStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[NutritionOrderStatusu45list]}
}

      


/** Measurements and simple assertions made about a patient, device or other subject.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ObservationType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  basedOn: Seq[ReferenceType] = Nil,
  status: ObservationStatus,
  category: Seq[CodeableConceptType] = Nil,
  code: CodeableConceptType,
  subject: Option[ReferenceType] = None,
  context: Option[ReferenceType] = None,
  effectiveDateTime: Option[DateTimeType] = None,
  effectivePeriod: Option[PeriodType] = None,
  issued: Option[InstantType] = None,
  performer: Seq[ReferenceType] = Nil,
  valueQuantity: Option[Quantityable] = None,
  valueCodeableConcept: Option[CodeableConceptType] = None,
  valueString: Option[StringTypeType] = None,
  valueBoolean: Option[BooleanTypeType] = None,
  valueRange: Option[RangeTypeType] = None,
  valueRatio: Option[RatioType] = None,
  valueSampledData: Option[SampledDataType] = None,
  valueAttachment: Option[AttachmentType] = None,
  valueTime: Option[TimeType] = None,
  valueDateTime: Option[DateTimeType] = None,
  valuePeriod: Option[PeriodType] = None,
  dataAbsentReason: Option[CodeableConceptType] = None,
  interpretation: Option[CodeableConceptType] = None,
  comment: Option[StringTypeType] = None,
  bodySite: Option[CodeableConceptType] = None,
  method: Option[CodeableConceptType] = None,
  specimen: Option[ReferenceType] = None,
  device: Option[ReferenceType] = None,
  referenceRange: Seq[Observationu46ReferenceRange] = Nil,
  related: Seq[Observationu46Related] = Nil,
  component: Seq[Observationu46Component] = Nil) extends DomainResourcable
      


/** Measurements and simple assertions made about a patient, device or other subject.
*/
case class Observationu46ReferenceRange(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  low: Option[Quantityable] = None,
  high: Option[Quantityable] = None,
  typeValue: Option[CodeableConceptType] = None,
  appliesTo: Seq[CodeableConceptType] = Nil,
  age: Option[RangeTypeType] = None,
  text: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Measurements and simple assertions made about a patient, device or other subject.
*/
case class Observationu46Related(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: Option[ObservationRelationshipType] = None,
  target: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Measurements and simple assertions made about a patient, device or other subject.
*/
case class Observationu46Component(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: CodeableConceptType,
  valueQuantity: Option[Quantityable] = None,
  valueCodeableConcept: Option[CodeableConceptType] = None,
  valueString: Option[StringTypeType] = None,
  valueRange: Option[RangeTypeType] = None,
  valueRatio: Option[RatioType] = None,
  valueSampledData: Option[SampledDataType] = None,
  valueAttachment: Option[AttachmentType] = None,
  valueTime: Option[TimeType] = None,
  valueDateTime: Option[DateTimeType] = None,
  valuePeriod: Option[PeriodType] = None,
  dataAbsentReason: Option[CodeableConceptType] = None,
  interpretation: Option[CodeableConceptType] = None,
  referenceRange: Seq[Observationu46ReferenceRange] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ObservationRelationshipTypeu45list

object ObservationRelationshipTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ObservationRelationshipTypeu45list]): ObservationRelationshipTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ObservationRelationshipTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ObservationRelationshipTypeu45list] = Seq(Hasu45member, Derivedu45from, Sequelu45to, Replaces, Qualifiedu45by, Interferedu45by)
}

case object Hasu45member extends ObservationRelationshipTypeu45list { override def toString = "has-member" }
case object Derivedu45from extends ObservationRelationshipTypeu45list { override def toString = "derived-from" }
case object Sequelu45to extends ObservationRelationshipTypeu45list { override def toString = "sequel-to" }
case object Replaces extends ObservationRelationshipTypeu45list { override def toString = "replaces" }
case object Qualifiedu45by extends ObservationRelationshipTypeu45list { override def toString = "qualified-by" }
case object Interferedu45by extends ObservationRelationshipTypeu45list { override def toString = "interfered-by" }


/** Codes specifying how two observations are related.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ObservationRelationshipType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ObservationRelationshipTypeu45list]}
}

      


/** A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction).If the element is present, it must have either a @value, an @id, or extensions
*/
case class OperationDefinitionType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: Option[UriType] = None,
  version: Option[StringTypeType] = None,
  name: StringTypeType,
  status: PublicationStatus,
  kind: OperationKind,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  description: Option[MarkdownType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  purpose: Option[MarkdownType] = None,
  idempotent: Option[BooleanTypeType] = None,
  code: CodeType,
  comment: Option[StringTypeType] = None,
  base: Option[ReferenceType] = None,
  resource: Seq[ResourceTypeType] = Nil,
  system: BooleanTypeType,
  typeValue: BooleanTypeType,
  instance: BooleanTypeType,
  parameter: Seq[OperationDefinitionu46Parameter] = Nil,
  overload: Seq[OperationDefinitionu46Overload] = Nil) extends DomainResourcable
      


/** A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction).
*/
case class OperationDefinitionu46Parameter(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: CodeType,
  use: OperationParameterUse,
  min: IntegerType,
  max: StringTypeType,
  documentation: Option[StringTypeType] = None,
  typeValue: Option[FHIRAllTypes] = None,
  searchType: Option[SearchParamType] = None,
  profile: Option[ReferenceType] = None,
  binding: Option[OperationDefinitionu46Binding] = None,
  part: Seq[OperationDefinitionu46Parameter] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction).
*/
case class OperationDefinitionu46Binding(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  strength: BindingStrength,
  valueSetUri: Option[UriType] = None,
  valueSetReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction).
*/
case class OperationDefinitionu46Overload(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  parameterName: Seq[StringTypeType] = Nil,
  comment: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait FHIRAllTypesu45list

object FHIRAllTypesu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[FHIRAllTypesu45list]): FHIRAllTypesu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: FHIRAllTypesu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[FHIRAllTypesu45list] = Seq(AddressValue, AgeValue, AnnotationValue, AttachmentValue2, BackboneElementValue, CodeableConceptValue, CodingValue, ContactDetailValue, ContactPointValue, ContributorValue, CountValue, DataRequirementValue, DistanceValue2, DosageValue, DurationValue, ElementValue, ElementDefinitionValue, ExtensionValue2, HumanNameValue, IdentifierValue, MetaValue, MoneyValue, NarrativeValue, ParameterDefinitionValue, PeriodValue, QuantityValue2, RangeTypeValue, RatioValue, ReferenceValue3, RelatedArtifactValue, SampledDataValue, SignatureValue, SimpleQuantityValue, TimingValue, TriggerDefinitionValue, UsageContextValue, Base64BinaryTypeValue, BooleanTypeValue2, CodeValue, DateValue2, DateTimeValue2, DecimalValue2, IdValue2, InstantValue, IntegerValue2, MarkdownValue, OidValue, PositiveIntValue, StringTypeValue2, TimeValue2, UnsignedIntValue, UriValue, UuidValue2, XhtmlValue, AccountValue, ActivityDefinitionValue, AdverseEventValue, AllergyIntoleranceValue, AppointmentValue, AppointmentResponseValue, AuditEventValue, BasicValue, BinaryValue, BodySiteValue, BundleValue, CapabilityStatementValue, CarePlanValue, CareTeamValue, ChargeItemValue, ClaimValue, ClaimResponseValue, ClinicalImpressionValue, CodeSystemValue, CommunicationValue, CommunicationRequestValue, CompartmentDefinitionValue, CompositionValue, ConceptMapValue, ConditionValue, ConsentValue, ContractValue, CoverageValue, DataElementValue, DetectedIssueValue, DeviceValue, DeviceComponentValue, DeviceMetricValue, DeviceRequestValue, DeviceUseStatementValue, DiagnosticReportValue, DocumentManifestValue, DocumentReferenceValue, DomainResourceValue, EligibilityRequestValue, EligibilityResponseValue, EncounterValue, EndpointValue, EnrollmentRequestValue, EnrollmentResponseValue, EpisodeOfCareValue, ExpansionProfileValue, ExplanationOfBenefitValue, FamilyMemberHistoryValue, FlagValue, GoalValue, GraphDefinitionValue, GroupValue2, GuidanceResponseValue, HealthcareServiceValue, ImagingManifestValue, ImagingStudyValue, ImmunizationValue, ImmunizationRecommendationValue, ImplementationGuideValue, LibraryValue, LinkageValue, ListTypeValue, LocationValue, MeasureValue, MeasureReportValue, MediaValue, MedicationValue, MedicationAdministrationValue, MedicationDispenseValue, MedicationRequestValue, MedicationStatementValue, MessageDefinitionValue, MessageHeaderValue, NamingSystemValue, NutritionOrderValue, ObservationValue, OperationDefinitionValue, OperationOutcomeValue, OrganizationValue, ParametersValue, PatientValue, PaymentNoticeValue, PaymentReconciliationValue, PersonValue, PlanDefinitionValue, PractitionerValue, PractitionerRoleValue, ProcedureValue, ProcedureRequestValue, ProcessRequestValue, ProcessResponseValue, ProvenanceValue, QuestionnaireValue, QuestionnaireResponseValue, ReferralRequestValue, RelatedPersonValue, RequestGroupValue, ResearchStudyValue, ResearchSubjectValue, ResourceValue, RiskAssessmentValue, ScheduleValue, SearchParameterValue, SequenceValue, ServiceDefinitionValue, SlotValue, SpecimenValue, StructureDefinitionValue, StructureMapValue, SubscriptionValue, SubstanceValue, SupplyDeliveryValue, SupplyRequestValue, TaskValue, TestReportValue, TestScriptValue, ValueSetValue2, VisionPrescriptionValue, TypeValue2, AnyType)
}

case object AddressValue extends FHIRAllTypesu45list { override def toString = "Address" }
case object AgeValue extends FHIRAllTypesu45list { override def toString = "Age" }
case object AnnotationValue extends FHIRAllTypesu45list { override def toString = "Annotation" }
case object AttachmentValue2 extends FHIRAllTypesu45list { override def toString = "Attachment" }
case object BackboneElementValue extends FHIRAllTypesu45list { override def toString = "BackboneElement" }
case object CodeableConceptValue extends FHIRAllTypesu45list { override def toString = "CodeableConcept" }
case object CodingValue extends FHIRAllTypesu45list { override def toString = "Coding" }
case object ContactDetailValue extends FHIRAllTypesu45list { override def toString = "ContactDetail" }
case object ContactPointValue extends FHIRAllTypesu45list { override def toString = "ContactPoint" }
case object ContributorValue extends FHIRAllTypesu45list { override def toString = "Contributor" }
case object CountValue extends FHIRAllTypesu45list { override def toString = "Count" }
case object DataRequirementValue extends FHIRAllTypesu45list { override def toString = "DataRequirement" }
case object DistanceValue2 extends FHIRAllTypesu45list { override def toString = "Distance" }
case object DosageValue extends FHIRAllTypesu45list { override def toString = "Dosage" }
case object DurationValue extends FHIRAllTypesu45list { override def toString = "Duration" }
case object ElementValue extends FHIRAllTypesu45list { override def toString = "Element" }
case object ElementDefinitionValue extends FHIRAllTypesu45list { override def toString = "ElementDefinition" }
case object ExtensionValue2 extends FHIRAllTypesu45list { override def toString = "Extension" }
case object HumanNameValue extends FHIRAllTypesu45list { override def toString = "HumanName" }
case object IdentifierValue extends FHIRAllTypesu45list { override def toString = "Identifier" }
case object MetaValue extends FHIRAllTypesu45list { override def toString = "Meta" }
case object MoneyValue extends FHIRAllTypesu45list { override def toString = "Money" }
case object NarrativeValue extends FHIRAllTypesu45list { override def toString = "Narrative" }
case object ParameterDefinitionValue extends FHIRAllTypesu45list { override def toString = "ParameterDefinition" }
case object PeriodValue extends FHIRAllTypesu45list { override def toString = "Period" }
case object QuantityValue2 extends FHIRAllTypesu45list { override def toString = "Quantity" }
case object RangeTypeValue extends FHIRAllTypesu45list { override def toString = "Range" }
case object RatioValue extends FHIRAllTypesu45list { override def toString = "Ratio" }
case object ReferenceValue3 extends FHIRAllTypesu45list { override def toString = "Reference" }
case object RelatedArtifactValue extends FHIRAllTypesu45list { override def toString = "RelatedArtifact" }
case object SampledDataValue extends FHIRAllTypesu45list { override def toString = "SampledData" }
case object SignatureValue extends FHIRAllTypesu45list { override def toString = "Signature" }
case object SimpleQuantityValue extends FHIRAllTypesu45list { override def toString = "SimpleQuantity" }
case object TimingValue extends FHIRAllTypesu45list { override def toString = "Timing" }
case object TriggerDefinitionValue extends FHIRAllTypesu45list { override def toString = "TriggerDefinition" }
case object UsageContextValue extends FHIRAllTypesu45list { override def toString = "UsageContext" }
case object Base64BinaryTypeValue extends FHIRAllTypesu45list { override def toString = "base64Binary" }
case object BooleanTypeValue2 extends FHIRAllTypesu45list { override def toString = "boolean" }
case object CodeValue extends FHIRAllTypesu45list { override def toString = "code" }
case object DateValue2 extends FHIRAllTypesu45list { override def toString = "date" }
case object DateTimeValue2 extends FHIRAllTypesu45list { override def toString = "dateTime" }
case object DecimalValue2 extends FHIRAllTypesu45list { override def toString = "decimal" }
case object IdValue2 extends FHIRAllTypesu45list { override def toString = "id" }
case object InstantValue extends FHIRAllTypesu45list { override def toString = "instant" }
case object IntegerValue2 extends FHIRAllTypesu45list { override def toString = "integer" }
case object MarkdownValue extends FHIRAllTypesu45list { override def toString = "markdown" }
case object OidValue extends FHIRAllTypesu45list { override def toString = "oid" }
case object PositiveIntValue extends FHIRAllTypesu45list { override def toString = "positiveInt" }
case object StringTypeValue2 extends FHIRAllTypesu45list { override def toString = "string" }
case object TimeValue2 extends FHIRAllTypesu45list { override def toString = "time" }
case object UnsignedIntValue extends FHIRAllTypesu45list { override def toString = "unsignedInt" }
case object UriValue extends FHIRAllTypesu45list { override def toString = "uri" }
case object UuidValue2 extends FHIRAllTypesu45list { override def toString = "uuid" }
case object XhtmlValue extends FHIRAllTypesu45list { override def toString = "xhtml" }
case object AccountValue extends FHIRAllTypesu45list { override def toString = "Account" }
case object ActivityDefinitionValue extends FHIRAllTypesu45list { override def toString = "ActivityDefinition" }
case object AdverseEventValue extends FHIRAllTypesu45list { override def toString = "AdverseEvent" }
case object AllergyIntoleranceValue extends FHIRAllTypesu45list { override def toString = "AllergyIntolerance" }
case object AppointmentValue extends FHIRAllTypesu45list { override def toString = "Appointment" }
case object AppointmentResponseValue extends FHIRAllTypesu45list { override def toString = "AppointmentResponse" }
case object AuditEventValue extends FHIRAllTypesu45list { override def toString = "AuditEvent" }
case object BasicValue extends FHIRAllTypesu45list { override def toString = "Basic" }
case object BinaryValue extends FHIRAllTypesu45list { override def toString = "Binary" }
case object BodySiteValue extends FHIRAllTypesu45list { override def toString = "BodySite" }
case object BundleValue extends FHIRAllTypesu45list { override def toString = "Bundle" }
case object CapabilityStatementValue extends FHIRAllTypesu45list { override def toString = "CapabilityStatement" }
case object CarePlanValue extends FHIRAllTypesu45list { override def toString = "CarePlan" }
case object CareTeamValue extends FHIRAllTypesu45list { override def toString = "CareTeam" }
case object ChargeItemValue extends FHIRAllTypesu45list { override def toString = "ChargeItem" }
case object ClaimValue extends FHIRAllTypesu45list { override def toString = "Claim" }
case object ClaimResponseValue extends FHIRAllTypesu45list { override def toString = "ClaimResponse" }
case object ClinicalImpressionValue extends FHIRAllTypesu45list { override def toString = "ClinicalImpression" }
case object CodeSystemValue extends FHIRAllTypesu45list { override def toString = "CodeSystem" }
case object CommunicationValue extends FHIRAllTypesu45list { override def toString = "Communication" }
case object CommunicationRequestValue extends FHIRAllTypesu45list { override def toString = "CommunicationRequest" }
case object CompartmentDefinitionValue extends FHIRAllTypesu45list { override def toString = "CompartmentDefinition" }
case object CompositionValue extends FHIRAllTypesu45list { override def toString = "Composition" }
case object ConceptMapValue extends FHIRAllTypesu45list { override def toString = "ConceptMap" }
case object ConditionValue extends FHIRAllTypesu45list { override def toString = "Condition" }
case object ConsentValue extends FHIRAllTypesu45list { override def toString = "Consent" }
case object ContractValue extends FHIRAllTypesu45list { override def toString = "Contract" }
case object CoverageValue extends FHIRAllTypesu45list { override def toString = "Coverage" }
case object DataElementValue extends FHIRAllTypesu45list { override def toString = "DataElement" }
case object DetectedIssueValue extends FHIRAllTypesu45list { override def toString = "DetectedIssue" }
case object DeviceValue extends FHIRAllTypesu45list { override def toString = "Device" }
case object DeviceComponentValue extends FHIRAllTypesu45list { override def toString = "DeviceComponent" }
case object DeviceMetricValue extends FHIRAllTypesu45list { override def toString = "DeviceMetric" }
case object DeviceRequestValue extends FHIRAllTypesu45list { override def toString = "DeviceRequest" }
case object DeviceUseStatementValue extends FHIRAllTypesu45list { override def toString = "DeviceUseStatement" }
case object DiagnosticReportValue extends FHIRAllTypesu45list { override def toString = "DiagnosticReport" }
case object DocumentManifestValue extends FHIRAllTypesu45list { override def toString = "DocumentManifest" }
case object DocumentReferenceValue extends FHIRAllTypesu45list { override def toString = "DocumentReference" }
case object DomainResourceValue extends FHIRAllTypesu45list { override def toString = "DomainResource" }
case object EligibilityRequestValue extends FHIRAllTypesu45list { override def toString = "EligibilityRequest" }
case object EligibilityResponseValue extends FHIRAllTypesu45list { override def toString = "EligibilityResponse" }
case object EncounterValue extends FHIRAllTypesu45list { override def toString = "Encounter" }
case object EndpointValue extends FHIRAllTypesu45list { override def toString = "Endpoint" }
case object EnrollmentRequestValue extends FHIRAllTypesu45list { override def toString = "EnrollmentRequest" }
case object EnrollmentResponseValue extends FHIRAllTypesu45list { override def toString = "EnrollmentResponse" }
case object EpisodeOfCareValue extends FHIRAllTypesu45list { override def toString = "EpisodeOfCare" }
case object ExpansionProfileValue extends FHIRAllTypesu45list { override def toString = "ExpansionProfile" }
case object ExplanationOfBenefitValue extends FHIRAllTypesu45list { override def toString = "ExplanationOfBenefit" }
case object FamilyMemberHistoryValue extends FHIRAllTypesu45list { override def toString = "FamilyMemberHistory" }
case object FlagValue extends FHIRAllTypesu45list { override def toString = "Flag" }
case object GoalValue extends FHIRAllTypesu45list { override def toString = "Goal" }
case object GraphDefinitionValue extends FHIRAllTypesu45list { override def toString = "GraphDefinition" }
case object GroupValue2 extends FHIRAllTypesu45list { override def toString = "Group" }
case object GuidanceResponseValue extends FHIRAllTypesu45list { override def toString = "GuidanceResponse" }
case object HealthcareServiceValue extends FHIRAllTypesu45list { override def toString = "HealthcareService" }
case object ImagingManifestValue extends FHIRAllTypesu45list { override def toString = "ImagingManifest" }
case object ImagingStudyValue extends FHIRAllTypesu45list { override def toString = "ImagingStudy" }
case object ImmunizationValue extends FHIRAllTypesu45list { override def toString = "Immunization" }
case object ImmunizationRecommendationValue extends FHIRAllTypesu45list { override def toString = "ImmunizationRecommendation" }
case object ImplementationGuideValue extends FHIRAllTypesu45list { override def toString = "ImplementationGuide" }
case object LibraryValue extends FHIRAllTypesu45list { override def toString = "Library" }
case object LinkageValue extends FHIRAllTypesu45list { override def toString = "Linkage" }
case object ListTypeValue extends FHIRAllTypesu45list { override def toString = "List" }
case object LocationValue extends FHIRAllTypesu45list { override def toString = "Location" }
case object MeasureValue extends FHIRAllTypesu45list { override def toString = "Measure" }
case object MeasureReportValue extends FHIRAllTypesu45list { override def toString = "MeasureReport" }
case object MediaValue extends FHIRAllTypesu45list { override def toString = "Media" }
case object MedicationValue extends FHIRAllTypesu45list { override def toString = "Medication" }
case object MedicationAdministrationValue extends FHIRAllTypesu45list { override def toString = "MedicationAdministration" }
case object MedicationDispenseValue extends FHIRAllTypesu45list { override def toString = "MedicationDispense" }
case object MedicationRequestValue extends FHIRAllTypesu45list { override def toString = "MedicationRequest" }
case object MedicationStatementValue extends FHIRAllTypesu45list { override def toString = "MedicationStatement" }
case object MessageDefinitionValue extends FHIRAllTypesu45list { override def toString = "MessageDefinition" }
case object MessageHeaderValue extends FHIRAllTypesu45list { override def toString = "MessageHeader" }
case object NamingSystemValue extends FHIRAllTypesu45list { override def toString = "NamingSystem" }
case object NutritionOrderValue extends FHIRAllTypesu45list { override def toString = "NutritionOrder" }
case object ObservationValue extends FHIRAllTypesu45list { override def toString = "Observation" }
case object OperationDefinitionValue extends FHIRAllTypesu45list { override def toString = "OperationDefinition" }
case object OperationOutcomeValue extends FHIRAllTypesu45list { override def toString = "OperationOutcome" }
case object OrganizationValue extends FHIRAllTypesu45list { override def toString = "Organization" }
case object ParametersValue extends FHIRAllTypesu45list { override def toString = "Parameters" }
case object PatientValue extends FHIRAllTypesu45list { override def toString = "Patient" }
case object PaymentNoticeValue extends FHIRAllTypesu45list { override def toString = "PaymentNotice" }
case object PaymentReconciliationValue extends FHIRAllTypesu45list { override def toString = "PaymentReconciliation" }
case object PersonValue extends FHIRAllTypesu45list { override def toString = "Person" }
case object PlanDefinitionValue extends FHIRAllTypesu45list { override def toString = "PlanDefinition" }
case object PractitionerValue extends FHIRAllTypesu45list { override def toString = "Practitioner" }
case object PractitionerRoleValue extends FHIRAllTypesu45list { override def toString = "PractitionerRole" }
case object ProcedureValue extends FHIRAllTypesu45list { override def toString = "Procedure" }
case object ProcedureRequestValue extends FHIRAllTypesu45list { override def toString = "ProcedureRequest" }
case object ProcessRequestValue extends FHIRAllTypesu45list { override def toString = "ProcessRequest" }
case object ProcessResponseValue extends FHIRAllTypesu45list { override def toString = "ProcessResponse" }
case object ProvenanceValue extends FHIRAllTypesu45list { override def toString = "Provenance" }
case object QuestionnaireValue extends FHIRAllTypesu45list { override def toString = "Questionnaire" }
case object QuestionnaireResponseValue extends FHIRAllTypesu45list { override def toString = "QuestionnaireResponse" }
case object ReferralRequestValue extends FHIRAllTypesu45list { override def toString = "ReferralRequest" }
case object RelatedPersonValue extends FHIRAllTypesu45list { override def toString = "RelatedPerson" }
case object RequestGroupValue extends FHIRAllTypesu45list { override def toString = "RequestGroup" }
case object ResearchStudyValue extends FHIRAllTypesu45list { override def toString = "ResearchStudy" }
case object ResearchSubjectValue extends FHIRAllTypesu45list { override def toString = "ResearchSubject" }
case object ResourceValue extends FHIRAllTypesu45list { override def toString = "Resource" }
case object RiskAssessmentValue extends FHIRAllTypesu45list { override def toString = "RiskAssessment" }
case object ScheduleValue extends FHIRAllTypesu45list { override def toString = "Schedule" }
case object SearchParameterValue extends FHIRAllTypesu45list { override def toString = "SearchParameter" }
case object SequenceValue extends FHIRAllTypesu45list { override def toString = "Sequence" }
case object ServiceDefinitionValue extends FHIRAllTypesu45list { override def toString = "ServiceDefinition" }
case object SlotValue extends FHIRAllTypesu45list { override def toString = "Slot" }
case object SpecimenValue extends FHIRAllTypesu45list { override def toString = "Specimen" }
case object StructureDefinitionValue extends FHIRAllTypesu45list { override def toString = "StructureDefinition" }
case object StructureMapValue extends FHIRAllTypesu45list { override def toString = "StructureMap" }
case object SubscriptionValue extends FHIRAllTypesu45list { override def toString = "Subscription" }
case object SubstanceValue extends FHIRAllTypesu45list { override def toString = "Substance" }
case object SupplyDeliveryValue extends FHIRAllTypesu45list { override def toString = "SupplyDelivery" }
case object SupplyRequestValue extends FHIRAllTypesu45list { override def toString = "SupplyRequest" }
case object TaskValue extends FHIRAllTypesu45list { override def toString = "Task" }
case object TestReportValue extends FHIRAllTypesu45list { override def toString = "TestReport" }
case object TestScriptValue extends FHIRAllTypesu45list { override def toString = "TestScript" }
case object ValueSetValue2 extends FHIRAllTypesu45list { override def toString = "ValueSet" }
case object VisionPrescriptionValue extends FHIRAllTypesu45list { override def toString = "VisionPrescription" }
case object TypeValue2 extends FHIRAllTypesu45list { override def toString = "Type" }
case object AnyType extends FHIRAllTypesu45list { override def toString = "Any" }


/** If the element is present, it must have either a @value, an @id, or extensions
*/
case class FHIRAllTypes(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[FHIRAllTypesu45list]}
}

      

sealed trait OperationParameterUseu45list

object OperationParameterUseu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[OperationParameterUseu45list]): OperationParameterUseu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: OperationParameterUseu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[OperationParameterUseu45list] = Seq(InValue2, Out)
}

case object InValue2 extends OperationParameterUseu45list { override def toString = "in" }
case object Out extends OperationParameterUseu45list { override def toString = "out" }


/** Whether an operation parameter is an input or an output parameter.If the element is present, it must have either a @value, an @id, or extensions
*/
case class OperationParameterUse(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[OperationParameterUseu45list]}
}

      

sealed trait OperationKindu45list

object OperationKindu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[OperationKindu45list]): OperationKindu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: OperationKindu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[OperationKindu45list] = Seq(Operation, Query)
}

case object Operation extends OperationKindu45list { override def toString = "operation" }
case object Query extends OperationKindu45list { override def toString = "query" }


/** Whether an operation is a normal operation or a query.If the element is present, it must have either a @value, an @id, or extensions
*/
case class OperationKind(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[OperationKindu45list]}
}

      


/** A collection of error, warning or information messages that result from a system action.If the element is present, it must have either a @value, an @id, or extensions
*/
case class OperationOutcomeType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  issue: Seq[OperationOutcomeu46Issue] = Nil) extends DomainResourcable
      


/** A collection of error, warning or information messages that result from a system action.
*/
case class OperationOutcomeu46Issue(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  severity: IssueSeverity,
  code: IssueType,
  details: Option[CodeableConceptType] = None,
  diagnostics: Option[StringTypeType] = None,
  location: Seq[StringTypeType] = Nil,
  expression: Seq[StringTypeType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait IssueTypeu45list

object IssueTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[IssueTypeu45list]): IssueTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: IssueTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[IssueTypeu45list] = Seq(Invalid, Structure, Required, Value, Invariant, Security, Login, UnknownValue, Expired, ForbiddenValue, Suppressed, Processing, Notu45supported, Duplicate, Notu45found, Toou45long, Codeu45invalid, ExtensionValue, Toou45costly, Businessu45rule, ConflictValue, Incomplete, Transient, Locku45error, Nou45store, Exception, Timeout, Throttled, Informational)
}

case object Invalid extends IssueTypeu45list { override def toString = "invalid" }
case object Structure extends IssueTypeu45list { override def toString = "structure" }
case object Required extends IssueTypeu45list { override def toString = "required" }
case object Value extends IssueTypeu45list { override def toString = "value" }
case object Invariant extends IssueTypeu45list { override def toString = "invariant" }
case object Security extends IssueTypeu45list { override def toString = "security" }
case object Login extends IssueTypeu45list { override def toString = "login" }
case object UnknownValue extends IssueTypeu45list { override def toString = "unknown" }
case object Expired extends IssueTypeu45list { override def toString = "expired" }
case object ForbiddenValue extends IssueTypeu45list { override def toString = "forbidden" }
case object Suppressed extends IssueTypeu45list { override def toString = "suppressed" }
case object Processing extends IssueTypeu45list { override def toString = "processing" }
case object Notu45supported extends IssueTypeu45list { override def toString = "not-supported" }
case object Duplicate extends IssueTypeu45list { override def toString = "duplicate" }
case object Notu45found extends IssueTypeu45list { override def toString = "not-found" }
case object Toou45long extends IssueTypeu45list { override def toString = "too-long" }
case object Codeu45invalid extends IssueTypeu45list { override def toString = "code-invalid" }
case object ExtensionValue extends IssueTypeu45list { override def toString = "extension" }
case object Toou45costly extends IssueTypeu45list { override def toString = "too-costly" }
case object Businessu45rule extends IssueTypeu45list { override def toString = "business-rule" }
case object ConflictValue extends IssueTypeu45list { override def toString = "conflict" }
case object Incomplete extends IssueTypeu45list { override def toString = "incomplete" }
case object Transient extends IssueTypeu45list { override def toString = "transient" }
case object Locku45error extends IssueTypeu45list { override def toString = "lock-error" }
case object Nou45store extends IssueTypeu45list { override def toString = "no-store" }
case object Exception extends IssueTypeu45list { override def toString = "exception" }
case object Timeout extends IssueTypeu45list { override def toString = "timeout" }
case object Throttled extends IssueTypeu45list { override def toString = "throttled" }
case object Informational extends IssueTypeu45list { override def toString = "informational" }


/** A code that describes the type of issue.If the element is present, it must have either a @value, an @id, or extensions
*/
case class IssueType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[IssueTypeu45list]}
}

      

sealed trait IssueSeverityu45list

object IssueSeverityu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[IssueSeverityu45list]): IssueSeverityu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: IssueSeverityu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[IssueSeverityu45list] = Seq(Fatal, ErrorValue, Warning, Information)
}

case object Fatal extends IssueSeverityu45list { override def toString = "fatal" }
case object ErrorValue extends IssueSeverityu45list { override def toString = "error" }
case object Warning extends IssueSeverityu45list { override def toString = "warning" }
case object Information extends IssueSeverityu45list { override def toString = "information" }


/** How the issue affects the success of the action.If the element is present, it must have either a @value, an @id, or extensions
*/
case class IssueSeverity(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[IssueSeverityu45list]}
}

      


/** A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, etc.If the element is present, it must have either a @value, an @id, or extensions
*/
case class OrganizationType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  active: Option[BooleanTypeType] = None,
  typeValue: Seq[CodeableConceptType] = Nil,
  name: Option[StringTypeType] = None,
  alias: Seq[StringTypeType] = Nil,
  telecom: Seq[ContactPointType] = Nil,
  address: Seq[AddressType2] = Nil,
  partOf: Option[ReferenceType] = None,
  contact: Seq[Organizationu46Contact] = Nil,
  endpoint: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, etc.
*/
case class Organizationu46Contact(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  purpose: Option[CodeableConceptType] = None,
  name: Option[HumanNameType] = None,
  telecom: Seq[ContactPointType] = Nil,
  address: Option[AddressType2] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This special resource type is used to represent an operation request and response (operations.html). It has no other use, and there is no RESTful endpoint associated with it.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ParametersType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  parameter: Seq[Parametersu46Parameter] = Nil) extends Resourcable
      


/** This special resource type is used to represent an operation request and response (operations.html). It has no other use, and there is no RESTful endpoint associated with it.
*/
case class Parametersu46Parameter(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: StringTypeType,
  valueBase64Binary: Option[Base64BinaryTypeType] = None,
  valueBoolean: Option[BooleanTypeType] = None,
  valueCode: Option[CodeType] = None,
  valueDate: Option[DateType] = None,
  valueDateTime: Option[DateTimeType] = None,
  valueDecimal: Option[DecimalType] = None,
  valueId: Option[IdType] = None,
  valueInstant: Option[InstantType] = None,
  valueInteger: Option[IntegerType] = None,
  valueMarkdown: Option[MarkdownType] = None,
  valueOid: Option[OidType] = None,
  valuePositiveInt: Option[PositiveIntType] = None,
  valueString: Option[StringTypeType] = None,
  valueTime: Option[TimeType] = None,
  valueUnsignedInt: Option[UnsignedIntType] = None,
  valueUri: Option[UriType] = None,
  valueAddress: Option[AddressType2] = None,
  valueAge: Option[AgeType] = None,
  valueAnnotation: Option[AnnotationType] = None,
  valueAttachment: Option[AttachmentType] = None,
  valueCodeableConcept: Option[CodeableConceptType] = None,
  valueCoding: Option[CodingType] = None,
  valueContactPoint: Option[ContactPointType] = None,
  valueCount: Option[CountType] = None,
  valueDistance: Option[DistanceType] = None,
  valueDuration: Option[DurationType] = None,
  valueHumanName: Option[HumanNameType] = None,
  valueIdentifier: Option[IdentifierType] = None,
  valueMoney: Option[MoneyType] = None,
  valuePeriod: Option[PeriodType] = None,
  valueQuantity: Option[Quantityable] = None,
  valueRange: Option[RangeTypeType] = None,
  valueRatio: Option[RatioType] = None,
  valueReference: Option[ReferenceType] = None,
  valueSampledData: Option[SampledDataType] = None,
  valueSignature: Option[SignatureType] = None,
  valueTiming: Option[TimingType] = None,
  valueMeta: Option[MetaType] = None,
  resource: Option[ResourceContainer] = None,
  part: Seq[Parametersu46Parameter] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Demographics and other administrative information about an individual or animal receiving care or other health-related services.If the element is present, it must have either a @value, an @id, or extensions
*/
case class PatientType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  active: Option[BooleanTypeType] = None,
  name: Seq[HumanNameType] = Nil,
  telecom: Seq[ContactPointType] = Nil,
  gender: Option[AdministrativeGender] = None,
  birthDate: Option[DateType] = None,
  deceasedBoolean: Option[BooleanTypeType] = None,
  deceasedDateTime: Option[DateTimeType] = None,
  address: Seq[AddressType2] = Nil,
  maritalStatus: Option[CodeableConceptType] = None,
  multipleBirthBoolean: Option[BooleanTypeType] = None,
  multipleBirthInteger: Option[IntegerType] = None,
  photo: Seq[AttachmentType] = Nil,
  contact: Seq[Patientu46Contact] = Nil,
  animal: Option[Patientu46Animal] = None,
  communication: Seq[Patientu46Communication] = Nil,
  generalPractitioner: Seq[ReferenceType] = Nil,
  managingOrganization: Option[ReferenceType] = None,
  link: Seq[Patientu46Link] = Nil) extends DomainResourcable
      


/** Demographics and other administrative information about an individual or animal receiving care or other health-related services.
*/
case class Patientu46Contact(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  relationship: Seq[CodeableConceptType] = Nil,
  name: Option[HumanNameType] = None,
  telecom: Seq[ContactPointType] = Nil,
  address: Option[AddressType2] = None,
  gender: Option[AdministrativeGender] = None,
  organization: Option[ReferenceType] = None,
  period: Option[PeriodType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Demographics and other administrative information about an individual or animal receiving care or other health-related services.
*/
case class Patientu46Animal(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  species: CodeableConceptType,
  breed: Option[CodeableConceptType] = None,
  genderStatus: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Demographics and other administrative information about an individual or animal receiving care or other health-related services.
*/
case class Patientu46Communication(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  language: CodeableConceptType,
  preferred: Option[BooleanTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Demographics and other administrative information about an individual or animal receiving care or other health-related services.
*/
case class Patientu46Link(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  other: ReferenceType,
  typeValue: LinkType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait LinkTypeu45list

object LinkTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[LinkTypeu45list]): LinkTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: LinkTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[LinkTypeu45list] = Seq(Replacedu45by, ReplacesValue2, Refer, Seealso)
}

case object Replacedu45by extends LinkTypeu45list { override def toString = "replaced-by" }
case object ReplacesValue2 extends LinkTypeu45list { override def toString = "replaces" }
case object Refer extends LinkTypeu45list { override def toString = "refer" }
case object Seealso extends LinkTypeu45list { override def toString = "seealso" }


/** The type of link between this patient resource and another patient resource.If the element is present, it must have either a @value, an @id, or extensions
*/
case class LinkType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[LinkTypeu45list]}
}

      


/** This resource provides the status of the payment for goods and services rendered, and the request and response resource references.If the element is present, it must have either a @value, an @id, or extensions
*/
case class PaymentNoticeType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[FinancialResourceStatusCodes] = None,
  request: Option[ReferenceType] = None,
  response: Option[ReferenceType] = None,
  statusDate: Option[DateType] = None,
  created: Option[DateTimeType] = None,
  target: Option[ReferenceType] = None,
  provider: Option[ReferenceType] = None,
  organization: Option[ReferenceType] = None,
  paymentStatus: Option[CodeableConceptType] = None) extends DomainResourcable
      


/** This resource provides payment details and claim references supporting a bulk payment.If the element is present, it must have either a @value, an @id, or extensions
*/
case class PaymentReconciliationType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[FinancialResourceStatusCodes] = None,
  period: Option[PeriodType] = None,
  created: Option[DateTimeType] = None,
  organization: Option[ReferenceType] = None,
  request: Option[ReferenceType] = None,
  outcome: Option[CodeableConceptType] = None,
  disposition: Option[StringTypeType] = None,
  requestProvider: Option[ReferenceType] = None,
  requestOrganization: Option[ReferenceType] = None,
  detail: Seq[PaymentReconciliationu46Detail] = Nil,
  form: Option[CodeableConceptType] = None,
  total: Option[MoneyType] = None,
  processNote: Seq[PaymentReconciliationu46ProcessNote] = Nil) extends DomainResourcable
      


/** This resource provides payment details and claim references supporting a bulk payment.
*/
case class PaymentReconciliationu46Detail(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: CodeableConceptType,
  request: Option[ReferenceType] = None,
  response: Option[ReferenceType] = None,
  submitter: Option[ReferenceType] = None,
  payee: Option[ReferenceType] = None,
  date: Option[DateType] = None,
  amount: Option[MoneyType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource provides payment details and claim references supporting a bulk payment.
*/
case class PaymentReconciliationu46ProcessNote(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: Option[CodeableConceptType] = None,
  text: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Demographics and administrative information about a person independent of a specific health-related context.If the element is present, it must have either a @value, an @id, or extensions
*/
case class PersonType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  name: Seq[HumanNameType] = Nil,
  telecom: Seq[ContactPointType] = Nil,
  gender: Option[AdministrativeGender] = None,
  birthDate: Option[DateType] = None,
  address: Seq[AddressType2] = Nil,
  photo: Option[AttachmentType] = None,
  managingOrganization: Option[ReferenceType] = None,
  active: Option[BooleanTypeType] = None,
  link: Seq[Personu46Link] = Nil) extends DomainResourcable
      


/** Demographics and administrative information about a person independent of a specific health-related context.
*/
case class Personu46Link(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  target: ReferenceType,
  assurance: Option[IdentityAssuranceLevel] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait IdentityAssuranceLevelu45list

object IdentityAssuranceLevelu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[IdentityAssuranceLevelu45list]): IdentityAssuranceLevelu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: IdentityAssuranceLevelu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[IdentityAssuranceLevelu45list] = Seq(Level1, Level2, Level3, Level4)
}

case object Level1 extends IdentityAssuranceLevelu45list { override def toString = "level1" }
case object Level2 extends IdentityAssuranceLevelu45list { override def toString = "level2" }
case object Level3 extends IdentityAssuranceLevelu45list { override def toString = "level3" }
case object Level4 extends IdentityAssuranceLevelu45list { override def toString = "level4" }


/** The level of confidence that this link represents the same actual person, based on NIST Authentication Levels.If the element is present, it must have either a @value, an @id, or extensions
*/
case class IdentityAssuranceLevel(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[IdentityAssuranceLevelu45list]}
}

      


/** This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical artifacts such as clinical decision support rules, order sets and protocols.If the element is present, it must have either a @value, an @id, or extensions
*/
case class PlanDefinitionType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: Option[UriType] = None,
  identifier: Seq[IdentifierType] = Nil,
  version: Option[StringTypeType] = None,
  name: Option[StringTypeType] = None,
  title: Option[StringTypeType] = None,
  typeValue: Option[CodeableConceptType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  description: Option[MarkdownType] = None,
  purpose: Option[MarkdownType] = None,
  usage: Option[StringTypeType] = None,
  approvalDate: Option[DateType] = None,
  lastReviewDate: Option[DateType] = None,
  effectivePeriod: Option[PeriodType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  topic: Seq[CodeableConceptType] = Nil,
  contributor: Seq[ContributorType2] = Nil,
  contact: Seq[ContactDetailType] = Nil,
  copyright: Option[MarkdownType] = None,
  relatedArtifact: Seq[RelatedArtifactType] = Nil,
  library: Seq[ReferenceType] = Nil,
  goal: Seq[PlanDefinitionu46Goal] = Nil,
  action: Seq[PlanDefinitionu46Action] = Nil) extends DomainResourcable
      


/** This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical artifacts such as clinical decision support rules, order sets and protocols.
*/
case class PlanDefinitionu46Goal(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  category: Option[CodeableConceptType] = None,
  description: CodeableConceptType,
  priority: Option[CodeableConceptType] = None,
  start: Option[CodeableConceptType] = None,
  addresses: Seq[CodeableConceptType] = Nil,
  documentation: Seq[RelatedArtifactType] = Nil,
  target: Seq[PlanDefinitionu46Target] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical artifacts such as clinical decision support rules, order sets and protocols.
*/
case class PlanDefinitionu46Target(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  measure: Option[CodeableConceptType] = None,
  detailQuantity: Option[Quantityable] = None,
  detailRange: Option[RangeTypeType] = None,
  detailCodeableConcept: Option[CodeableConceptType] = None,
  due: Option[DurationType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical artifacts such as clinical decision support rules, order sets and protocols.
*/
case class PlanDefinitionu46Action(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  label: Option[StringTypeType] = None,
  title: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  textEquivalent: Option[StringTypeType] = None,
  code: Seq[CodeableConceptType] = Nil,
  reason: Seq[CodeableConceptType] = Nil,
  documentation: Seq[RelatedArtifactType] = Nil,
  goalId: Seq[IdType] = Nil,
  triggerDefinition: Seq[TriggerDefinitionType] = Nil,
  condition: Seq[PlanDefinitionu46Condition] = Nil,
  input: Seq[DataRequirementType] = Nil,
  output: Seq[DataRequirementType] = Nil,
  relatedAction: Seq[PlanDefinitionu46RelatedAction] = Nil,
  timingDateTime: Option[DateTimeType] = None,
  timingPeriod: Option[PeriodType] = None,
  timingDuration: Option[DurationType] = None,
  timingRange: Option[RangeTypeType] = None,
  timingTiming: Option[TimingType] = None,
  participant: Seq[PlanDefinitionu46Participant] = Nil,
  typeValue: Option[CodingType] = None,
  groupingBehavior: Option[ActionGroupingBehavior] = None,
  selectionBehavior: Option[ActionSelectionBehavior] = None,
  requiredBehavior: Option[ActionRequiredBehavior] = None,
  precheckBehavior: Option[ActionPrecheckBehavior] = None,
  cardinalityBehavior: Option[ActionCardinalityBehavior] = None,
  definition: Option[ReferenceType] = None,
  transform: Option[ReferenceType] = None,
  dynamicValue: Seq[PlanDefinitionu46DynamicValue] = Nil,
  action: Seq[PlanDefinitionu46Action] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical artifacts such as clinical decision support rules, order sets and protocols.
*/
case class PlanDefinitionu46Condition(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  kind: ActionConditionKind,
  description: Option[StringTypeType] = None,
  language: Option[StringTypeType] = None,
  expression: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical artifacts such as clinical decision support rules, order sets and protocols.
*/
case class PlanDefinitionu46RelatedAction(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  actionId: IdType,
  relationship: ActionRelationshipType,
  offsetDuration: Option[DurationType] = None,
  offsetRange: Option[RangeTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical artifacts such as clinical decision support rules, order sets and protocols.
*/
case class PlanDefinitionu46Participant(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: ActionParticipantType,
  role: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical artifacts such as clinical decision support rules, order sets and protocols.
*/
case class PlanDefinitionu46DynamicValue(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  description: Option[StringTypeType] = None,
  path: Option[StringTypeType] = None,
  language: Option[StringTypeType] = None,
  expression: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ActionRequiredBehavioru45list

object ActionRequiredBehavioru45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ActionRequiredBehavioru45list]): ActionRequiredBehavioru45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ActionRequiredBehavioru45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ActionRequiredBehavioru45list] = Seq(Must, Could, Mustu45unlessu45documented)
}

case object Must extends ActionRequiredBehavioru45list { override def toString = "must" }
case object Could extends ActionRequiredBehavioru45list { override def toString = "could" }
case object Mustu45unlessu45documented extends ActionRequiredBehavioru45list { override def toString = "must-unless-documented" }


/** Defines requiredness behavior for selecting an action or an action groupIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ActionRequiredBehavior(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ActionRequiredBehavioru45list]}
}

      

sealed trait ActionRelationshipTypeu45list

object ActionRelationshipTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ActionRelationshipTypeu45list]): ActionRelationshipTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ActionRelationshipTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ActionRelationshipTypeu45list] = Seq(Beforeu45start, Before, Beforeu45end, Concurrentu45withu45start, Concurrent, Concurrentu45withu45end, Afteru45start, After, Afteru45end)
}

case object Beforeu45start extends ActionRelationshipTypeu45list { override def toString = "before-start" }
case object Before extends ActionRelationshipTypeu45list { override def toString = "before" }
case object Beforeu45end extends ActionRelationshipTypeu45list { override def toString = "before-end" }
case object Concurrentu45withu45start extends ActionRelationshipTypeu45list { override def toString = "concurrent-with-start" }
case object Concurrent extends ActionRelationshipTypeu45list { override def toString = "concurrent" }
case object Concurrentu45withu45end extends ActionRelationshipTypeu45list { override def toString = "concurrent-with-end" }
case object Afteru45start extends ActionRelationshipTypeu45list { override def toString = "after-start" }
case object After extends ActionRelationshipTypeu45list { override def toString = "after" }
case object Afteru45end extends ActionRelationshipTypeu45list { override def toString = "after-end" }


/** Defines the types of relationships between actionsIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ActionRelationshipType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ActionRelationshipTypeu45list]}
}

      

sealed trait ActionGroupingBehavioru45list

object ActionGroupingBehavioru45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ActionGroupingBehavioru45list]): ActionGroupingBehavioru45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ActionGroupingBehavioru45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ActionGroupingBehavioru45list] = Seq(Visualu45group, Logicalu45group, Sentenceu45group)
}

case object Visualu45group extends ActionGroupingBehavioru45list { override def toString = "visual-group" }
case object Logicalu45group extends ActionGroupingBehavioru45list { override def toString = "logical-group" }
case object Sentenceu45group extends ActionGroupingBehavioru45list { override def toString = "sentence-group" }


/** Defines organization behavior of a groupIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ActionGroupingBehavior(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ActionGroupingBehavioru45list]}
}

      

sealed trait ActionSelectionBehavioru45list

object ActionSelectionBehavioru45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ActionSelectionBehavioru45list]): ActionSelectionBehavioru45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ActionSelectionBehavioru45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ActionSelectionBehavioru45list] = Seq(AnyTypeValue, AllType, Allu45oru45none, Exactlyu45one, Atu45mostu45one, Oneu45oru45more)
}

case object AnyTypeValue extends ActionSelectionBehavioru45list { override def toString = "any" }
case object AllType extends ActionSelectionBehavioru45list { override def toString = "all" }
case object Allu45oru45none extends ActionSelectionBehavioru45list { override def toString = "all-or-none" }
case object Exactlyu45one extends ActionSelectionBehavioru45list { override def toString = "exactly-one" }
case object Atu45mostu45one extends ActionSelectionBehavioru45list { override def toString = "at-most-one" }
case object Oneu45oru45more extends ActionSelectionBehavioru45list { override def toString = "one-or-more" }


/** Defines selection behavior of a groupIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ActionSelectionBehavior(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ActionSelectionBehavioru45list]}
}

      

sealed trait ActionCardinalityBehavioru45list

object ActionCardinalityBehavioru45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ActionCardinalityBehavioru45list]): ActionCardinalityBehavioru45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ActionCardinalityBehavioru45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ActionCardinalityBehavioru45list] = Seq(SingleValue, MultipleValue)
}

case object SingleValue extends ActionCardinalityBehavioru45list { override def toString = "single" }
case object MultipleValue extends ActionCardinalityBehavioru45list { override def toString = "multiple" }


/** Defines behavior for an action or a group for how many times that item may be repeatedIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ActionCardinalityBehavior(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ActionCardinalityBehavioru45list]}
}

      

sealed trait ActionPrecheckBehavioru45list

object ActionPrecheckBehavioru45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ActionPrecheckBehavioru45list]): ActionPrecheckBehavioru45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ActionPrecheckBehavioru45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ActionPrecheckBehavioru45list] = Seq(Yes, NoValue)
}

case object Yes extends ActionPrecheckBehavioru45list { override def toString = "yes" }
case object NoValue extends ActionPrecheckBehavioru45list { override def toString = "no" }


/** Defines selection frequency behavior for an action or groupIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ActionPrecheckBehavior(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ActionPrecheckBehavioru45list]}
}

      

sealed trait ActionConditionKindu45list

object ActionConditionKindu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ActionConditionKindu45list]): ActionConditionKindu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ActionConditionKindu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ActionConditionKindu45list] = Seq(Applicability, Start, Stop)
}

case object Applicability extends ActionConditionKindu45list { override def toString = "applicability" }
case object Start extends ActionConditionKindu45list { override def toString = "start" }
case object Stop extends ActionConditionKindu45list { override def toString = "stop" }


/** Defines the kinds of conditions that can appear on actionsIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ActionConditionKind(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ActionConditionKindu45list]}
}

      


/** A person who is directly or indirectly involved in the provisioning of healthcare.If the element is present, it must have either a @value, an @id, or extensions
*/
case class PractitionerType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  active: Option[BooleanTypeType] = None,
  name: Seq[HumanNameType] = Nil,
  telecom: Seq[ContactPointType] = Nil,
  address: Seq[AddressType2] = Nil,
  gender: Option[AdministrativeGender] = None,
  birthDate: Option[DateType] = None,
  photo: Seq[AttachmentType] = Nil,
  qualification: Seq[Practitioneru46Qualification] = Nil,
  communication: Seq[CodeableConceptType] = Nil) extends DomainResourcable
      


/** A person who is directly or indirectly involved in the provisioning of healthcare.
*/
case class Practitioneru46Qualification(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  code: CodeableConceptType,
  period: Option[PeriodType] = None,
  issuer: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.If the element is present, it must have either a @value, an @id, or extensions
*/
case class PractitionerRoleType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  active: Option[BooleanTypeType] = None,
  period: Option[PeriodType] = None,
  practitioner: Option[ReferenceType] = None,
  organization: Option[ReferenceType] = None,
  code: Seq[CodeableConceptType] = Nil,
  specialty: Seq[CodeableConceptType] = Nil,
  location: Seq[ReferenceType] = Nil,
  healthcareService: Seq[ReferenceType] = Nil,
  telecom: Seq[ContactPointType] = Nil,
  availableTime: Seq[PractitionerRoleu46AvailableTime] = Nil,
  notAvailable: Seq[PractitionerRoleu46NotAvailable] = Nil,
  availabilityExceptions: Option[StringTypeType] = None,
  endpoint: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
*/
case class PractitionerRoleu46AvailableTime(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  daysOfWeek: Seq[DaysOfWeek] = Nil,
  allDay: Option[BooleanTypeType] = None,
  availableStartTime: Option[TimeType] = None,
  availableEndTime: Option[TimeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
*/
case class PractitionerRoleu46NotAvailable(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  description: StringTypeType,
  during: Option[PeriodType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** An action that is or was performed on a patient. This can be a physical intervention like an operation, or less invasive like counseling or hypnotherapy.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ProcedureType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  definition: Seq[ReferenceType] = Nil,
  basedOn: Seq[ReferenceType] = Nil,
  partOf: Seq[ReferenceType] = Nil,
  status: EventStatus,
  notDone: Option[BooleanTypeType] = None,
  notDoneReason: Option[CodeableConceptType] = None,
  category: Option[CodeableConceptType] = None,
  code: Option[CodeableConceptType] = None,
  subject: ReferenceType,
  context: Option[ReferenceType] = None,
  performedDateTime: Option[DateTimeType] = None,
  performedPeriod: Option[PeriodType] = None,
  performer: Seq[Procedureu46Performer] = Nil,
  location: Option[ReferenceType] = None,
  reasonCode: Seq[CodeableConceptType] = Nil,
  reasonReference: Seq[ReferenceType] = Nil,
  bodySite: Seq[CodeableConceptType] = Nil,
  outcome: Option[CodeableConceptType] = None,
  report: Seq[ReferenceType] = Nil,
  complication: Seq[CodeableConceptType] = Nil,
  complicationDetail: Seq[ReferenceType] = Nil,
  followUp: Seq[CodeableConceptType] = Nil,
  note: Seq[AnnotationType] = Nil,
  focalDevice: Seq[Procedureu46FocalDevice] = Nil,
  usedReference: Seq[ReferenceType] = Nil,
  usedCode: Seq[CodeableConceptType] = Nil) extends DomainResourcable
      


/** An action that is or was performed on a patient. This can be a physical intervention like an operation, or less invasive like counseling or hypnotherapy.
*/
case class Procedureu46Performer(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  role: Option[CodeableConceptType] = None,
  actor: ReferenceType,
  onBehalfOf: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** An action that is or was performed on a patient. This can be a physical intervention like an operation, or less invasive like counseling or hypnotherapy.
*/
case class Procedureu46FocalDevice(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  action: Option[CodeableConceptType] = None,
  manipulated: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A record of a request for diagnostic investigations, treatments, or operations to be performed.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ProcedureRequestType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  definition: Seq[ReferenceType] = Nil,
  basedOn: Seq[ReferenceType] = Nil,
  replaces: Seq[ReferenceType] = Nil,
  requisition: Option[IdentifierType] = None,
  status: RequestStatus,
  intent: RequestIntent,
  priority: Option[RequestPriority] = None,
  doNotPerform: Option[BooleanTypeType] = None,
  category: Seq[CodeableConceptType] = Nil,
  code: CodeableConceptType,
  subject: ReferenceType,
  context: Option[ReferenceType] = None,
  occurrenceDateTime: Option[DateTimeType] = None,
  occurrencePeriod: Option[PeriodType] = None,
  occurrenceTiming: Option[TimingType] = None,
  asNeededBoolean: Option[BooleanTypeType] = None,
  asNeededCodeableConcept: Option[CodeableConceptType] = None,
  authoredOn: Option[DateTimeType] = None,
  requester: Option[ProcedureRequestu46Requester] = None,
  performerType: Option[CodeableConceptType] = None,
  performer: Option[ReferenceType] = None,
  reasonCode: Seq[CodeableConceptType] = Nil,
  reasonReference: Seq[ReferenceType] = Nil,
  supportingInfo: Seq[ReferenceType] = Nil,
  specimen: Seq[ReferenceType] = Nil,
  bodySite: Seq[CodeableConceptType] = Nil,
  note: Seq[AnnotationType] = Nil,
  relevantHistory: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** A record of a request for diagnostic investigations, treatments, or operations to be performed.
*/
case class ProcedureRequestu46Requester(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  agent: ReferenceType,
  onBehalfOf: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait RequestIntentu45list

object RequestIntentu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[RequestIntentu45list]): RequestIntentu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RequestIntentu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[RequestIntentu45list] = Seq(ProposalValue2, PlanValue2, OrderValue2, Originalu45order, Reflexu45order, Filleru45order, Instanceu45orderValue, OptionTypeValue)
}

case object ProposalValue2 extends RequestIntentu45list { override def toString = "proposal" }
case object PlanValue2 extends RequestIntentu45list { override def toString = "plan" }
case object OrderValue2 extends RequestIntentu45list { override def toString = "order" }
case object Originalu45order extends RequestIntentu45list { override def toString = "original-order" }
case object Reflexu45order extends RequestIntentu45list { override def toString = "reflex-order" }
case object Filleru45order extends RequestIntentu45list { override def toString = "filler-order" }
case object Instanceu45orderValue extends RequestIntentu45list { override def toString = "instance-order" }
case object OptionTypeValue extends RequestIntentu45list { override def toString = "option" }


/** The kind of procedure or diagnostic requestIf the element is present, it must have either a @value, an @id, or extensions
*/
case class RequestIntent(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[RequestIntentu45list]}
}

      


/** This resource provides the target, request and response, and action details for an action to be performed by the target on or about existing resources.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ProcessRequestType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[FinancialResourceStatusCodes] = None,
  action: Option[ActionList] = None,
  target: Option[ReferenceType] = None,
  created: Option[DateTimeType] = None,
  provider: Option[ReferenceType] = None,
  organization: Option[ReferenceType] = None,
  request: Option[ReferenceType] = None,
  response: Option[ReferenceType] = None,
  nullify: Option[BooleanTypeType] = None,
  reference: Option[StringTypeType] = None,
  item: Seq[ProcessRequestu46Item] = Nil,
  include: Seq[StringTypeType] = Nil,
  exclude: Seq[StringTypeType] = Nil,
  period: Option[PeriodType] = None) extends DomainResourcable
      


/** This resource provides the target, request and response, and action details for an action to be performed by the target on or about existing resources.
*/
case class ProcessRequestu46Item(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  sequenceLinkId: IntegerType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ActionListu45list

object ActionListu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ActionListu45list]): ActionListu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ActionListu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ActionListu45list] = Seq(Cancel, Poll, Reprocess, Status)
}

case object Cancel extends ActionListu45list { override def toString = "cancel" }
case object Poll extends ActionListu45list { override def toString = "poll" }
case object Reprocess extends ActionListu45list { override def toString = "reprocess" }
case object Status extends ActionListu45list { override def toString = "status" }


/** List of allowable action which this resource can request.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ActionList(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ActionListu45list]}
}

      


/** This resource provides processing status, errors and notes from the processing of a resource.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ProcessResponseType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[FinancialResourceStatusCodes] = None,
  created: Option[DateTimeType] = None,
  organization: Option[ReferenceType] = None,
  request: Option[ReferenceType] = None,
  outcome: Option[CodeableConceptType] = None,
  disposition: Option[StringTypeType] = None,
  requestProvider: Option[ReferenceType] = None,
  requestOrganization: Option[ReferenceType] = None,
  form: Option[CodeableConceptType] = None,
  processNote: Seq[ProcessResponseu46ProcessNote] = Nil,
  error: Seq[CodeableConceptType] = Nil,
  communicationRequest: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** This resource provides processing status, errors and notes from the processing of a resource.
*/
case class ProcessResponseu46ProcessNote(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: Option[CodeableConceptType] = None,
  text: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Provenance of a resource is a record that describes entities and processes involved in producing and delivering or otherwise influencing that resource. Provenance provides a critical foundation for assessing authenticity, enabling trust, and allowing reproducibility. Provenance assertions are a form of contextual metadata and can themselves become important records with their own provenance. Provenance statement indicates clinical significance in terms of confidence in authenticity, reliability, and trustworthiness, integrity, and stage in lifecycle (e.g. Document Completion - has the artifact been legally authenticated), all of which may impact security, privacy, and trust policies.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ProvenanceType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  target: Seq[ReferenceType] = Nil,
  period: Option[PeriodType] = None,
  recorded: InstantType,
  policy: Seq[UriType] = Nil,
  location: Option[ReferenceType] = None,
  reason: Seq[CodingType] = Nil,
  activity: Option[CodingType] = None,
  agent: Seq[Provenanceu46Agent] = Nil,
  entity: Seq[Provenanceu46Entity] = Nil,
  signature: Seq[SignatureType] = Nil) extends DomainResourcable
      


/** Provenance of a resource is a record that describes entities and processes involved in producing and delivering or otherwise influencing that resource. Provenance provides a critical foundation for assessing authenticity, enabling trust, and allowing reproducibility. Provenance assertions are a form of contextual metadata and can themselves become important records with their own provenance. Provenance statement indicates clinical significance in terms of confidence in authenticity, reliability, and trustworthiness, integrity, and stage in lifecycle (e.g. Document Completion - has the artifact been legally authenticated), all of which may impact security, privacy, and trust policies.
*/
case class Provenanceu46Agent(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  role: Seq[CodeableConceptType] = Nil,
  whoUri: Option[UriType] = None,
  whoReference: Option[ReferenceType] = None,
  onBehalfOfUri: Option[UriType] = None,
  onBehalfOfReference: Option[ReferenceType] = None,
  relatedAgentType: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Provenance of a resource is a record that describes entities and processes involved in producing and delivering or otherwise influencing that resource. Provenance provides a critical foundation for assessing authenticity, enabling trust, and allowing reproducibility. Provenance assertions are a form of contextual metadata and can themselves become important records with their own provenance. Provenance statement indicates clinical significance in terms of confidence in authenticity, reliability, and trustworthiness, integrity, and stage in lifecycle (e.g. Document Completion - has the artifact been legally authenticated), all of which may impact security, privacy, and trust policies.
*/
case class Provenanceu46Entity(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  role: ProvenanceEntityRole,
  whatUri: Option[UriType] = None,
  whatReference: Option[ReferenceType] = None,
  whatIdentifier: Option[IdentifierType] = None,
  agent: Seq[Provenanceu46Agent] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ProvenanceEntityRoleu45list

object ProvenanceEntityRoleu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ProvenanceEntityRoleu45list]): ProvenanceEntityRoleu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ProvenanceEntityRoleu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ProvenanceEntityRoleu45list] = Seq(Derivation, Revision, Quotation, SourceValue2, Removal)
}

case object Derivation extends ProvenanceEntityRoleu45list { override def toString = "derivation" }
case object Revision extends ProvenanceEntityRoleu45list { override def toString = "revision" }
case object Quotation extends ProvenanceEntityRoleu45list { override def toString = "quotation" }
case object SourceValue2 extends ProvenanceEntityRoleu45list { override def toString = "source" }
case object Removal extends ProvenanceEntityRoleu45list { override def toString = "removal" }


/** How an entity was used in an activity.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ProvenanceEntityRole(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ProvenanceEntityRoleu45list]}
}

      


/** A structured set of questions intended to guide the collection of answers from end-users. Questionnaires provide detailed control over order, presentation, phraseology and grouping to allow coherent, consistent data collection.If the element is present, it must have either a @value, an @id, or extensions
*/
case class QuestionnaireType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: Option[UriType] = None,
  identifier: Seq[IdentifierType] = Nil,
  version: Option[StringTypeType] = None,
  name: Option[StringTypeType] = None,
  title: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  description: Option[MarkdownType] = None,
  purpose: Option[MarkdownType] = None,
  approvalDate: Option[DateType] = None,
  lastReviewDate: Option[DateType] = None,
  effectivePeriod: Option[PeriodType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  contact: Seq[ContactDetailType] = Nil,
  copyright: Option[MarkdownType] = None,
  code: Seq[CodingType] = Nil,
  subjectType: Seq[ResourceTypeType] = Nil,
  item: Seq[Questionnaireu46Item] = Nil) extends DomainResourcable
      


/** A structured set of questions intended to guide the collection of answers from end-users. Questionnaires provide detailed control over order, presentation, phraseology and grouping to allow coherent, consistent data collection.
*/
case class Questionnaireu46Item(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  linkId: StringTypeType,
  definition: Option[UriType] = None,
  code: Seq[CodingType] = Nil,
  prefix: Option[StringTypeType] = None,
  text: Option[StringTypeType] = None,
  typeValue: QuestionnaireItemType,
  enableWhen: Seq[Questionnaireu46EnableWhen] = Nil,
  required: Option[BooleanTypeType] = None,
  repeats: Option[BooleanTypeType] = None,
  readOnly: Option[BooleanTypeType] = None,
  maxLength: Option[IntegerType] = None,
  options: Option[ReferenceType] = None,
  option: Seq[Questionnaireu46Option] = Nil,
  initialBoolean: Option[BooleanTypeType] = None,
  initialDecimal: Option[DecimalType] = None,
  initialInteger: Option[IntegerType] = None,
  initialDate: Option[DateType] = None,
  initialDateTime: Option[DateTimeType] = None,
  initialTime: Option[TimeType] = None,
  initialString: Option[StringTypeType] = None,
  initialUri: Option[UriType] = None,
  initialAttachment: Option[AttachmentType] = None,
  initialCoding: Option[CodingType] = None,
  initialQuantity: Option[Quantityable] = None,
  initialReference: Option[ReferenceType] = None,
  item: Seq[Questionnaireu46Item] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of questions intended to guide the collection of answers from end-users. Questionnaires provide detailed control over order, presentation, phraseology and grouping to allow coherent, consistent data collection.
*/
case class Questionnaireu46EnableWhen(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  question: StringTypeType,
  hasAnswer: Option[BooleanTypeType] = None,
  answerBoolean: Option[BooleanTypeType] = None,
  answerDecimal: Option[DecimalType] = None,
  answerInteger: Option[IntegerType] = None,
  answerDate: Option[DateType] = None,
  answerDateTime: Option[DateTimeType] = None,
  answerTime: Option[TimeType] = None,
  answerString: Option[StringTypeType] = None,
  answerUri: Option[UriType] = None,
  answerAttachment: Option[AttachmentType] = None,
  answerCoding: Option[CodingType] = None,
  answerQuantity: Option[Quantityable] = None,
  answerReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of questions intended to guide the collection of answers from end-users. Questionnaires provide detailed control over order, presentation, phraseology and grouping to allow coherent, consistent data collection.
*/
case class Questionnaireu46Option(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  valueInteger: Option[IntegerType] = None,
  valueDate: Option[DateType] = None,
  valueTime: Option[TimeType] = None,
  valueString: Option[StringTypeType] = None,
  valueCoding: Option[CodingType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait QuestionnaireItemTypeu45list

object QuestionnaireItemTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[QuestionnaireItemTypeu45list]): QuestionnaireItemTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: QuestionnaireItemTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[QuestionnaireItemTypeu45list] = Seq(GroupValue, Display, BooleanTypeValue, DecimalValue, IntegerValue,
    DateValue, DateTimeValue, TimeValue, StringTypeValue, TextValue, Url, Choice, Openu45choice, AttachmentValue, ReferenceValue2, QuantityValue)
}

case object GroupValue extends QuestionnaireItemTypeu45list { override def toString = "group" }
case object Display extends QuestionnaireItemTypeu45list { override def toString = "display" }
case object BooleanTypeValue extends QuestionnaireItemTypeu45list { override def toString = "boolean" }
case object DecimalValue extends QuestionnaireItemTypeu45list { override def toString = "decimal" }
case object IntegerValue extends QuestionnaireItemTypeu45list { override def toString = "integer" }
case object DateValue extends QuestionnaireItemTypeu45list { override def toString = "date" }
case object DateTimeValue extends QuestionnaireItemTypeu45list { override def toString = "dateTime" }
case object TimeValue extends QuestionnaireItemTypeu45list { override def toString = "time" }
case object StringTypeValue extends QuestionnaireItemTypeu45list { override def toString = "string" }
case object TextValue extends QuestionnaireItemTypeu45list { override def toString = "text" }
case object Url extends QuestionnaireItemTypeu45list { override def toString = "url" }
case object Choice extends QuestionnaireItemTypeu45list { override def toString = "choice" }
case object Openu45choice extends QuestionnaireItemTypeu45list { override def toString = "open-choice" }
case object AttachmentValue extends QuestionnaireItemTypeu45list { override def toString = "attachment" }
case object ReferenceValue2 extends QuestionnaireItemTypeu45list { override def toString = "reference" }
case object QuantityValue extends QuestionnaireItemTypeu45list { override def toString = "quantity" }


/** Distinguishes groups from questions and display text and indicates data type for questionsIf the element is present, it must have either a @value, an @id, or extensions
*/
case class QuestionnaireItemType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[QuestionnaireItemTypeu45list]}
}

      


/** A structured set of questions and their answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the questionnaire being responded to.If the element is present, it must have either a @value, an @id, or extensions
*/
case class QuestionnaireResponseType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  basedOn: Seq[ReferenceType] = Nil,
  parent: Seq[ReferenceType] = Nil,
  questionnaire: Option[ReferenceType] = None,
  status: QuestionnaireResponseStatus,
  subject: Option[ReferenceType] = None,
  context: Option[ReferenceType] = None,
  authored: Option[DateTimeType] = None,
  author: Option[ReferenceType] = None,
  source: Option[ReferenceType] = None,
  item: Seq[QuestionnaireResponseu46Item] = Nil) extends DomainResourcable
      


/** A structured set of questions and their answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the questionnaire being responded to.
*/
case class QuestionnaireResponseu46Item(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  linkId: StringTypeType,
  definition: Option[UriType] = None,
  text: Option[StringTypeType] = None,
  subject: Option[ReferenceType] = None,
  answer: Seq[QuestionnaireResponseu46Answer] = Nil,
  item: Seq[QuestionnaireResponseu46Item] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of questions and their answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the questionnaire being responded to.
*/
case class QuestionnaireResponseu46Answer(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  valueBoolean: Option[BooleanTypeType] = None,
  valueDecimal: Option[DecimalType] = None,
  valueInteger: Option[IntegerType] = None,
  valueDate: Option[DateType] = None,
  valueDateTime: Option[DateTimeType] = None,
  valueTime: Option[TimeType] = None,
  valueString: Option[StringTypeType] = None,
  valueUri: Option[UriType] = None,
  valueAttachment: Option[AttachmentType] = None,
  valueCoding: Option[CodingType] = None,
  valueQuantity: Option[Quantityable] = None,
  valueReference: Option[ReferenceType] = None,
  item: Seq[QuestionnaireResponseu46Item] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait QuestionnaireResponseStatusu45list

object QuestionnaireResponseStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[QuestionnaireResponseStatusu45list]): QuestionnaireResponseStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: QuestionnaireResponseStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[QuestionnaireResponseStatusu45list] = Seq(Inu45progressValue8, CompletedValue16, AmendedValue4, Enteredu45inu45errorValue38, StoppedValue6)
}

case object Inu45progressValue8 extends QuestionnaireResponseStatusu45list { override def toString = "in-progress" }
case object CompletedValue16 extends QuestionnaireResponseStatusu45list { override def toString = "completed" }
case object AmendedValue4 extends QuestionnaireResponseStatusu45list { override def toString = "amended" }
case object Enteredu45inu45errorValue38 extends QuestionnaireResponseStatusu45list { override def toString = "entered-in-error" }
case object StoppedValue6 extends QuestionnaireResponseStatusu45list { override def toString = "stopped" }


/** Lifecycle status of the questionnaire response.If the element is present, it must have either a @value, an @id, or extensions
*/
case class QuestionnaireResponseStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[QuestionnaireResponseStatusu45list]}
}

      


/** Used to record and send details about a request for referral service or transfer of a patient to the care of another provider or provider organization.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ReferralRequestType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  definition: Seq[ReferenceType] = Nil,
  basedOn: Seq[ReferenceType] = Nil,
  replaces: Seq[ReferenceType] = Nil,
  groupIdentifier: Option[IdentifierType] = None,
  status: RequestStatus,
  intent: RequestIntent,
  typeValue: Option[CodeableConceptType] = None,
  priority: Option[RequestPriority] = None,
  serviceRequested: Seq[CodeableConceptType] = Nil,
  subject: ReferenceType,
  context: Option[ReferenceType] = None,
  occurrenceDateTime: Option[DateTimeType] = None,
  occurrencePeriod: Option[PeriodType] = None,
  authoredOn: Option[DateTimeType] = None,
  requester: Option[ReferralRequestu46Requester] = None,
  specialty: Option[CodeableConceptType] = None,
  recipient: Seq[ReferenceType] = Nil,
  reasonCode: Seq[CodeableConceptType] = Nil,
  reasonReference: Seq[ReferenceType] = Nil,
  description: Option[StringTypeType] = None,
  supportingInfo: Seq[ReferenceType] = Nil,
  note: Seq[AnnotationType] = Nil,
  relevantHistory: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** Used to record and send details about a request for referral service or transfer of a patient to the care of another provider or provider organization.
*/
case class ReferralRequestu46Requester(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  agent: ReferenceType,
  onBehalfOf: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Information about a person that is involved in the care for a patient, but who is not the target of healthcare, nor has a formal responsibility in the care process.If the element is present, it must have either a @value, an @id, or extensions
*/
case class RelatedPersonType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  active: Option[BooleanTypeType] = None,
  patient: ReferenceType,
  relationship: Option[CodeableConceptType] = None,
  name: Seq[HumanNameType] = Nil,
  telecom: Seq[ContactPointType] = Nil,
  gender: Option[AdministrativeGender] = None,
  birthDate: Option[DateType] = None,
  address: Seq[AddressType2] = Nil,
  photo: Seq[AttachmentType] = Nil,
  period: Option[PeriodType] = None) extends DomainResourcable
      


/** A group of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one".If the element is present, it must have either a @value, an @id, or extensions
*/
case class RequestGroupType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  definition: Seq[ReferenceType] = Nil,
  basedOn: Seq[ReferenceType] = Nil,
  replaces: Seq[ReferenceType] = Nil,
  groupIdentifier: Option[IdentifierType] = None,
  status: RequestStatus,
  intent: RequestIntent,
  priority: Option[RequestPriority] = None,
  subject: Option[ReferenceType] = None,
  context: Option[ReferenceType] = None,
  authoredOn: Option[DateTimeType] = None,
  author: Option[ReferenceType] = None,
  reasonCodeableConcept: Option[CodeableConceptType] = None,
  reasonReference: Option[ReferenceType] = None,
  note: Seq[AnnotationType] = Nil,
  action: Seq[RequestGroupu46Action] = Nil) extends DomainResourcable
      


/** A group of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one".
*/
case class RequestGroupu46Action(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  label: Option[StringTypeType] = None,
  title: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  textEquivalent: Option[StringTypeType] = None,
  code: Seq[CodeableConceptType] = Nil,
  documentation: Seq[RelatedArtifactType] = Nil,
  condition: Seq[RequestGroupu46Condition] = Nil,
  relatedAction: Seq[RequestGroupu46RelatedAction] = Nil,
  timingDateTime: Option[DateTimeType] = None,
  timingPeriod: Option[PeriodType] = None,
  timingDuration: Option[DurationType] = None,
  timingRange: Option[RangeTypeType] = None,
  timingTiming: Option[TimingType] = None,
  participant: Seq[ReferenceType] = Nil,
  typeValue: Option[CodingType] = None,
  groupingBehavior: Option[ActionGroupingBehavior] = None,
  selectionBehavior: Option[ActionSelectionBehavior] = None,
  requiredBehavior: Option[ActionRequiredBehavior] = None,
  precheckBehavior: Option[ActionPrecheckBehavior] = None,
  cardinalityBehavior: Option[ActionCardinalityBehavior] = None,
  resource: Option[ReferenceType] = None,
  action: Seq[RequestGroupu46Action] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A group of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one".
*/
case class RequestGroupu46Condition(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  kind: ActionConditionKind,
  description: Option[StringTypeType] = None,
  language: Option[StringTypeType] = None,
  expression: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A group of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one".
*/
case class RequestGroupu46RelatedAction(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  actionId: IdType,
  relationship: ActionRelationshipType,
  offsetDuration: Option[DurationType] = None,
  offsetRange: Option[RangeTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A process where a researcher or organization plans and then executes a series of steps intended to increase the field of healthcare-related knowledge.  This includes studies of safety, efficacy, comparative effectiveness and other information about medications, devices, therapies and other interventional and investigative techniques.  A ResearchStudy involves the gathering of information about human or animal subjects.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ResearchStudyType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  title: Option[StringTypeType] = None,
  protocol: Seq[ReferenceType] = Nil,
  partOf: Seq[ReferenceType] = Nil,
  status: ResearchStudyStatus,
  category: Seq[CodeableConceptType] = Nil,
  focus: Seq[CodeableConceptType] = Nil,
  contact: Seq[ContactDetailType] = Nil,
  relatedArtifact: Seq[RelatedArtifactType] = Nil,
  keyword: Seq[CodeableConceptType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  description: Option[MarkdownType] = None,
  enrollment: Seq[ReferenceType] = Nil,
  period: Option[PeriodType] = None,
  sponsor: Option[ReferenceType] = None,
  principalInvestigator: Option[ReferenceType] = None,
  site: Seq[ReferenceType] = Nil,
  reasonStopped: Option[CodeableConceptType] = None,
  note: Seq[AnnotationType] = Nil,
  arm: Seq[ResearchStudyu46Arm] = Nil) extends DomainResourcable
      


/** A process where a researcher or organization plans and then executes a series of steps intended to increase the field of healthcare-related knowledge.  This includes studies of safety, efficacy, comparative effectiveness and other information about medications, devices, therapies and other interventional and investigative techniques.  A ResearchStudy involves the gathering of information about human or animal subjects.
*/
case class ResearchStudyu46Arm(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: StringTypeType,
  code: Option[CodeableConceptType] = None,
  description: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait ResearchStudyStatusu45list

object ResearchStudyStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ResearchStudyStatusu45list]): ResearchStudyStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ResearchStudyStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ResearchStudyStatusu45list] = Seq(DraftValue, Inu45progress, SuspendedValue, Stopped, CompletedValue, Enteredu45inu45errorValue)
}

case object DraftValue extends ResearchStudyStatusu45list { override def toString = "draft" }
case object Inu45progress extends ResearchStudyStatusu45list { override def toString = "in-progress" }
case object SuspendedValue extends ResearchStudyStatusu45list { override def toString = "suspended" }
case object Stopped extends ResearchStudyStatusu45list { override def toString = "stopped" }
case object CompletedValue extends ResearchStudyStatusu45list { override def toString = "completed" }
case object Enteredu45inu45errorValue extends ResearchStudyStatusu45list { override def toString = "entered-in-error" }


/** Codes that convey the current status of the research studyIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ResearchStudyStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ResearchStudyStatusu45list]}
}

      


/** A process where a researcher or organization plans and then executes a series of steps intended to increase the field of healthcare-related knowledge.  This includes studies of safety, efficacy, comparative effectiveness and other information about medications, devices, therapies and other interventional and investigative techniques.  A ResearchStudy involves the gathering of information about human or animal subjects.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ResearchSubjectType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  status: ResearchSubjectStatus,
  period: Option[PeriodType] = None,
  study: ReferenceType,
  individual: ReferenceType,
  assignedArm: Option[StringTypeType] = None,
  actualArm: Option[StringTypeType] = None,
  consent: Option[ReferenceType] = None) extends DomainResourcable
      

sealed trait ResearchSubjectStatusu45list

object ResearchSubjectStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ResearchSubjectStatusu45list]): ResearchSubjectStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ResearchSubjectStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ResearchSubjectStatusu45list] = Seq(Candidate, Enrolled, ActiveValue23, SuspendedValue8, Withdrawn, CompletedValue17)
}

case object Candidate extends ResearchSubjectStatusu45list { override def toString = "candidate" }
case object Enrolled extends ResearchSubjectStatusu45list { override def toString = "enrolled" }
case object ActiveValue23 extends ResearchSubjectStatusu45list { override def toString = "active" }
case object SuspendedValue8 extends ResearchSubjectStatusu45list { override def toString = "suspended" }
case object Withdrawn extends ResearchSubjectStatusu45list { override def toString = "withdrawn" }
case object CompletedValue17 extends ResearchSubjectStatusu45list { override def toString = "completed" }


/** Indicates the progression of a study subject through a studyIf the element is present, it must have either a @value, an @id, or extensions
*/
case class ResearchSubjectStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ResearchSubjectStatusu45list]}
}

      


/** An assessment of the likely outcome(s) for a patient or other subject as well as the likelihood of each outcome.If the element is present, it must have either a @value, an @id, or extensions
*/
case class RiskAssessmentType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  basedOn: Option[ReferenceType] = None,
  parent: Option[ReferenceType] = None,
  status: ObservationStatus,
  method: Option[CodeableConceptType] = None,
  code: Option[CodeableConceptType] = None,
  subject: Option[ReferenceType] = None,
  context: Option[ReferenceType] = None,
  occurrenceDateTime: Option[DateTimeType] = None,
  occurrencePeriod: Option[PeriodType] = None,
  condition: Option[ReferenceType] = None,
  performer: Option[ReferenceType] = None,
  reasonCodeableConcept: Option[CodeableConceptType] = None,
  reasonReference: Option[ReferenceType] = None,
  basis: Seq[ReferenceType] = Nil,
  prediction: Seq[RiskAssessmentu46Prediction] = Nil,
  mitigation: Option[StringTypeType] = None,
  comment: Option[StringTypeType] = None) extends DomainResourcable
      


/** An assessment of the likely outcome(s) for a patient or other subject as well as the likelihood of each outcome.
*/
case class RiskAssessmentu46Prediction(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  outcome: CodeableConceptType,
  probabilityDecimal: Option[DecimalType] = None,
  probabilityRange: Option[RangeTypeType] = None,
  qualitativeRisk: Option[CodeableConceptType] = None,
  relativeRisk: Option[DecimalType] = None,
  whenPeriod: Option[PeriodType] = None,
  whenRange: Option[RangeTypeType] = None,
  rationale: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A container for slots of time that may be available for booking appointments.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ScheduleType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  active: Option[BooleanTypeType] = None,
  serviceCategory: Option[CodeableConceptType] = None,
  serviceType: Seq[CodeableConceptType] = Nil,
  specialty: Seq[CodeableConceptType] = Nil,
  actor: Seq[ReferenceType] = Nil,
  planningHorizon: Option[PeriodType] = None,
  comment: Option[StringTypeType] = None) extends DomainResourcable
      


/** A search parameter that defines a named search item that can be used to search/filter on a resource.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SearchParameterType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: UriType,
  version: Option[StringTypeType] = None,
  name: StringTypeType,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  purpose: Option[MarkdownType] = None,
  code: CodeType,
  base: Seq[ResourceTypeType] = Nil,
  typeValue: SearchParamType,
  derivedFrom: Option[UriType] = None,
  description: MarkdownType,
  expression: Option[StringTypeType] = None,
  xpath: Option[StringTypeType] = None,
  xpathUsage: Option[XPathUsageType] = None,
  target: Seq[ResourceTypeType] = Nil,
  comparator: Seq[SearchComparator] = Nil,
  modifier: Seq[SearchModifierCode] = Nil,
  chain: Seq[StringTypeType] = Nil,
  component: Seq[SearchParameteru46Component] = Nil) extends DomainResourcable
      


/** A search parameter that defines a named search item that can be used to search/filter on a resource.
*/
case class SearchParameteru46Component(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  definition: ReferenceType,
  expression: StringTypeType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait XPathUsageTypeu45list

object XPathUsageTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[XPathUsageTypeu45list]): XPathUsageTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: XPathUsageTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[XPathUsageTypeu45list] = Seq(Normal, Phonetic, Nearby, DistanceValue, Other)
}

case object Normal extends XPathUsageTypeu45list { override def toString = "normal" }
case object Phonetic extends XPathUsageTypeu45list { override def toString = "phonetic" }
case object Nearby extends XPathUsageTypeu45list { override def toString = "nearby" }
case object DistanceValue extends XPathUsageTypeu45list { override def toString = "distance" }
case object Other extends XPathUsageTypeu45list { override def toString = "other" }


/** How a search parameter relates to the set of elements returned by evaluating its xpath query.If the element is present, it must have either a @value, an @id, or extensions
*/
case class XPathUsageType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[XPathUsageTypeu45list]}
}

      

sealed trait SearchModifierCodeu45list

object SearchModifierCodeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[SearchModifierCodeu45list]): SearchModifierCodeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SearchModifierCodeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SearchModifierCodeu45list] = Seq(Missing, Exact, ContainsValue, Not, Text, InValue, Notu45in, Below, Above, TypeValue)
}

case object Missing extends SearchModifierCodeu45list { override def toString = "missing" }
case object Exact extends SearchModifierCodeu45list { override def toString = "exact" }
case object ContainsValue extends SearchModifierCodeu45list { override def toString = "contains" }
case object Not extends SearchModifierCodeu45list { override def toString = "not" }
case object Text extends SearchModifierCodeu45list { override def toString = "text" }
case object InValue extends SearchModifierCodeu45list { override def toString = "in" }
case object Notu45in extends SearchModifierCodeu45list { override def toString = "not-in" }
case object Below extends SearchModifierCodeu45list { override def toString = "below" }
case object Above extends SearchModifierCodeu45list { override def toString = "above" }
case object TypeValue extends SearchModifierCodeu45list { override def toString = "type" }


/** A supported modifier for a search parameter.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SearchModifierCode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[SearchModifierCodeu45list]}
}

      

sealed trait SearchComparatoru45list

object SearchComparatoru45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[SearchComparatoru45list]): SearchComparatoru45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SearchComparatoru45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SearchComparatoru45list] = Seq(Eq, Ne, Gt, Lt, Ge, Le, Sa, Eb, Ap)
}

case object Eq extends SearchComparatoru45list { override def toString = "eq" }
case object Ne extends SearchComparatoru45list { override def toString = "ne" }
case object Gt extends SearchComparatoru45list { override def toString = "gt" }
case object Lt extends SearchComparatoru45list { override def toString = "lt" }
case object Ge extends SearchComparatoru45list { override def toString = "ge" }
case object Le extends SearchComparatoru45list { override def toString = "le" }
case object Sa extends SearchComparatoru45list { override def toString = "sa" }
case object Eb extends SearchComparatoru45list { override def toString = "eb" }
case object Ap extends SearchComparatoru45list { override def toString = "ap" }


/** What Search Comparator Codes are supported in searchIf the element is present, it must have either a @value, an @id, or extensions
*/
case class SearchComparator(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[SearchComparatoru45list]}
}

      


/** Raw data describing a biological sequence.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SequenceType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  typeValue: Option[CodeType] = None,
  coordinateSystem: IntegerType,
  patient: Option[ReferenceType] = None,
  specimen: Option[ReferenceType] = None,
  device: Option[ReferenceType] = None,
  performer: Option[ReferenceType] = None,
  quantity: Option[Quantityable] = None,
  referenceSeq: Option[Sequenceu46ReferenceSeq] = None,
  variant: Seq[Sequenceu46Variant] = Nil,
  observedSeq: Option[StringTypeType] = None,
  quality: Seq[Sequenceu46Quality] = Nil,
  readCoverage: Option[IntegerType] = None,
  repository: Seq[Sequenceu46Repository] = Nil,
  pointer: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** Raw data describing a biological sequence.
*/
case class Sequenceu46ReferenceSeq(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  chromosome: Option[CodeableConceptType] = None,
  genomeBuild: Option[StringTypeType] = None,
  referenceSeqId: Option[CodeableConceptType] = None,
  referenceSeqPointer: Option[ReferenceType] = None,
  referenceSeqString: Option[StringTypeType] = None,
  strand: Option[IntegerType] = None,
  windowStart: IntegerType,
  windowEnd: IntegerType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Raw data describing a biological sequence.
*/
case class Sequenceu46Variant(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  start: Option[IntegerType] = None,
  end: Option[IntegerType] = None,
  observedAllele: Option[StringTypeType] = None,
  referenceAllele: Option[StringTypeType] = None,
  cigar: Option[StringTypeType] = None,
  variantPointer: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Raw data describing a biological sequence.
*/
case class Sequenceu46Quality(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: QualityType,
  standardSequence: Option[CodeableConceptType] = None,
  start: Option[IntegerType] = None,
  end: Option[IntegerType] = None,
  score: Option[Quantityable] = None,
  method: Option[CodeableConceptType] = None,
  truthTP: Option[DecimalType] = None,
  queryTP: Option[DecimalType] = None,
  truthFN: Option[DecimalType] = None,
  queryFP: Option[DecimalType] = None,
  gtFP: Option[DecimalType] = None,
  precision: Option[DecimalType] = None,
  recall: Option[DecimalType] = None,
  fScore: Option[DecimalType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** Raw data describing a biological sequence.
*/
case class Sequenceu46Repository(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: RepositoryType,
  url: Option[UriType] = None,
  name: Option[StringTypeType] = None,
  datasetId: Option[StringTypeType] = None,
  variantsetId: Option[StringTypeType] = None,
  readsetId: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait RepositoryTypeu45list

object RepositoryTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[RepositoryTypeu45list]): RepositoryTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RepositoryTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[RepositoryTypeu45list] = Seq(Directlink, Openapi, LoginValue, Oauth, OtherValue6)
}

case object Directlink extends RepositoryTypeu45list { override def toString = "directlink" }
case object Openapi extends RepositoryTypeu45list { override def toString = "openapi" }
case object LoginValue extends RepositoryTypeu45list { override def toString = "login" }
case object Oauth extends RepositoryTypeu45list { override def toString = "oauth" }
case object OtherValue6 extends RepositoryTypeu45list { override def toString = "other" }


/** Type for access of external URIIf the element is present, it must have either a @value, an @id, or extensions
*/
case class RepositoryType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[RepositoryTypeu45list]}
}

      

sealed trait QualityTypeu45list

object QualityTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[QualityTypeu45list]): QualityTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: QualityTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[QualityTypeu45list] = Seq(Indel, Snp, UnknownValue17)
}

case object Indel extends QualityTypeu45list { override def toString = "indel" }
case object Snp extends QualityTypeu45list { override def toString = "snp" }
case object UnknownValue17 extends QualityTypeu45list { override def toString = "unknown" }


/** Type for quality reportIf the element is present, it must have either a @value, an @id, or extensions
*/
case class QualityType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[QualityTypeu45list]}
}

      


/** The ServiceDefinition describes a unit of decision support functionality that is made available as a service, such as immunization modules or drug-drug interaction checking.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ServiceDefinitionType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: Option[UriType] = None,
  identifier: Seq[IdentifierType] = Nil,
  version: Option[StringTypeType] = None,
  name: Option[StringTypeType] = None,
  title: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  description: Option[MarkdownType] = None,
  purpose: Option[MarkdownType] = None,
  usage: Option[StringTypeType] = None,
  approvalDate: Option[DateType] = None,
  lastReviewDate: Option[DateType] = None,
  effectivePeriod: Option[PeriodType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  topic: Seq[CodeableConceptType] = Nil,
  contributor: Seq[ContributorType2] = Nil,
  contact: Seq[ContactDetailType] = Nil,
  copyright: Option[MarkdownType] = None,
  relatedArtifact: Seq[RelatedArtifactType] = Nil,
  trigger: Seq[TriggerDefinitionType] = Nil,
  dataRequirement: Seq[DataRequirementType] = Nil,
  operationDefinition: Option[ReferenceType] = None) extends DomainResourcable
      


/** A slot of time on a schedule that may be available for booking appointments.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SlotType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  serviceCategory: Option[CodeableConceptType] = None,
  serviceType: Seq[CodeableConceptType] = Nil,
  specialty: Seq[CodeableConceptType] = Nil,
  appointmentType: Option[CodeableConceptType] = None,
  schedule: ReferenceType,
  status: SlotStatus,
  start: InstantType,
  end: InstantType,
  overbooked: Option[BooleanTypeType] = None,
  comment: Option[StringTypeType] = None) extends DomainResourcable
      

sealed trait SlotStatusu45list

object SlotStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[SlotStatusu45list]): SlotStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SlotStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SlotStatusu45list] = Seq(Busy, Free, Busyu45unavailable, Busyu45tentative, Enteredu45inu45errorValue39)
}

case object Busy extends SlotStatusu45list { override def toString = "busy" }
case object Free extends SlotStatusu45list { override def toString = "free" }
case object Busyu45unavailable extends SlotStatusu45list { override def toString = "busy-unavailable" }
case object Busyu45tentative extends SlotStatusu45list { override def toString = "busy-tentative" }
case object Enteredu45inu45errorValue39 extends SlotStatusu45list { override def toString = "entered-in-error" }


/** The free/busy status of the slot.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SlotStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[SlotStatusu45list]}
}

      


/** A sample to be used for analysis.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SpecimenType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  accessionIdentifier: Option[IdentifierType] = None,
  status: Option[SpecimenStatus] = None,
  typeValue: Option[CodeableConceptType] = None,
  subject: ReferenceType,
  receivedTime: Option[DateTimeType] = None,
  parent: Seq[ReferenceType] = Nil,
  request: Seq[ReferenceType] = Nil,
  collection: Option[Specimenu46Collection] = None,
  processing: Seq[Specimenu46Processing] = Nil,
  container: Seq[Specimenu46Container] = Nil,
  note: Seq[AnnotationType] = Nil) extends DomainResourcable
      


/** A sample to be used for analysis.
*/
case class Specimenu46Collection(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  collector: Option[ReferenceType] = None,
  collectedDateTime: Option[DateTimeType] = None,
  collectedPeriod: Option[PeriodType] = None,
  quantity: Option[Quantityable] = None,
  method: Option[CodeableConceptType] = None,
  bodySite: Option[CodeableConceptType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A sample to be used for analysis.
*/
case class Specimenu46Processing(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  description: Option[StringTypeType] = None,
  procedure: Option[CodeableConceptType] = None,
  additive: Seq[ReferenceType] = Nil,
  timeDateTime: Option[DateTimeType] = None,
  timePeriod: Option[PeriodType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A sample to be used for analysis.
*/
case class Specimenu46Container(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  description: Option[StringTypeType] = None,
  typeValue: Option[CodeableConceptType] = None,
  capacity: Option[Quantityable] = None,
  specimenQuantity: Option[Quantityable] = None,
  additiveCodeableConcept: Option[CodeableConceptType] = None,
  additiveReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait SpecimenStatusu45list

object SpecimenStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[SpecimenStatusu45list]): SpecimenStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SpecimenStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SpecimenStatusu45list] = Seq(Available, UnavailableValue, Unsatisfactory, Enteredu45inu45errorValue40)
}

case object Available extends SpecimenStatusu45list { override def toString = "available" }
case object UnavailableValue extends SpecimenStatusu45list { override def toString = "unavailable" }
case object Unsatisfactory extends SpecimenStatusu45list { override def toString = "unsatisfactory" }
case object Enteredu45inu45errorValue40 extends SpecimenStatusu45list { override def toString = "entered-in-error" }


/** Codes providing the status/availability of a specimen.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SpecimenStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[SpecimenStatusu45list]}
}

      


/** A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions and constraints on resources and data types.If the element is present, it must have either a @value, an @id, or extensions
*/
case class StructureDefinitionType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: UriType,
  identifier: Seq[IdentifierType] = Nil,
  version: Option[StringTypeType] = None,
  name: StringTypeType,
  title: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  description: Option[MarkdownType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  purpose: Option[MarkdownType] = None,
  copyright: Option[MarkdownType] = None,
  keyword: Seq[CodingType] = Nil,
  fhirVersion: Option[IdType] = None,
  mapping: Seq[StructureDefinitionu46Mapping] = Nil,
  kind: StructureDefinitionKind,
  abstractValue: BooleanTypeType,
  contextType: Option[ExtensionContext] = None,
  context: Seq[StringTypeType] = Nil,
  contextInvariant: Seq[StringTypeType] = Nil,
  typeValue: CodeType,
  baseDefinition: Option[UriType] = None,
  derivation: Option[TypeDerivationRule] = None,
  snapshot: Option[StructureDefinitionu46Snapshot] = None,
  differential: Option[StructureDefinitionu46Differential] = None) extends DomainResourcable
      


/** A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions and constraints on resources and data types.
*/
case class StructureDefinitionu46Mapping(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identity: IdType,
  uri: Option[UriType] = None,
  name: Option[StringTypeType] = None,
  comment: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions and constraints on resources and data types.
*/
case class StructureDefinitionu46Snapshot(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  element: Seq[ElementDefinitionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions and constraints on resources and data types.
*/
case class StructureDefinitionu46Differential(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  element: Seq[ElementDefinitionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait StructureDefinitionKindu45list

object StructureDefinitionKindu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[StructureDefinitionKindu45list]): StructureDefinitionKindu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: StructureDefinitionKindu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[StructureDefinitionKindu45list] = Seq(Primitiveu45type, Complexu45type, ResourceValue4, LogicalValue)
}

case object Primitiveu45type extends StructureDefinitionKindu45list { override def toString = "primitive-type" }
case object Complexu45type extends StructureDefinitionKindu45list { override def toString = "complex-type" }
case object ResourceValue4 extends StructureDefinitionKindu45list { override def toString = "resource" }
case object LogicalValue extends StructureDefinitionKindu45list { override def toString = "logical" }


/** Defines the type of structure that a definition is describing.If the element is present, it must have either a @value, an @id, or extensions
*/
case class StructureDefinitionKind(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[StructureDefinitionKindu45list]}
}

      

sealed trait TypeDerivationRuleu45list

object TypeDerivationRuleu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[TypeDerivationRuleu45list]): TypeDerivationRuleu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TypeDerivationRuleu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[TypeDerivationRuleu45list] = Seq(Specialization, Constraint)
}

case object Specialization extends TypeDerivationRuleu45list { override def toString = "specialization" }
case object Constraint extends TypeDerivationRuleu45list { override def toString = "constraint" }


/** How a type relates to its baseDefinition.If the element is present, it must have either a @value, an @id, or extensions
*/
case class TypeDerivationRule(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[TypeDerivationRuleu45list]}
}

      

sealed trait ExtensionContextu45list

object ExtensionContextu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ExtensionContextu45list]): ExtensionContextu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ExtensionContextu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ExtensionContextu45list] = Seq(ResourceValue5, Datatype, ExtensionValue3)
}

case object ResourceValue5 extends ExtensionContextu45list { override def toString = "resource" }
case object Datatype extends ExtensionContextu45list { override def toString = "datatype" }
case object ExtensionValue3 extends ExtensionContextu45list { override def toString = "extension" }


/** How an extension context is interpreted.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ExtensionContext(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ExtensionContextu45list]}
}

      


/** A Map of relationships between 2 structures that can be used to transform data.If the element is present, it must have either a @value, an @id, or extensions
*/
case class StructureMapType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: UriType,
  identifier: Seq[IdentifierType] = Nil,
  version: Option[StringTypeType] = None,
  name: StringTypeType,
  title: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  description: Option[MarkdownType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  purpose: Option[MarkdownType] = None,
  copyright: Option[MarkdownType] = None,
  structure: Seq[StructureMapu46Structure] = Nil,
  importValue: Seq[UriType] = Nil,
  group: Seq[StructureMapu46Group] = Nil) extends DomainResourcable
      


/** A Map of relationships between 2 structures that can be used to transform data.
*/
case class StructureMapu46Structure(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: UriType,
  mode: StructureMapModelMode,
  alias: Option[StringTypeType] = None,
  documentation: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Map of relationships between 2 structures that can be used to transform data.
*/
case class StructureMapu46Group(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: IdType,
  extendsValue: Option[IdType] = None,
  typeMode: StructureMapGroupTypeMode,
  documentation: Option[StringTypeType] = None,
  input: Seq[StructureMapu46Input] = Nil,
  rule: Seq[StructureMapu46Rule] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Map of relationships between 2 structures that can be used to transform data.
*/
case class StructureMapu46Input(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: IdType,
  typeValue: Option[StringTypeType] = None,
  mode: StructureMapInputMode,
  documentation: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Map of relationships between 2 structures that can be used to transform data.
*/
case class StructureMapu46Rule(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: IdType,
  source: Seq[StructureMapu46Source] = Nil,
  target: Seq[StructureMapu46Target] = Nil,
  rule: Seq[StructureMapu46Rule] = Nil,
  dependent: Seq[StructureMapu46Dependent] = Nil,
  documentation: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Map of relationships between 2 structures that can be used to transform data.
*/
case class StructureMapu46Source(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  context: IdType,
  min: Option[IntegerType] = None,
  max: Option[StringTypeType] = None,
  typeValue: Option[StringTypeType] = None,
  defaultValueBase64Binary: Option[Base64BinaryTypeType] = None,
  defaultValueBoolean: Option[BooleanTypeType] = None,
  defaultValueCode: Option[CodeType] = None,
  defaultValueDate: Option[DateType] = None,
  defaultValueDateTime: Option[DateTimeType] = None,
  defaultValueDecimal: Option[DecimalType] = None,
  defaultValueId: Option[IdType] = None,
  defaultValueInstant: Option[InstantType] = None,
  defaultValueInteger: Option[IntegerType] = None,
  defaultValueMarkdown: Option[MarkdownType] = None,
  defaultValueOid: Option[OidType] = None,
  defaultValuePositiveInt: Option[PositiveIntType] = None,
  defaultValueString: Option[StringTypeType] = None,
  defaultValueTime: Option[TimeType] = None,
  defaultValueUnsignedInt: Option[UnsignedIntType] = None,
  defaultValueUri: Option[UriType] = None,
  defaultValueAddress: Option[AddressType2] = None,
  defaultValueAge: Option[AgeType] = None,
  defaultValueAnnotation: Option[AnnotationType] = None,
  defaultValueAttachment: Option[AttachmentType] = None,
  defaultValueCodeableConcept: Option[CodeableConceptType] = None,
  defaultValueCoding: Option[CodingType] = None,
  defaultValueContactPoint: Option[ContactPointType] = None,
  defaultValueCount: Option[CountType] = None,
  defaultValueDistance: Option[DistanceType] = None,
  defaultValueDuration: Option[DurationType] = None,
  defaultValueHumanName: Option[HumanNameType] = None,
  defaultValueIdentifier: Option[IdentifierType] = None,
  defaultValueMoney: Option[MoneyType] = None,
  defaultValuePeriod: Option[PeriodType] = None,
  defaultValueQuantity: Option[Quantityable] = None,
  defaultValueRange: Option[RangeTypeType] = None,
  defaultValueRatio: Option[RatioType] = None,
  defaultValueReference: Option[ReferenceType] = None,
  defaultValueSampledData: Option[SampledDataType] = None,
  defaultValueSignature: Option[SignatureType] = None,
  defaultValueTiming: Option[TimingType] = None,
  defaultValueMeta: Option[MetaType] = None,
  element: Option[StringTypeType] = None,
  listMode: Option[StructureMapSourceListMode] = None,
  variable: Option[IdType] = None,
  condition: Option[StringTypeType] = None,
  check: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Map of relationships between 2 structures that can be used to transform data.
*/
case class StructureMapu46Target(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  context: Option[IdType] = None,
  contextType: Option[StructureMapContextType] = None,
  element: Option[StringTypeType] = None,
  variable: Option[IdType] = None,
  listMode: Seq[StructureMapTargetListMode] = Nil,
  listRuleId: Option[IdType] = None,
  transform: Option[StructureMapTransform] = None,
  parameter: Seq[StructureMapu46Parameter] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Map of relationships between 2 structures that can be used to transform data.
*/
case class StructureMapu46Parameter(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  valueId: Option[IdType] = None,
  valueString: Option[StringTypeType] = None,
  valueBoolean: Option[BooleanTypeType] = None,
  valueInteger: Option[IntegerType] = None,
  valueDecimal: Option[DecimalType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A Map of relationships between 2 structures that can be used to transform data.
*/
case class StructureMapu46Dependent(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: IdType,
  variable: Seq[StringTypeType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait StructureMapInputModeu45list

object StructureMapInputModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[StructureMapInputModeu45list]): StructureMapInputModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: StructureMapInputModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[StructureMapInputModeu45list] = Seq(SourceValue, TargetValue)
}

case object SourceValue extends StructureMapInputModeu45list { override def toString = "source" }
case object TargetValue extends StructureMapInputModeu45list { override def toString = "target" }


/** Mode for this instance of dataIf the element is present, it must have either a @value, an @id, or extensions
*/
case class StructureMapInputMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[StructureMapInputModeu45list]}
}

      

sealed trait StructureMapContextTypeu45list

object StructureMapContextTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[StructureMapContextTypeu45list]): StructureMapContextTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: StructureMapContextTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[StructureMapContextTypeu45list] = Seq(Type, Variable)
}

case object Type extends StructureMapContextTypeu45list { override def toString = "type" }
case object Variable extends StructureMapContextTypeu45list { override def toString = "variable" }


/** How to interpret the contextIf the element is present, it must have either a @value, an @id, or extensions
*/
case class StructureMapContextType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[StructureMapContextTypeu45list]}
}

      

sealed trait StructureMapTargetListModeu45list

object StructureMapTargetListModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[StructureMapTargetListModeu45list]): StructureMapTargetListModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: StructureMapTargetListModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[StructureMapTargetListModeu45list] = Seq(FirstValue, Share, LastValue, Collate)
}

case object FirstValue extends StructureMapTargetListModeu45list { override def toString = "first" }
case object Share extends StructureMapTargetListModeu45list { override def toString = "share" }
case object LastValue extends StructureMapTargetListModeu45list { override def toString = "last" }
case object Collate extends StructureMapTargetListModeu45list { override def toString = "collate" }


/** If field is a list, how to manage the productionIf the element is present, it must have either a @value, an @id, or extensions
*/
case class StructureMapTargetListMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[StructureMapTargetListModeu45list]}
}

      

sealed trait StructureMapTransformu45list

object StructureMapTransformu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[StructureMapTransformu45list]): StructureMapTransformu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: StructureMapTransformu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[StructureMapTransformu45list] = Seq(Create, Copy, Truncate, Escape, Cast, Append, Translate, ReferenceValue, DateOp, UuidValue, Pointer, Evaluate, Cc, C, Qty, IdValue, Cp)
}

case object Create extends StructureMapTransformu45list { override def toString = "create" }
case object Copy extends StructureMapTransformu45list { override def toString = "copy" }
case object Truncate extends StructureMapTransformu45list { override def toString = "truncate" }
case object Escape extends StructureMapTransformu45list { override def toString = "escape" }
case object Cast extends StructureMapTransformu45list { override def toString = "cast" }
case object Append extends StructureMapTransformu45list { override def toString = "append" }
case object Translate extends StructureMapTransformu45list { override def toString = "translate" }
case object ReferenceValue extends StructureMapTransformu45list { override def toString = "reference" }
case object DateOp extends StructureMapTransformu45list { override def toString = "dateOp" }
case object UuidValue extends StructureMapTransformu45list { override def toString = "uuid" }
case object Pointer extends StructureMapTransformu45list { override def toString = "pointer" }
case object Evaluate extends StructureMapTransformu45list { override def toString = "evaluate" }
case object Cc extends StructureMapTransformu45list { override def toString = "cc" }
case object C extends StructureMapTransformu45list { override def toString = "c" }
case object Qty extends StructureMapTransformu45list { override def toString = "qty" }
case object IdValue extends StructureMapTransformu45list { override def toString = "id" }
case object Cp extends StructureMapTransformu45list { override def toString = "cp" }


/** How data is copied/createdIf the element is present, it must have either a @value, an @id, or extensions
*/
case class StructureMapTransform(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[StructureMapTransformu45list]}
}

      

sealed trait StructureMapSourceListModeu45list

object StructureMapSourceListModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[StructureMapSourceListModeu45list]): StructureMapSourceListModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: StructureMapSourceListModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[StructureMapSourceListModeu45list] = Seq(First, Not_first, Last, Not_last, Only_one)
}

case object First extends StructureMapSourceListModeu45list { override def toString = "first" }
case object Not_first extends StructureMapSourceListModeu45list { override def toString = "not_first" }
case object Last extends StructureMapSourceListModeu45list { override def toString = "last" }
case object Not_last extends StructureMapSourceListModeu45list { override def toString = "not_last" }
case object Only_one extends StructureMapSourceListModeu45list { override def toString = "only_one" }


/** If field is a list, how to manage the sourceIf the element is present, it must have either a @value, an @id, or extensions
*/
case class StructureMapSourceListMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[StructureMapSourceListModeu45list]}
}

      

sealed trait StructureMapGroupTypeModeu45list

object StructureMapGroupTypeModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[StructureMapGroupTypeModeu45list]): StructureMapGroupTypeModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: StructureMapGroupTypeModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[StructureMapGroupTypeModeu45list] = Seq(NoneTypeValue, Types, Typeu45andu45types)
}

case object NoneTypeValue extends StructureMapGroupTypeModeu45list { override def toString = "none" }
case object Types extends StructureMapGroupTypeModeu45list { override def toString = "types" }
case object Typeu45andu45types extends StructureMapGroupTypeModeu45list { override def toString = "type-and-types" }


/** If this is the default rule set to apply for the source type, or this combination of typesIf the element is present, it must have either a @value, an @id, or extensions
*/
case class StructureMapGroupTypeMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[StructureMapGroupTypeModeu45list]}
}

      

sealed trait StructureMapModelModeu45list

object StructureMapModelModeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[StructureMapModelModeu45list]): StructureMapModelModeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: StructureMapModelModeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[StructureMapModelModeu45list] = Seq(Source, Queried, Target, Produced)
}

case object Source extends StructureMapModelModeu45list { override def toString = "source" }
case object Queried extends StructureMapModelModeu45list { override def toString = "queried" }
case object Target extends StructureMapModelModeu45list { override def toString = "target" }
case object Produced extends StructureMapModelModeu45list { override def toString = "produced" }


/** How the referenced structure is used in this mappingIf the element is present, it must have either a @value, an @id, or extensions
*/
case class StructureMapModelMode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[StructureMapModelModeu45list]}
}

      


/** The subscription resource is used to define a push based subscription from a server to another system. Once a subscription is registered with the server, the server checks every resource that is created or updated, and if the resource matches the given criteria, it sends a message on the defined "channel" so that another system is able to take an appropriate action.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SubscriptionType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  status: SubscriptionStatus,
  contact: Seq[ContactPointType] = Nil,
  end: Option[InstantType] = None,
  reason: StringTypeType,
  criteria: StringTypeType,
  error: Option[StringTypeType] = None,
  channel: Subscriptionu46Channel,
  tag: Seq[CodingType] = Nil) extends DomainResourcable
      


/** The subscription resource is used to define a push based subscription from a server to another system. Once a subscription is registered with the server, the server checks every resource that is created or updated, and if the resource matches the given criteria, it sends a message on the defined "channel" so that another system is able to take an appropriate action.
*/
case class Subscriptionu46Channel(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: SubscriptionChannelType,
  endpoint: Option[UriType] = None,
  payload: Option[StringTypeType] = None,
  header: Seq[StringTypeType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait SubscriptionStatusu45list

object SubscriptionStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[SubscriptionStatusu45list]): SubscriptionStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SubscriptionStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SubscriptionStatusu45list] = Seq(Requested, ActiveValue, Error, Off)
}

case object Requested extends SubscriptionStatusu45list { override def toString = "requested" }
case object ActiveValue extends SubscriptionStatusu45list { override def toString = "active" }
case object Error extends SubscriptionStatusu45list { override def toString = "error" }
case object Off extends SubscriptionStatusu45list { override def toString = "off" }


/** The status of a subscription.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SubscriptionStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[SubscriptionStatusu45list]}
}

      

sealed trait SubscriptionChannelTypeu45list

object SubscriptionChannelTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[SubscriptionChannelTypeu45list]): SubscriptionChannelTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SubscriptionChannelTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SubscriptionChannelTypeu45list] = Seq(Restu45hook, Websocket, Email, Sms, Message)
}

case object Restu45hook extends SubscriptionChannelTypeu45list { override def toString = "rest-hook" }
case object Websocket extends SubscriptionChannelTypeu45list { override def toString = "websocket" }
case object Email extends SubscriptionChannelTypeu45list { override def toString = "email" }
case object Sms extends SubscriptionChannelTypeu45list { override def toString = "sms" }
case object Message extends SubscriptionChannelTypeu45list { override def toString = "message" }


/** The type of method used to execute a subscription.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SubscriptionChannelType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[SubscriptionChannelTypeu45list]}
}

      


/** A homogeneous material with a definite composition.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SubstanceType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[FHIRSubstanceStatus] = None,
  category: Seq[CodeableConceptType] = Nil,
  code: CodeableConceptType,
  description: Option[StringTypeType] = None,
  instance: Seq[Substanceu46Instance] = Nil,
  ingredient: Seq[Substanceu46Ingredient] = Nil) extends DomainResourcable
      


/** A homogeneous material with a definite composition.
*/
case class Substanceu46Instance(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  expiry: Option[DateTimeType] = None,
  quantity: Option[Quantityable] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A homogeneous material with a definite composition.
*/
case class Substanceu46Ingredient(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  quantity: Option[RatioType] = None,
  substanceCodeableConcept: Option[CodeableConceptType] = None,
  substanceReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait FHIRSubstanceStatusu45list

object FHIRSubstanceStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[FHIRSubstanceStatusu45list]): FHIRSubstanceStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: FHIRSubstanceStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[FHIRSubstanceStatusu45list] = Seq(ActiveValue24, InactiveValue9, Enteredu45inu45errorValue41)
}

case object ActiveValue24 extends FHIRSubstanceStatusu45list { override def toString = "active" }
case object InactiveValue9 extends FHIRSubstanceStatusu45list { override def toString = "inactive" }
case object Enteredu45inu45errorValue41 extends FHIRSubstanceStatusu45list { override def toString = "entered-in-error" }


/** A code to indicate if the substance is actively usedIf the element is present, it must have either a @value, an @id, or extensions
*/
case class FHIRSubstanceStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[FHIRSubstanceStatusu45list]}
}

      


/** Record of delivery of what is supplied.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SupplyDeliveryType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  basedOn: Seq[ReferenceType] = Nil,
  partOf: Seq[ReferenceType] = Nil,
  status: Option[SupplyDeliveryStatus] = None,
  patient: Option[ReferenceType] = None,
  typeValue: Option[CodeableConceptType] = None,
  suppliedItem: Option[SupplyDeliveryu46SuppliedItem] = None,
  occurrenceDateTime: Option[DateTimeType] = None,
  occurrencePeriod: Option[PeriodType] = None,
  occurrenceTiming: Option[TimingType] = None,
  supplier: Option[ReferenceType] = None,
  destination: Option[ReferenceType] = None,
  receiver: Seq[ReferenceType] = Nil) extends DomainResourcable
      


/** Record of delivery of what is supplied.
*/
case class SupplyDeliveryu46SuppliedItem(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  quantity: Option[Quantityable] = None,
  itemCodeableConcept: Option[CodeableConceptType] = None,
  itemReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait SupplyDeliveryStatusu45list

object SupplyDeliveryStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[SupplyDeliveryStatusu45list]): SupplyDeliveryStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SupplyDeliveryStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SupplyDeliveryStatusu45list] = Seq(Inu45progressValue9, CompletedValue18, Abandoned, Enteredu45inu45errorValue42)
}

case object Inu45progressValue9 extends SupplyDeliveryStatusu45list { override def toString = "in-progress" }
case object CompletedValue18 extends SupplyDeliveryStatusu45list { override def toString = "completed" }
case object Abandoned extends SupplyDeliveryStatusu45list { override def toString = "abandoned" }
case object Enteredu45inu45errorValue42 extends SupplyDeliveryStatusu45list { override def toString = "entered-in-error" }


/** Status of the supply delivery.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SupplyDeliveryStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[SupplyDeliveryStatusu45list]}
}

      


/** A record of a request for a medication, substance or device used in the healthcare setting.If the element is present, it must have either a @value, an @id, or extensions
*/
case class SupplyRequestType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  status: Option[SupplyRequestStatus] = None,
  category: Option[CodeableConceptType] = None,
  priority: Option[RequestPriority] = None,
  orderedItem: Option[SupplyRequestu46OrderedItem] = None,
  occurrenceDateTime: Option[DateTimeType] = None,
  occurrencePeriod: Option[PeriodType] = None,
  occurrenceTiming: Option[TimingType] = None,
  authoredOn: Option[DateTimeType] = None,
  requester: Option[SupplyRequestu46Requester] = None,
  supplier: Seq[ReferenceType] = Nil,
  reasonCodeableConcept: Option[CodeableConceptType] = None,
  reasonReference: Option[ReferenceType] = None,
  deliverFrom: Option[ReferenceType] = None,
  deliverTo: Option[ReferenceType] = None) extends DomainResourcable
      


/** A record of a request for a medication, substance or device used in the healthcare setting.
*/
case class SupplyRequestu46OrderedItem(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  quantity: Quantityable,
  itemCodeableConcept: Option[CodeableConceptType] = None,
  itemReference: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A record of a request for a medication, substance or device used in the healthcare setting.
*/
case class SupplyRequestu46Requester(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  agent: ReferenceType,
  onBehalfOf: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait SupplyRequestStatusu45list

object SupplyRequestStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[SupplyRequestStatusu45list]): SupplyRequestStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SupplyRequestStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[SupplyRequestStatusu45list] = Seq(Draft, Active, Suspended, Cancelled, Completed, Enteredu45inu45error, Unknown)
}

case object Draft extends SupplyRequestStatusu45list { override def toString = "draft" }
case object Active extends SupplyRequestStatusu45list { override def toString = "active" }
case object Suspended extends SupplyRequestStatusu45list { override def toString = "suspended" }
case object Cancelled extends SupplyRequestStatusu45list { override def toString = "cancelled" }
case object Completed extends SupplyRequestStatusu45list { override def toString = "completed" }
case object Enteredu45inu45error extends SupplyRequestStatusu45list { override def toString = "entered-in-error" }
case object Unknown extends SupplyRequestStatusu45list { override def toString = "unknown" }


/** Status of the supply requestIf the element is present, it must have either a @value, an @id, or extensions
*/
case class SupplyRequestStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[SupplyRequestStatusu45list]}
}

      


/** A task to be performed.If the element is present, it must have either a @value, an @id, or extensions
*/
case class TaskType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  definitionUri: Option[UriType] = None,
  definitionReference: Option[ReferenceType] = None,
  basedOn: Seq[ReferenceType] = Nil,
  groupIdentifier: Option[IdentifierType] = None,
  partOf: Seq[ReferenceType] = Nil,
  status: TaskStatus,
  statusReason: Option[CodeableConceptType] = None,
  businessStatus: Option[CodeableConceptType] = None,
  intent: RequestIntent,
  priority: Option[RequestPriority] = None,
  code: Option[CodeableConceptType] = None,
  description: Option[StringTypeType] = None,
  focus: Option[ReferenceType] = None,
  forValue: Option[ReferenceType] = None,
  context: Option[ReferenceType] = None,
  executionPeriod: Option[PeriodType] = None,
  authoredOn: Option[DateTimeType] = None,
  lastModified: Option[DateTimeType] = None,
  requester: Option[Tasku46Requester] = None,
  performerType: Seq[CodeableConceptType] = Nil,
  owner: Option[ReferenceType] = None,
  reason: Option[CodeableConceptType] = None,
  note: Seq[AnnotationType] = Nil,
  relevantHistory: Seq[ReferenceType] = Nil,
  restriction: Option[Tasku46Restriction] = None,
  input: Seq[Tasku46Input] = Nil,
  output: Seq[Tasku46Output] = Nil) extends DomainResourcable
      


/** A task to be performed.
*/
case class Tasku46Requester(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  agent: ReferenceType,
  onBehalfOf: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A task to be performed.
*/
case class Tasku46Restriction(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  repetitions: Option[PositiveIntType] = None,
  period: Option[PeriodType] = None,
  recipient: Seq[ReferenceType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A task to be performed.
*/
case class Tasku46Input(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: CodeableConceptType,
  valueBase64Binary: Option[Base64BinaryTypeType] = None,
  valueBoolean: Option[BooleanTypeType] = None,
  valueCode: Option[CodeType] = None,
  valueDate: Option[DateType] = None,
  valueDateTime: Option[DateTimeType] = None,
  valueDecimal: Option[DecimalType] = None,
  valueId: Option[IdType] = None,
  valueInstant: Option[InstantType] = None,
  valueInteger: Option[IntegerType] = None,
  valueMarkdown: Option[MarkdownType] = None,
  valueOid: Option[OidType] = None,
  valuePositiveInt: Option[PositiveIntType] = None,
  valueString: Option[StringTypeType] = None,
  valueTime: Option[TimeType] = None,
  valueUnsignedInt: Option[UnsignedIntType] = None,
  valueUri: Option[UriType] = None,
  valueAddress: Option[AddressType2] = None,
  valueAge: Option[AgeType] = None,
  valueAnnotation: Option[AnnotationType] = None,
  valueAttachment: Option[AttachmentType] = None,
  valueCodeableConcept: Option[CodeableConceptType] = None,
  valueCoding: Option[CodingType] = None,
  valueContactPoint: Option[ContactPointType] = None,
  valueCount: Option[CountType] = None,
  valueDistance: Option[DistanceType] = None,
  valueDuration: Option[DurationType] = None,
  valueHumanName: Option[HumanNameType] = None,
  valueIdentifier: Option[IdentifierType] = None,
  valueMoney: Option[MoneyType] = None,
  valuePeriod: Option[PeriodType] = None,
  valueQuantity: Option[Quantityable] = None,
  valueRange: Option[RangeTypeType] = None,
  valueRatio: Option[RatioType] = None,
  valueReference: Option[ReferenceType] = None,
  valueSampledData: Option[SampledDataType] = None,
  valueSignature: Option[SignatureType] = None,
  valueTiming: Option[TimingType] = None,
  valueMeta: Option[MetaType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A task to be performed.
*/
case class Tasku46Output(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: CodeableConceptType,
  valueBase64Binary: Option[Base64BinaryTypeType] = None,
  valueBoolean: Option[BooleanTypeType] = None,
  valueCode: Option[CodeType] = None,
  valueDate: Option[DateType] = None,
  valueDateTime: Option[DateTimeType] = None,
  valueDecimal: Option[DecimalType] = None,
  valueId: Option[IdType] = None,
  valueInstant: Option[InstantType] = None,
  valueInteger: Option[IntegerType] = None,
  valueMarkdown: Option[MarkdownType] = None,
  valueOid: Option[OidType] = None,
  valuePositiveInt: Option[PositiveIntType] = None,
  valueString: Option[StringTypeType] = None,
  valueTime: Option[TimeType] = None,
  valueUnsignedInt: Option[UnsignedIntType] = None,
  valueUri: Option[UriType] = None,
  valueAddress: Option[AddressType2] = None,
  valueAge: Option[AgeType] = None,
  valueAnnotation: Option[AnnotationType] = None,
  valueAttachment: Option[AttachmentType] = None,
  valueCodeableConcept: Option[CodeableConceptType] = None,
  valueCoding: Option[CodingType] = None,
  valueContactPoint: Option[ContactPointType] = None,
  valueCount: Option[CountType] = None,
  valueDistance: Option[DistanceType] = None,
  valueDuration: Option[DurationType] = None,
  valueHumanName: Option[HumanNameType] = None,
  valueIdentifier: Option[IdentifierType] = None,
  valueMoney: Option[MoneyType] = None,
  valuePeriod: Option[PeriodType] = None,
  valueQuantity: Option[Quantityable] = None,
  valueRange: Option[RangeTypeType] = None,
  valueRatio: Option[RatioType] = None,
  valueReference: Option[ReferenceType] = None,
  valueSampledData: Option[SampledDataType] = None,
  valueSignature: Option[SignatureType] = None,
  valueTiming: Option[TimingType] = None,
  valueMeta: Option[MetaType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait TaskStatusu45list

object TaskStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[TaskStatusu45list]): TaskStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TaskStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[TaskStatusu45list] = Seq(DraftValue11, RequestedValue2, Received, AcceptedValue2, RejectedValue3, Ready, CancelledValue15, Inu45progressValue10, Onu45holdValue8, Failed, CompletedValue19, Enteredu45inu45errorValue43)
}

case object DraftValue11 extends TaskStatusu45list { override def toString = "draft" }
case object RequestedValue2 extends TaskStatusu45list { override def toString = "requested" }
case object Received extends TaskStatusu45list { override def toString = "received" }
case object AcceptedValue2 extends TaskStatusu45list { override def toString = "accepted" }
case object RejectedValue3 extends TaskStatusu45list { override def toString = "rejected" }
case object Ready extends TaskStatusu45list { override def toString = "ready" }
case object CancelledValue15 extends TaskStatusu45list { override def toString = "cancelled" }
case object Inu45progressValue10 extends TaskStatusu45list { override def toString = "in-progress" }
case object Onu45holdValue8 extends TaskStatusu45list { override def toString = "on-hold" }
case object Failed extends TaskStatusu45list { override def toString = "failed" }
case object CompletedValue19 extends TaskStatusu45list { override def toString = "completed" }
case object Enteredu45inu45errorValue43 extends TaskStatusu45list { override def toString = "entered-in-error" }


/** The current status of the task.If the element is present, it must have either a @value, an @id, or extensions
*/
case class TaskStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[TaskStatusu45list]}
}

      


/** A summary of information based on the results of executing a TestScript.If the element is present, it must have either a @value, an @id, or extensions
*/
case class TestReportType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Option[IdentifierType] = None,
  name: Option[StringTypeType] = None,
  status: TestReportStatus,
  testScript: ReferenceType,
  result: TestReportResult,
  score: Option[DecimalType] = None,
  tester: Option[StringTypeType] = None,
  issued: Option[DateTimeType] = None,
  participant: Seq[TestReportu46Participant] = Nil,
  setup: Option[TestReportu46Setup] = None,
  test: Seq[TestReportu46Test] = Nil,
  teardown: Option[TestReportu46Teardown] = None) extends DomainResourcable
      


/** A summary of information based on the results of executing a TestScript.
*/
case class TestReportu46Participant(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: TestReportParticipantType,
  uri: UriType,
  display: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A summary of information based on the results of executing a TestScript.
*/
case class TestReportu46Setup(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  action: Seq[TestReportu46Action] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A summary of information based on the results of executing a TestScript.
*/
case class TestReportu46Action(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  operation: Option[TestReportu46Operation] = None,
  assert: Option[TestReportu46Assert] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A summary of information based on the results of executing a TestScript.
*/
case class TestReportu46Operation(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  result: TestReportActionResult,
  message: Option[MarkdownType] = None,
  detail: Option[UriType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A summary of information based on the results of executing a TestScript.
*/
case class TestReportu46Assert(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  result: TestReportActionResult,
  message: Option[MarkdownType] = None,
  detail: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A summary of information based on the results of executing a TestScript.
*/
case class TestReportu46Test(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  action: Seq[TestReportu46Action1] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A summary of information based on the results of executing a TestScript.
*/
case class TestReportu46Action1(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  operation: Option[TestReportu46Operation] = None,
  assert: Option[TestReportu46Assert] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A summary of information based on the results of executing a TestScript.
*/
case class TestReportu46Teardown(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  action: Seq[TestReportu46Action2] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A summary of information based on the results of executing a TestScript.
*/
case class TestReportu46Action2(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  operation: TestReportu46Operation,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait TestReportStatusu45list

object TestReportStatusu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[TestReportStatusu45list]): TestReportStatusu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TestReportStatusu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[TestReportStatusu45list] = Seq(CompletedValue20, Inu45progressValue11, Waiting, StoppedValue7, Enteredu45inu45errorValue44)
}

case object CompletedValue20 extends TestReportStatusu45list { override def toString = "completed" }
case object Inu45progressValue11 extends TestReportStatusu45list { override def toString = "in-progress" }
case object Waiting extends TestReportStatusu45list { override def toString = "waiting" }
case object StoppedValue7 extends TestReportStatusu45list { override def toString = "stopped" }
case object Enteredu45inu45errorValue44 extends TestReportStatusu45list { override def toString = "entered-in-error" }


/** The current status of the test report.If the element is present, it must have either a @value, an @id, or extensions
*/
case class TestReportStatus(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[TestReportStatusu45list]}
}

      

sealed trait TestReportActionResultu45list

object TestReportActionResultu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[TestReportActionResultu45list]): TestReportActionResultu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TestReportActionResultu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[TestReportActionResultu45list] = Seq(Pass, Skip, Fail, WarningValue2, ErrorValue6)
}

case object Pass extends TestReportActionResultu45list { override def toString = "pass" }
case object Skip extends TestReportActionResultu45list { override def toString = "skip" }
case object Fail extends TestReportActionResultu45list { override def toString = "fail" }
case object WarningValue2 extends TestReportActionResultu45list { override def toString = "warning" }
case object ErrorValue6 extends TestReportActionResultu45list { override def toString = "error" }


/** The results of executing an action.If the element is present, it must have either a @value, an @id, or extensions
*/
case class TestReportActionResult(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[TestReportActionResultu45list]}
}

      

sealed trait TestReportParticipantTypeu45list

object TestReportParticipantTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[TestReportParticipantTypeu45list]): TestReportParticipantTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TestReportParticipantTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[TestReportParticipantTypeu45list] = Seq(Testu45engine, ClientValue, ServerValue)
}

case object Testu45engine extends TestReportParticipantTypeu45list { override def toString = "test-engine" }
case object ClientValue extends TestReportParticipantTypeu45list { override def toString = "client" }
case object ServerValue extends TestReportParticipantTypeu45list { override def toString = "server" }


/** The type of participant.If the element is present, it must have either a @value, an @id, or extensions
*/
case class TestReportParticipantType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[TestReportParticipantTypeu45list]}
}

      

sealed trait TestReportResultu45list

object TestReportResultu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[TestReportResultu45list]): TestReportResultu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TestReportResultu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[TestReportResultu45list] = Seq(PassValue, FailValue, PendingValue2)
}

case object PassValue extends TestReportResultu45list { override def toString = "pass" }
case object FailValue extends TestReportResultu45list { override def toString = "fail" }
case object PendingValue2 extends TestReportResultu45list { override def toString = "pending" }


/** The reported execution result.If the element is present, it must have either a @value, an @id, or extensions
*/
case class TestReportResult(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[TestReportResultu45list]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.If the element is present, it must have either a @value, an @id, or extensions
*/
case class TestScriptType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: UriType,
  identifier: Option[IdentifierType] = None,
  version: Option[StringTypeType] = None,
  name: StringTypeType,
  title: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  description: Option[MarkdownType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  purpose: Option[MarkdownType] = None,
  copyright: Option[MarkdownType] = None,
  origin: Seq[TestScriptu46Origin] = Nil,
  destination: Seq[TestScriptu46Destination] = Nil,
  metadata: Option[TestScriptu46Metadata] = None,
  fixture: Seq[TestScriptu46Fixture] = Nil,
  profile: Seq[ReferenceType] = Nil,
  variable: Seq[TestScriptu46Variable] = Nil,
  rule: Seq[TestScriptu46Rule] = Nil,
  ruleset: Seq[TestScriptu46Ruleset] = Nil,
  setup: Option[TestScriptu46Setup] = None,
  test: Seq[TestScriptu46Test] = Nil,
  teardown: Option[TestScriptu46Teardown] = None) extends DomainResourcable
      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Origin(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  index: IntegerType,
  profile: CodingType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Destination(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  index: IntegerType,
  profile: CodingType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Metadata(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  link: Seq[TestScriptu46Link] = Nil,
  capability: Seq[TestScriptu46Capability] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Link(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: UriType,
  description: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Capability(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  required: Option[BooleanTypeType] = None,
  validated: Option[BooleanTypeType] = None,
  description: Option[StringTypeType] = None,
  origin: Seq[IntegerType] = Nil,
  destination: Option[IntegerType] = None,
  link: Seq[UriType] = Nil,
  capabilities: ReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Fixture(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  autocreate: Option[BooleanTypeType] = None,
  autodelete: Option[BooleanTypeType] = None,
  resource: Option[ReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Variable(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: StringTypeType,
  defaultValue: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  expression: Option[StringTypeType] = None,
  headerField: Option[StringTypeType] = None,
  hint: Option[StringTypeType] = None,
  path: Option[StringTypeType] = None,
  sourceId: Option[IdType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Rule(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  resource: ReferenceType,
  param: Seq[TestScriptu46Param] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Param(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: StringTypeType,
  value: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Ruleset(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  resource: ReferenceType,
  rule: Seq[TestScriptu46Rule1] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Rule1(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  ruleId: IdType,
  param: Seq[TestScriptu46Param1] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Param1(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: StringTypeType,
  value: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Setup(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  action: Seq[TestScriptu46Action] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Action(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  operation: Option[TestScriptu46Operation] = None,
  assert: Option[TestScriptu46Assert] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Operation(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  typeValue: Option[CodingType] = None,
  resource: Option[FHIRDefinedType] = None,
  label: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  accept: Option[ContentType] = None,
  contentType: Option[ContentType] = None,
  destination: Option[IntegerType] = None,
  encodeRequestUrl: Option[BooleanTypeType] = None,
  origin: Option[IntegerType] = None,
  params: Option[StringTypeType] = None,
  requestHeader: Seq[TestScriptu46RequestHeader] = Nil,
  requestId: Option[IdType] = None,
  responseId: Option[IdType] = None,
  sourceId: Option[IdType] = None,
  targetId: Option[IdType] = None,
  url: Option[StringTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46RequestHeader(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  field: StringTypeType,
  value: StringTypeType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Assert(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  label: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  direction: Option[AssertionDirectionType] = None,
  compareToSourceId: Option[StringTypeType] = None,
  compareToSourceExpression: Option[StringTypeType] = None,
  compareToSourcePath: Option[StringTypeType] = None,
  contentType: Option[ContentType] = None,
  expression: Option[StringTypeType] = None,
  headerField: Option[StringTypeType] = None,
  minimumId: Option[StringTypeType] = None,
  navigationLinks: Option[BooleanTypeType] = None,
  operator: Option[AssertionOperatorType] = None,
  path: Option[StringTypeType] = None,
  requestMethod: Option[TestScriptRequestMethodCode] = None,
  requestURL: Option[StringTypeType] = None,
  resource: Option[FHIRDefinedType] = None,
  response: Option[AssertionResponseTypes] = None,
  responseCode: Option[StringTypeType] = None,
  rule: Option[TestScriptu46Rule2] = None,
  ruleset: Option[TestScriptu46Ruleset1] = None,
  sourceId: Option[IdType] = None,
  validateProfileId: Option[IdType] = None,
  value: Option[StringTypeType] = None,
  warningOnly: Option[BooleanTypeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Rule2(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  ruleId: IdType,
  param: Seq[TestScriptu46Param2] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Param2(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: StringTypeType,
  value: StringTypeType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Ruleset1(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  rulesetId: IdType,
  rule: Seq[TestScriptu46Rule3] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Rule3(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  ruleId: IdType,
  param: Seq[TestScriptu46Param3] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Param3(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: StringTypeType,
  value: StringTypeType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Test(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: Option[StringTypeType] = None,
  description: Option[StringTypeType] = None,
  action: Seq[TestScriptu46Action1] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Action1(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  operation: Option[TestScriptu46Operation] = None,
  assert: Option[TestScriptu46Assert] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Teardown(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  action: Seq[TestScriptu46Action2] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
*/
case class TestScriptu46Action2(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  operation: TestScriptu46Operation,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait FHIRDefinedTypeu45list

object FHIRDefinedTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[FHIRDefinedTypeu45list]): FHIRDefinedTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: FHIRDefinedTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[FHIRDefinedTypeu45list] = Seq(Address, Age, Annotation, Attachment, BackboneElement, CodeableConcept, Coding, ContactDetail, ContactPoint, Contributor, Count, DataRequirement, Distance, Dosage, Duration, Element, ElementDefinition, Extension, HumanName, Identifier, Meta, Money, Narrative, ParameterDefinition, Period, Quantity, RangeType, Ratio, Reference, RelatedArtifact, SampledData, Signature, SimpleQuantity, Timing, TriggerDefinition, UsageContext, Base64BinaryType, BooleanType, Code, Date, DateTime, Decimal, Id, Instant, Integer, Markdown, Oid, PositiveInt, StringType, Time, UnsignedInt, Uri, Uuid, Xhtml, Account, ActivityDefinition, AdverseEvent, AllergyIntolerance, Appointment, AppointmentResponse, AuditEvent, Basic, Binary, BodySite, Bundle, CapabilityStatement, CarePlan, CareTeam, ChargeItem, Claim, ClaimResponse, ClinicalImpression, CodeSystem, Communication, CommunicationRequest, CompartmentDefinition, Composition, ConceptMap, Condition, Consent, Contract, Coverage, DataElement, DetectedIssue, Device, DeviceComponent, DeviceMetric, DeviceRequest, DeviceUseStatement, DiagnosticReport, DocumentManifest, DocumentReference, DomainResource, EligibilityRequest, EligibilityResponse, Encounter, Endpoint, EnrollmentRequest, EnrollmentResponse, EpisodeOfCare, ExpansionProfile, ExplanationOfBenefit, FamilyMemberHistory, Flag, Goal, GraphDefinition, Group, GuidanceResponse, HealthcareService, ImagingManifest, ImagingStudy, Immunization, ImmunizationRecommendation, ImplementationGuide, Library, Linkage, ListType, Location, Measure, MeasureReport, Media, Medication, MedicationAdministration, MedicationDispense, MedicationRequest, MedicationStatement, MessageDefinition, MessageHeader, NamingSystem, NutritionOrder, Observation, OperationDefinition, OperationOutcome, Organization, Parameters, Patient, PaymentNotice, PaymentReconciliation, Person, PlanDefinition, Practitioner, PractitionerRole, Procedure, ProcedureRequest, ProcessRequest, ProcessResponse, Provenance, Questionnaire, QuestionnaireResponse, ReferralRequest, RelatedPerson, RequestGroup, ResearchStudy, ResearchSubject, Resource, RiskAssessment, Schedule, SearchParameter, Sequence, ServiceDefinition, Slot, Specimen, StructureDefinition, StructureMap, Subscription, Substance, SupplyDelivery, SupplyRequest, Task, TestReport, TestScript, ValueSetValue, VisionPrescription)
}

case object Address extends FHIRDefinedTypeu45list { override def toString = "Address" }
case object Age extends FHIRDefinedTypeu45list { override def toString = "Age" }
case object Annotation extends FHIRDefinedTypeu45list { override def toString = "Annotation" }
case object Attachment extends FHIRDefinedTypeu45list { override def toString = "Attachment" }
case object BackboneElement extends FHIRDefinedTypeu45list { override def toString = "BackboneElement" }
case object CodeableConcept extends FHIRDefinedTypeu45list { override def toString = "CodeableConcept" }
case object Coding extends FHIRDefinedTypeu45list { override def toString = "Coding" }
case object ContactDetail extends FHIRDefinedTypeu45list { override def toString = "ContactDetail" }
case object ContactPoint extends FHIRDefinedTypeu45list { override def toString = "ContactPoint" }
case object Contributor extends FHIRDefinedTypeu45list { override def toString = "Contributor" }
case object Count extends FHIRDefinedTypeu45list { override def toString = "Count" }
case object DataRequirement extends FHIRDefinedTypeu45list { override def toString = "DataRequirement" }
case object Distance extends FHIRDefinedTypeu45list { override def toString = "Distance" }
case object Dosage extends FHIRDefinedTypeu45list { override def toString = "Dosage" }
case object Duration extends FHIRDefinedTypeu45list { override def toString = "Duration" }
case object Element extends FHIRDefinedTypeu45list { override def toString = "Element" }
case object ElementDefinition extends FHIRDefinedTypeu45list { override def toString = "ElementDefinition" }
case object Extension extends FHIRDefinedTypeu45list { override def toString = "Extension" }
case object HumanName extends FHIRDefinedTypeu45list { override def toString = "HumanName" }
case object Identifier extends FHIRDefinedTypeu45list { override def toString = "Identifier" }
case object Meta extends FHIRDefinedTypeu45list { override def toString = "Meta" }
case object Money extends FHIRDefinedTypeu45list { override def toString = "Money" }
case object Narrative extends FHIRDefinedTypeu45list { override def toString = "Narrative" }
case object ParameterDefinition extends FHIRDefinedTypeu45list { override def toString = "ParameterDefinition" }
case object Period extends FHIRDefinedTypeu45list { override def toString = "Period" }
case object Quantity extends FHIRDefinedTypeu45list { override def toString = "Quantity" }
case object RangeType extends FHIRDefinedTypeu45list { override def toString = "Range" }
case object Ratio extends FHIRDefinedTypeu45list { override def toString = "Ratio" }
case object Reference extends FHIRDefinedTypeu45list { override def toString = "Reference" }
case object RelatedArtifact extends FHIRDefinedTypeu45list { override def toString = "RelatedArtifact" }
case object SampledData extends FHIRDefinedTypeu45list { override def toString = "SampledData" }
case object Signature extends FHIRDefinedTypeu45list { override def toString = "Signature" }
case object SimpleQuantity extends FHIRDefinedTypeu45list { override def toString = "SimpleQuantity" }
case object Timing extends FHIRDefinedTypeu45list { override def toString = "Timing" }
case object TriggerDefinition extends FHIRDefinedTypeu45list { override def toString = "TriggerDefinition" }
case object UsageContext extends FHIRDefinedTypeu45list { override def toString = "UsageContext" }
case object Base64BinaryType extends FHIRDefinedTypeu45list { override def toString = "base64Binary" }
case object BooleanType extends FHIRDefinedTypeu45list { override def toString = "boolean" }
case object Code extends FHIRDefinedTypeu45list { override def toString = "code" }
case object Date extends FHIRDefinedTypeu45list { override def toString = "date" }
case object DateTime extends FHIRDefinedTypeu45list { override def toString = "dateTime" }
case object Decimal extends FHIRDefinedTypeu45list { override def toString = "decimal" }
case object Id extends FHIRDefinedTypeu45list { override def toString = "id" }
case object Instant extends FHIRDefinedTypeu45list { override def toString = "instant" }
case object Integer extends FHIRDefinedTypeu45list { override def toString = "integer" }
case object Markdown extends FHIRDefinedTypeu45list { override def toString = "markdown" }
case object Oid extends FHIRDefinedTypeu45list { override def toString = "oid" }
case object PositiveInt extends FHIRDefinedTypeu45list { override def toString = "positiveInt" }
case object StringType extends FHIRDefinedTypeu45list { override def toString = "string" }
case object Time extends FHIRDefinedTypeu45list { override def toString = "time" }
case object UnsignedInt extends FHIRDefinedTypeu45list { override def toString = "unsignedInt" }
case object Uri extends FHIRDefinedTypeu45list { override def toString = "uri" }
case object Uuid extends FHIRDefinedTypeu45list { override def toString = "uuid" }
case object Xhtml extends FHIRDefinedTypeu45list { override def toString = "xhtml" }
case object Account extends FHIRDefinedTypeu45list { override def toString = "Account" }
case object ActivityDefinition extends FHIRDefinedTypeu45list { override def toString = "ActivityDefinition" }
case object AdverseEvent extends FHIRDefinedTypeu45list { override def toString = "AdverseEvent" }
case object AllergyIntolerance extends FHIRDefinedTypeu45list { override def toString = "AllergyIntolerance" }
case object Appointment extends FHIRDefinedTypeu45list { override def toString = "Appointment" }
case object AppointmentResponse extends FHIRDefinedTypeu45list { override def toString = "AppointmentResponse" }
case object AuditEvent extends FHIRDefinedTypeu45list { override def toString = "AuditEvent" }
case object Basic extends FHIRDefinedTypeu45list { override def toString = "Basic" }
case object Binary extends FHIRDefinedTypeu45list { override def toString = "Binary" }
case object BodySite extends FHIRDefinedTypeu45list { override def toString = "BodySite" }
case object Bundle extends FHIRDefinedTypeu45list { override def toString = "Bundle" }
case object CapabilityStatement extends FHIRDefinedTypeu45list { override def toString = "CapabilityStatement" }
case object CarePlan extends FHIRDefinedTypeu45list { override def toString = "CarePlan" }
case object CareTeam extends FHIRDefinedTypeu45list { override def toString = "CareTeam" }
case object ChargeItem extends FHIRDefinedTypeu45list { override def toString = "ChargeItem" }
case object Claim extends FHIRDefinedTypeu45list { override def toString = "Claim" }
case object ClaimResponse extends FHIRDefinedTypeu45list { override def toString = "ClaimResponse" }
case object ClinicalImpression extends FHIRDefinedTypeu45list { override def toString = "ClinicalImpression" }
case object CodeSystem extends FHIRDefinedTypeu45list { override def toString = "CodeSystem" }
case object Communication extends FHIRDefinedTypeu45list { override def toString = "Communication" }
case object CommunicationRequest extends FHIRDefinedTypeu45list { override def toString = "CommunicationRequest" }
case object CompartmentDefinition extends FHIRDefinedTypeu45list { override def toString = "CompartmentDefinition" }
case object Composition extends FHIRDefinedTypeu45list { override def toString = "Composition" }
case object ConceptMap extends FHIRDefinedTypeu45list { override def toString = "ConceptMap" }
case object Condition extends FHIRDefinedTypeu45list { override def toString = "Condition" }
case object Consent extends FHIRDefinedTypeu45list { override def toString = "Consent" }
case object Contract extends FHIRDefinedTypeu45list { override def toString = "Contract" }
case object Coverage extends FHIRDefinedTypeu45list { override def toString = "Coverage" }
case object DataElement extends FHIRDefinedTypeu45list { override def toString = "DataElement" }
case object DetectedIssue extends FHIRDefinedTypeu45list { override def toString = "DetectedIssue" }
case object Device extends FHIRDefinedTypeu45list { override def toString = "Device" }
case object DeviceComponent extends FHIRDefinedTypeu45list { override def toString = "DeviceComponent" }
case object DeviceMetric extends FHIRDefinedTypeu45list { override def toString = "DeviceMetric" }
case object DeviceRequest extends FHIRDefinedTypeu45list { override def toString = "DeviceRequest" }
case object DeviceUseStatement extends FHIRDefinedTypeu45list { override def toString = "DeviceUseStatement" }
case object DiagnosticReport extends FHIRDefinedTypeu45list { override def toString = "DiagnosticReport" }
case object DocumentManifest extends FHIRDefinedTypeu45list { override def toString = "DocumentManifest" }
case object DocumentReference extends FHIRDefinedTypeu45list { override def toString = "DocumentReference" }
case object DomainResource extends FHIRDefinedTypeu45list { override def toString = "DomainResource" }
case object EligibilityRequest extends FHIRDefinedTypeu45list { override def toString = "EligibilityRequest" }
case object EligibilityResponse extends FHIRDefinedTypeu45list { override def toString = "EligibilityResponse" }
case object Encounter extends FHIRDefinedTypeu45list { override def toString = "Encounter" }
case object Endpoint extends FHIRDefinedTypeu45list { override def toString = "Endpoint" }
case object EnrollmentRequest extends FHIRDefinedTypeu45list { override def toString = "EnrollmentRequest" }
case object EnrollmentResponse extends FHIRDefinedTypeu45list { override def toString = "EnrollmentResponse" }
case object EpisodeOfCare extends FHIRDefinedTypeu45list { override def toString = "EpisodeOfCare" }
case object ExpansionProfile extends FHIRDefinedTypeu45list { override def toString = "ExpansionProfile" }
case object ExplanationOfBenefit extends FHIRDefinedTypeu45list { override def toString = "ExplanationOfBenefit" }
case object FamilyMemberHistory extends FHIRDefinedTypeu45list { override def toString = "FamilyMemberHistory" }
case object Flag extends FHIRDefinedTypeu45list { override def toString = "Flag" }
case object Goal extends FHIRDefinedTypeu45list { override def toString = "Goal" }
case object GraphDefinition extends FHIRDefinedTypeu45list { override def toString = "GraphDefinition" }
case object Group extends FHIRDefinedTypeu45list { override def toString = "Group" }
case object GuidanceResponse extends FHIRDefinedTypeu45list { override def toString = "GuidanceResponse" }
case object HealthcareService extends FHIRDefinedTypeu45list { override def toString = "HealthcareService" }
case object ImagingManifest extends FHIRDefinedTypeu45list { override def toString = "ImagingManifest" }
case object ImagingStudy extends FHIRDefinedTypeu45list { override def toString = "ImagingStudy" }
case object Immunization extends FHIRDefinedTypeu45list { override def toString = "Immunization" }
case object ImmunizationRecommendation extends FHIRDefinedTypeu45list { override def toString = "ImmunizationRecommendation" }
case object ImplementationGuide extends FHIRDefinedTypeu45list { override def toString = "ImplementationGuide" }
case object Library extends FHIRDefinedTypeu45list { override def toString = "Library" }
case object Linkage extends FHIRDefinedTypeu45list { override def toString = "Linkage" }
case object ListType extends FHIRDefinedTypeu45list { override def toString = "List" }
case object Location extends FHIRDefinedTypeu45list { override def toString = "Location" }
case object Measure extends FHIRDefinedTypeu45list { override def toString = "Measure" }
case object MeasureReport extends FHIRDefinedTypeu45list { override def toString = "MeasureReport" }
case object Media extends FHIRDefinedTypeu45list { override def toString = "Media" }
case object Medication extends FHIRDefinedTypeu45list { override def toString = "Medication" }
case object MedicationAdministration extends FHIRDefinedTypeu45list { override def toString = "MedicationAdministration" }
case object MedicationDispense extends FHIRDefinedTypeu45list { override def toString = "MedicationDispense" }
case object MedicationRequest extends FHIRDefinedTypeu45list { override def toString = "MedicationRequest" }
case object MedicationStatement extends FHIRDefinedTypeu45list { override def toString = "MedicationStatement" }
case object MessageDefinition extends FHIRDefinedTypeu45list { override def toString = "MessageDefinition" }
case object MessageHeader extends FHIRDefinedTypeu45list { override def toString = "MessageHeader" }
case object NamingSystem extends FHIRDefinedTypeu45list { override def toString = "NamingSystem" }
case object NutritionOrder extends FHIRDefinedTypeu45list { override def toString = "NutritionOrder" }
case object Observation extends FHIRDefinedTypeu45list { override def toString = "Observation" }
case object OperationDefinition extends FHIRDefinedTypeu45list { override def toString = "OperationDefinition" }
case object OperationOutcome extends FHIRDefinedTypeu45list { override def toString = "OperationOutcome" }
case object Organization extends FHIRDefinedTypeu45list { override def toString = "Organization" }
case object Parameters extends FHIRDefinedTypeu45list { override def toString = "Parameters" }
case object Patient extends FHIRDefinedTypeu45list { override def toString = "Patient" }
case object PaymentNotice extends FHIRDefinedTypeu45list { override def toString = "PaymentNotice" }
case object PaymentReconciliation extends FHIRDefinedTypeu45list { override def toString = "PaymentReconciliation" }
case object Person extends FHIRDefinedTypeu45list { override def toString = "Person" }
case object PlanDefinition extends FHIRDefinedTypeu45list { override def toString = "PlanDefinition" }
case object Practitioner extends FHIRDefinedTypeu45list { override def toString = "Practitioner" }
case object PractitionerRole extends FHIRDefinedTypeu45list { override def toString = "PractitionerRole" }
case object Procedure extends FHIRDefinedTypeu45list { override def toString = "Procedure" }
case object ProcedureRequest extends FHIRDefinedTypeu45list { override def toString = "ProcedureRequest" }
case object ProcessRequest extends FHIRDefinedTypeu45list { override def toString = "ProcessRequest" }
case object ProcessResponse extends FHIRDefinedTypeu45list { override def toString = "ProcessResponse" }
case object Provenance extends FHIRDefinedTypeu45list { override def toString = "Provenance" }
case object Questionnaire extends FHIRDefinedTypeu45list { override def toString = "Questionnaire" }
case object QuestionnaireResponse extends FHIRDefinedTypeu45list { override def toString = "QuestionnaireResponse" }
case object ReferralRequest extends FHIRDefinedTypeu45list { override def toString = "ReferralRequest" }
case object RelatedPerson extends FHIRDefinedTypeu45list { override def toString = "RelatedPerson" }
case object RequestGroup extends FHIRDefinedTypeu45list { override def toString = "RequestGroup" }
case object ResearchStudy extends FHIRDefinedTypeu45list { override def toString = "ResearchStudy" }
case object ResearchSubject extends FHIRDefinedTypeu45list { override def toString = "ResearchSubject" }
case object Resource extends FHIRDefinedTypeu45list { override def toString = "Resource" }
case object RiskAssessment extends FHIRDefinedTypeu45list { override def toString = "RiskAssessment" }
case object Schedule extends FHIRDefinedTypeu45list { override def toString = "Schedule" }
case object SearchParameter extends FHIRDefinedTypeu45list { override def toString = "SearchParameter" }
case object Sequence extends FHIRDefinedTypeu45list { override def toString = "Sequence" }
case object ServiceDefinition extends FHIRDefinedTypeu45list { override def toString = "ServiceDefinition" }
case object Slot extends FHIRDefinedTypeu45list { override def toString = "Slot" }
case object Specimen extends FHIRDefinedTypeu45list { override def toString = "Specimen" }
case object StructureDefinition extends FHIRDefinedTypeu45list { override def toString = "StructureDefinition" }
case object StructureMap extends FHIRDefinedTypeu45list { override def toString = "StructureMap" }
case object Subscription extends FHIRDefinedTypeu45list { override def toString = "Subscription" }
case object Substance extends FHIRDefinedTypeu45list { override def toString = "Substance" }
case object SupplyDelivery extends FHIRDefinedTypeu45list { override def toString = "SupplyDelivery" }
case object SupplyRequest extends FHIRDefinedTypeu45list { override def toString = "SupplyRequest" }
case object Task extends FHIRDefinedTypeu45list { override def toString = "Task" }
case object TestReport extends FHIRDefinedTypeu45list { override def toString = "TestReport" }
case object TestScript extends FHIRDefinedTypeu45list { override def toString = "TestScript" }
case object ValueSetValue extends FHIRDefinedTypeu45list { override def toString = "ValueSet" }
case object VisionPrescription extends FHIRDefinedTypeu45list { override def toString = "VisionPrescription" }


/** If the element is present, it must have either a @value, an @id, or extensions
*/
case class FHIRDefinedType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[FHIRDefinedTypeu45list]}
}

      

sealed trait ContentTypeu45list

object ContentTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[ContentTypeu45list]): ContentTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ContentTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ContentTypeu45list] = Seq(Xml, Json, Ttl, NoneType)
}

case object Xml extends ContentTypeu45list { override def toString = "xml" }
case object Json extends ContentTypeu45list { override def toString = "json" }
case object Ttl extends ContentTypeu45list { override def toString = "ttl" }
case object NoneType extends ContentTypeu45list { override def toString = "none" }


/** The content or mime type.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ContentType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[ContentTypeu45list]}
}

      

sealed trait AssertionDirectionTypeu45list

object AssertionDirectionTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AssertionDirectionTypeu45list]): AssertionDirectionTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AssertionDirectionTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AssertionDirectionTypeu45list] = Seq(Response, Request)
}

case object Response extends AssertionDirectionTypeu45list { override def toString = "response" }
case object Request extends AssertionDirectionTypeu45list { override def toString = "request" }


/** The type of direction to use for assertion.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AssertionDirectionType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AssertionDirectionTypeu45list]}
}

      

sealed trait AssertionOperatorTypeu45list

object AssertionOperatorTypeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AssertionOperatorTypeu45list]): AssertionOperatorTypeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AssertionOperatorTypeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AssertionOperatorTypeu45list] = Seq(Equals, NotEquals, In, NotIn, GreaterThan, LessThan, Empty, NotEmpty, Contains, NotContains, Eval)
}

case object Equals extends AssertionOperatorTypeu45list { override def toString = "equals" }
case object NotEquals extends AssertionOperatorTypeu45list { override def toString = "notEquals" }
case object In extends AssertionOperatorTypeu45list { override def toString = "in" }
case object NotIn extends AssertionOperatorTypeu45list { override def toString = "notIn" }
case object GreaterThan extends AssertionOperatorTypeu45list { override def toString = "greaterThan" }
case object LessThan extends AssertionOperatorTypeu45list { override def toString = "lessThan" }
case object Empty extends AssertionOperatorTypeu45list { override def toString = "empty" }
case object NotEmpty extends AssertionOperatorTypeu45list { override def toString = "notEmpty" }
case object Contains extends AssertionOperatorTypeu45list { override def toString = "contains" }
case object NotContains extends AssertionOperatorTypeu45list { override def toString = "notContains" }
case object Eval extends AssertionOperatorTypeu45list { override def toString = "eval" }


/** The type of operator to use for assertion.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AssertionOperatorType(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AssertionOperatorTypeu45list]}
}

      

sealed trait AssertionResponseTypesu45list

object AssertionResponseTypesu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[AssertionResponseTypesu45list]): AssertionResponseTypesu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AssertionResponseTypesu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[AssertionResponseTypesu45list] = Seq(Okay, Created, NoContent, NotModified, Bad, Forbidden, NotFound, MethodNotAllowed, Conflict, Gone, PreconditionFailed, Unprocessable)
}

case object Okay extends AssertionResponseTypesu45list { override def toString = "okay" }
case object Created extends AssertionResponseTypesu45list { override def toString = "created" }
case object NoContent extends AssertionResponseTypesu45list { override def toString = "noContent" }
case object NotModified extends AssertionResponseTypesu45list { override def toString = "notModified" }
case object Bad extends AssertionResponseTypesu45list { override def toString = "bad" }
case object Forbidden extends AssertionResponseTypesu45list { override def toString = "forbidden" }
case object NotFound extends AssertionResponseTypesu45list { override def toString = "notFound" }
case object MethodNotAllowed extends AssertionResponseTypesu45list { override def toString = "methodNotAllowed" }
case object Conflict extends AssertionResponseTypesu45list { override def toString = "conflict" }
case object Gone extends AssertionResponseTypesu45list { override def toString = "gone" }
case object PreconditionFailed extends AssertionResponseTypesu45list { override def toString = "preconditionFailed" }
case object Unprocessable extends AssertionResponseTypesu45list { override def toString = "unprocessable" }


/** The type of response code to use for assertion.If the element is present, it must have either a @value, an @id, or extensions
*/
case class AssertionResponseTypes(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[AssertionResponseTypesu45list]}
}

      

sealed trait TestScriptRequestMethodCodeu45list

object TestScriptRequestMethodCodeu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[TestScriptRequestMethodCodeu45list]): TestScriptRequestMethodCodeu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TestScriptRequestMethodCodeu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[TestScriptRequestMethodCodeu45list] = Seq(Delete, Get, Options, Patch, Post, Put)
}

case object Delete extends TestScriptRequestMethodCodeu45list { override def toString = "delete" }
case object Get extends TestScriptRequestMethodCodeu45list { override def toString = "get" }
case object Options extends TestScriptRequestMethodCodeu45list { override def toString = "options" }
case object Patch extends TestScriptRequestMethodCodeu45list { override def toString = "patch" }
case object Post extends TestScriptRequestMethodCodeu45list { override def toString = "post" }
case object Put extends TestScriptRequestMethodCodeu45list { override def toString = "put" }


/** The allowable request method or HTTP operation codes.If the element is present, it must have either a @value, an @id, or extensions
*/
case class TestScriptRequestMethodCode(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[TestScriptRequestMethodCodeu45list]}
}

      


/** A value set specifies a set of codes drawn from one or more code systems.If the element is present, it must have either a @value, an @id, or extensions
*/
case class ValueSet(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  url: Option[UriType] = None,
  identifier: Seq[IdentifierType] = Nil,
  version: Option[StringTypeType] = None,
  name: Option[StringTypeType] = None,
  title: Option[StringTypeType] = None,
  status: PublicationStatus,
  experimental: Option[BooleanTypeType] = None,
  date: Option[DateTimeType] = None,
  publisher: Option[StringTypeType] = None,
  contact: Seq[ContactDetailType] = Nil,
  description: Option[MarkdownType] = None,
  useContext: Seq[UsageContextType] = Nil,
  jurisdiction: Seq[CodeableConceptType] = Nil,
  immutable: Option[BooleanTypeType] = None,
  purpose: Option[MarkdownType] = None,
  copyright: Option[MarkdownType] = None,
  extensible: Option[BooleanTypeType] = None,
  compose: Option[ValueSetu46Compose] = None,
  expansion: Option[ValueSetu46Expansion] = None) extends DomainResourcable
      


/** A value set specifies a set of codes drawn from one or more code systems.
*/
case class ValueSetu46Compose(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  lockedDate: Option[DateType] = None,
  inactive: Option[BooleanTypeType] = None,
  include: Seq[ValueSetu46Include] = Nil,
  exclude: Seq[ValueSetu46Include] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A value set specifies a set of codes drawn from one or more code systems.
*/
case class ValueSetu46Include(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  system: Option[UriType] = None,
  version: Option[StringTypeType] = None,
  concept: Seq[ValueSetu46Concept] = Nil,
  filter: Seq[ValueSetu46Filter] = Nil,
  valueSet: Seq[UriType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A value set specifies a set of codes drawn from one or more code systems.
*/
case class ValueSetu46Concept(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  code: CodeType,
  display: Option[StringTypeType] = None,
  designation: Seq[ValueSetu46Designation] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A value set specifies a set of codes drawn from one or more code systems.
*/
case class ValueSetu46Designation(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  language: Option[CodeType] = None,
  use: Option[CodingType] = None,
  value: StringTypeType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A value set specifies a set of codes drawn from one or more code systems.
*/
case class ValueSetu46Filter(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  property: CodeType,
  op: FilterOperator,
  value: CodeType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A value set specifies a set of codes drawn from one or more code systems.
*/
case class ValueSetu46Expansion(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: UriType,
  timestamp: DateTimeType,
  total: Option[IntegerType] = None,
  offset: Option[IntegerType] = None,
  parameter: Seq[ValueSetu46Parameter] = Nil,
  contains: Seq[ValueSetu46Contains] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A value set specifies a set of codes drawn from one or more code systems.
*/
case class ValueSetu46Parameter(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  name: StringTypeType,
  valueString: Option[StringTypeType] = None,
  valueBoolean: Option[BooleanTypeType] = None,
  valueInteger: Option[IntegerType] = None,
  valueDecimal: Option[DecimalType] = None,
  valueUri: Option[UriType] = None,
  valueCode: Option[CodeType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** A value set specifies a set of codes drawn from one or more code systems.
*/
case class ValueSetu46Contains(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  system: Option[UriType] = None,
  abstractValue: Option[BooleanTypeType] = None,
  inactive: Option[BooleanTypeType] = None,
  version: Option[StringTypeType] = None,
  code: Option[CodeType] = None,
  display: Option[StringTypeType] = None,
  designation: Seq[ValueSetu46Designation] = Nil,
  contains: Seq[ValueSetu46Contains] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      


/** An authorization for the supply of glasses and/or contact lenses to a patient.If the element is present, it must have either a @value, an @id, or extensions
*/
case class VisionPrescriptionType(id: Option[IdType] = None,
  meta: Option[MetaType] = None,
  implicitRules: Option[UriType] = None,
  language: Option[CodeType] = None,
  text: Option[NarrativeType] = None,
  contained: Seq[ResourceContainer] = Nil,
  extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  identifier: Seq[IdentifierType] = Nil,
  status: Option[FinancialResourceStatusCodes] = None,
  patient: Option[ReferenceType] = None,
  encounter: Option[ReferenceType] = None,
  dateWritten: Option[DateTimeType] = None,
  prescriber: Option[ReferenceType] = None,
  reasonCodeableConcept: Option[CodeableConceptType] = None,
  reasonReference: Option[ReferenceType] = None,
  dispense: Seq[VisionPrescriptionu46Dispense] = Nil) extends DomainResourcable
      


/** An authorization for the supply of glasses and/or contact lenses to a patient.
*/
case class VisionPrescriptionu46Dispense(extension: Seq[ExtensionType] = Nil,
  modifierExtension: Seq[ExtensionType] = Nil,
  product: Option[CodeableConceptType] = None,
  eye: Option[VisionEyes] = None,
  sphere: Option[DecimalType] = None,
  cylinder: Option[DecimalType] = None,
  axis: Option[IntegerType] = None,
  prism: Option[DecimalType] = None,
  base: Option[VisionBase] = None,
  add: Option[DecimalType] = None,
  power: Option[DecimalType] = None,
  backCurve: Option[DecimalType] = None,
  diameter: Option[DecimalType] = None,
  duration: Option[Quantityable] = None,
  color: Option[StringTypeType] = None,
  brand: Option[StringTypeType] = None,
  note: Seq[AnnotationType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends BackboneElementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      

sealed trait VisionBaseu45list

object VisionBaseu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[VisionBaseu45list]): VisionBaseu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: VisionBaseu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[VisionBaseu45list] = Seq(Up, Down, InValue4, OutValue)
}

case object Up extends VisionBaseu45list { override def toString = "up" }
case object Down extends VisionBaseu45list { override def toString = "down" }
case object InValue4 extends VisionBaseu45list { override def toString = "in" }
case object OutValue extends VisionBaseu45list { override def toString = "out" }


/** A coded concept listing the base codes.If the element is present, it must have either a @value, an @id, or extensions
*/
case class VisionBase(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[VisionBaseu45list]}
}

      

sealed trait VisionEyesu45list

object VisionEyesu45list {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[VisionEyesu45list]): VisionEyesu45list = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: VisionEyesu45list) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[VisionEyesu45list] = Seq(RightType, LeftType)
}

case object RightType extends VisionEyesu45list { override def toString = "right" }
case object LeftType extends VisionEyesu45list { override def toString = "left" }


/** A coded concept listing the eye codes.If the element is present, it must have either a @value, an @id, or extensions
*/
case class VisionEyes(extension: Seq[ExtensionType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Elementable {
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[VisionEyesu45list]}
}

      

